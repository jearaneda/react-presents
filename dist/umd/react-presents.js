!function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("react"), require("react-dom")) : "function" == typeof define && define.amd ? define([ "react", "react-dom" ], factory) : "object" == typeof exports ? exports.ReactPresents = factory(require("react"), require("react-dom")) : root.ReactPresents = factory(root.React, root.ReactDOM);
}(this, function(__WEBPACK_EXTERNAL_MODULE_108__, __WEBPACK_EXTERNAL_MODULE_120__) {
    /******/
    return function(modules) {
        /******/
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: !1
            };
            /******/
            /******/
            // Return the exports of the module
            /******/
            /******/
            /******/
            // Execute the module function
            /******/
            /******/
            /******/
            // Flag the module as loaded
            /******/
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/
        // Load entry module and return exports
        /******/
        /******/
        /******/
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/
        // expose the module cache
        /******/
        /******/
        /******/
        // __webpack_public_path__
        /******/
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ /* 0 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) return obj;
            var newObj = {};
            if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
            return newObj.default = obj, newObj;
        }
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.TitleSlide = exports.Step = exports.Slide = exports.PropTypes = exports.PresenterModePlugin = exports.Presentation = exports.IconButton = exports.DropDownNav = exports.ContentSlide = exports.Code = void 0;
        var _Code = __webpack_require__(1), _Code2 = _interopRequireDefault(_Code), _ContentSlide = __webpack_require__(144), _ContentSlide2 = _interopRequireDefault(_ContentSlide), _DropDownNav = __webpack_require__(146), _DropDownNav2 = _interopRequireDefault(_DropDownNav), _IconButton = __webpack_require__(203), _IconButton2 = _interopRequireDefault(_IconButton), _Presentation = __webpack_require__(208), _Presentation2 = _interopRequireDefault(_Presentation), _PresenterModePlugin = __webpack_require__(256), _PresenterModePlugin2 = _interopRequireDefault(_PresenterModePlugin), _PropTypes = __webpack_require__(206), PropTypes = _interopRequireWildcard(_PropTypes), _Slide = __webpack_require__(263), _Slide2 = _interopRequireDefault(_Slide), _Step = __webpack_require__(264), _Step2 = _interopRequireDefault(_Step), _TitleSlide = __webpack_require__(265), _TitleSlide2 = _interopRequireDefault(_TitleSlide);
        exports.Code = _Code2.default, exports.ContentSlide = _ContentSlide2.default, exports.DropDownNav = _DropDownNav2.default, 
        exports.IconButton = _IconButton2.default, exports.Presentation = _Presentation2.default, 
        exports.PresenterModePlugin = _PresenterModePlugin2.default, exports.PropTypes = PropTypes, 
        exports.Slide = _Slide2.default, exports.Step = _Step2.default, exports.TitleSlide = _TitleSlide2.default;
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _slicedToArray2 = __webpack_require__(43), _slicedToArray3 = _interopRequireDefault(_slicedToArray2), _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n.cm-s-reactpresents.CodeMirror {\n  height: auto;\n  border-radius: 0.5rem;\n  padding: 1rem;\n  background-color: #222 !important;\n  color: #f8f8f2 !important;\n  font-size: 12px;\n  border: none;\n}\n\n.cm-s-reactpresents.CodeMirror-focused div.CodeMirror-selected {\n  background: rgba(255, 255, 255, 0.10);\n}\n\n.cm-s-reactpresents {\n  .CodeMirror-sizer {\n    min-height: auto !important;\n  }\n\n  .CodeMirror-gutters {\n    background-color: #222 !important;\n    color: #f8f8f2 !important;\n    font-size: 12px;\n    border: none;\n  }\n  .CodeMirror-gutters { color: #222; }\n  .CodeMirror-cursor { border-left: solid thin #ddd; }\n  .CodeMirror-linenumber { cololibr: #75715e; }\n  .CodeMirror-line::selection,\n  .CodeMirror-line > span::selection,\n  .CodeMirror-line > span > span::selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  .CodeMirror-line::-moz-selection,\n  .CodeMirror-line > span::-moz-selection,\n  .CodeMirror-line > span > span::-moz-selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  span.cm-comment { color: #75715e; }\n  span.cm-string,\n  span.cm-string-2 { color: #f1fa8c; }\n  span.cm-number { color: #bd93f9; }\n  span.cm-variable { color: #ddd; }\n  span.cm-variable-2 { color: white; }\n  span.cm-def { color: #a6e22e; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-operator { color: #f92672; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-atom { color: #bd93f9; }\n  span.cm-meta { color: #f8f8f2; }\n  span.cm-tag { color: #f92672; }\n  span.cm-attribute { color: #ddd; }\n  span.cm-qualifier { color: #a6e22e; }\n  span.cm-property { color: #66d9ef; }\n  span.cm-builtin { color: #a6e22e; }\n  span.cm-variable-3 { color: #a6e22e; }\n\n  .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }\n  .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\n\n  span.cm-bracket { color: #900; }\n\n  span.dim {\n    opacity: 0.5;\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n  }\n\n  span.highlight {\n    background-color: rgba(189,147,249, .2);\n  }\n}\n" ], [ "\n.cm-s-reactpresents.CodeMirror {\n  height: auto;\n  border-radius: 0.5rem;\n  padding: 1rem;\n  background-color: #222 !important;\n  color: #f8f8f2 !important;\n  font-size: 12px;\n  border: none;\n}\n\n.cm-s-reactpresents.CodeMirror-focused div.CodeMirror-selected {\n  background: rgba(255, 255, 255, 0.10);\n}\n\n.cm-s-reactpresents {\n  .CodeMirror-sizer {\n    min-height: auto !important;\n  }\n\n  .CodeMirror-gutters {\n    background-color: #222 !important;\n    color: #f8f8f2 !important;\n    font-size: 12px;\n    border: none;\n  }\n  .CodeMirror-gutters { color: #222; }\n  .CodeMirror-cursor { border-left: solid thin #ddd; }\n  .CodeMirror-linenumber { cololibr: #75715e; }\n  .CodeMirror-line::selection,\n  .CodeMirror-line > span::selection,\n  .CodeMirror-line > span > span::selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  .CodeMirror-line::-moz-selection,\n  .CodeMirror-line > span::-moz-selection,\n  .CodeMirror-line > span > span::-moz-selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  span.cm-comment { color: #75715e; }\n  span.cm-string,\n  span.cm-string-2 { color: #f1fa8c; }\n  span.cm-number { color: #bd93f9; }\n  span.cm-variable { color: #ddd; }\n  span.cm-variable-2 { color: white; }\n  span.cm-def { color: #a6e22e; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-operator { color: #f92672; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-atom { color: #bd93f9; }\n  span.cm-meta { color: #f8f8f2; }\n  span.cm-tag { color: #f92672; }\n  span.cm-attribute { color: #ddd; }\n  span.cm-qualifier { color: #a6e22e; }\n  span.cm-property { color: #66d9ef; }\n  span.cm-builtin { color: #a6e22e; }\n  span.cm-variable-3 { color: #a6e22e; }\n\n  .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }\n  .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\n\n  span.cm-bracket { color: #900; }\n\n  span.dim {\n    opacity: 0.5;\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n  }\n\n  span.highlight {\n    background-color: rgba(189,147,249, .2);\n  }\n}\n" ]), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _reactCodemirror = (_interopRequireDefault(_propTypes), 
        __webpack_require__(119)), _reactCodemirror2 = _interopRequireDefault(_reactCodemirror), _styledComponents = __webpack_require__(132), _styledComponents2 = _interopRequireDefault(_styledComponents);
        __webpack_require__(141);
        var DEFAULT_CODE_MIRROR_OPTIONS = {
            lineNumbers: !1,
            mode: "jsx",
            readOnly: !0,
            theme: "reactpresents"
        }, Code = function(_Component) {
            function Code() {
                return (0, _classCallCheck3.default)(this, Code), (0, _possibleConstructorReturn3.default)(this, (Code.__proto__ || (0, 
                _getPrototypeOf2.default)(Code)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Code, _Component), (0, _createClass3.default)(Code, [ {
                key: "componentDidMount",
                value: function() {
                    var _props = this.props, dimLines = _props.dimLines, highlightLines = _props.highlightLines;
                    this._textMarks = [], this._addClassNameToLines(dimLines, "dim"), this._addClassNameToLines(highlightLines, "highlight");
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    var _props2 = this.props, dimLines = _props2.dimLines, highlightLines = _props2.highlightLines;
                    dimLines === nextProps.dimLines && highlightLines === nextProps.highlightLines || (this._textMarks.forEach(function(textMark) {
                        textMark.clear();
                    }), this._textMarks = [], this._addClassNameToLines(nextProps.dimLines, "dim"), 
                    this._addClassNameToLines(nextProps.highlightLines, "highlight"));
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, _props3 = this.props, codeMirrorOptions = _props3.codeMirrorOptions, value = _props3.value, className = _props3.className, options = (0, 
                    _extends3.default)({}, DEFAULT_CODE_MIRROR_OPTIONS, codeMirrorOptions);
                    return _react2.default.createElement(CodeMirrorTheme, {
                        className: className
                    }, _react2.default.createElement(_reactCodemirror2.default, {
                        options: options,
                        ref: function(_ref) {
                            _this2._codeMirror = _ref;
                        },
                        value: value
                    }));
                }
            }, {
                key: "_addClassNameToLines",
                value: function(lineNumbers, className) {
                    var _this3 = this;
                    lineNumbers.forEach(function(_ref2) {
                        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2), start = _ref3[0], stop = _ref3[1];
                        _this3._textMarks.push(_this3._codeMirror.codeMirror.doc.markText({
                            line: start,
                            ch: 0
                        }, {
                            line: stop + 1,
                            ch: 0
                        }, {
                            className: className
                        }));
                    });
                }
            } ]), Code;
        }(_react.Component);
        Code.defaultProps = {
            codeMirrorOptions: {},
            dimLines: [],
            highlightLines: []
        }, exports.default = Code;
        var CodeMirrorTheme = _styledComponents2.default.div(_templateObject);
    }, /* 2 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _defineProperties = __webpack_require__(3), _defineProperties2 = _interopRequireDefault(_defineProperties), _freeze = __webpack_require__(38), _freeze2 = _interopRequireDefault(_freeze);
        exports.default = function(strings, raw) {
            return (0, _freeze2.default)((0, _defineProperties2.default)(strings, {
                raw: {
                    value: (0, _freeze2.default)(raw)
                }
            }));
        };
    }, /* 3 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(4),
            __esModule: !0
        };
    }, /* 4 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(5);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(T, D) {
            return $Object.defineProperties(T, D);
        };
    }, /* 5 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
        $export($export.S + $export.F * !__webpack_require__(16), "Object", {
            defineProperties: __webpack_require__(22)
        });
    }, /* 6 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), core = __webpack_require__(8), ctx = __webpack_require__(9), hide = __webpack_require__(11), has = __webpack_require__(21), PROTOTYPE = "prototype", $export = function(type, name, source) {
            var key, own, out, IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, exports = IS_GLOBAL ? core : core[name] || (core[name] = {}), expProto = exports[PROTOTYPE], target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
            IS_GLOBAL && (source = name);
            for (key in source) // contains in native
            own = !IS_FORCED && target && void 0 !== target[key], own && has(exports, key) || (// export native or passed
            out = own ? target[key] : source[key], // prevent global pollution for namespaces
            exports[key] = IS_GLOBAL && "function" != typeof target[key] ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                var F = function(a, b, c) {
                    if (this instanceof C) {
                        switch (arguments.length) {
                          case 0:
                            return new C();

                          case 1:
                            return new C(a);

                          case 2:
                            return new C(a, b);
                        }
                        return new C(a, b, c);
                    }
                    return C.apply(this, arguments);
                };
                return F[PROTOTYPE] = C[PROTOTYPE], F;
            }(out) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out, // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
            IS_PROTO && ((exports.virtual || (exports.virtual = {}))[key] = out, // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
            type & $export.R && expProto && !expProto[key] && hide(expProto, key, out)));
        };
        // type bitmap
        $export.F = 1, // forced
        $export.G = 2, // global
        $export.S = 4, // static
        $export.P = 8, // proto
        $export.B = 16, // bind
        $export.W = 32, // wrap
        $export.U = 64, // safe
        $export.R = 128, // real proto method for `library`
        module.exports = $export;
    }, /* 7 */
    /***/
    function(module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = global);
    }, /* 8 */
    /***/
    function(module, exports) {
        var core = module.exports = {
            version: "2.6.11"
        };
        "number" == typeof __e && (__e = core);
    }, /* 9 */
    /***/
    function(module, exports, __webpack_require__) {
        // optional / simple context binding
        var aFunction = __webpack_require__(10);
        module.exports = function(fn, that, length) {
            if (aFunction(fn), void 0 === that) return fn;
            switch (length) {
              case 1:
                return function(a) {
                    return fn.call(that, a);
                };

              case 2:
                return function(a, b) {
                    return fn.call(that, a, b);
                };

              case 3:
                return function(a, b, c) {
                    return fn.call(that, a, b, c);
                };
            }
            return function() {
                return fn.apply(that, arguments);
            };
        };
    }, /* 10 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            if ("function" != typeof it) throw TypeError(it + " is not a function!");
            return it;
        };
    }, /* 11 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(12), createDesc = __webpack_require__(20);
        module.exports = __webpack_require__(16) ? function(object, key, value) {
            return dP.f(object, key, createDesc(1, value));
        } : function(object, key, value) {
            return object[key] = value, object;
        };
    }, /* 12 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), IE8_DOM_DEFINE = __webpack_require__(15), toPrimitive = __webpack_require__(19), dP = Object.defineProperty;
        exports.f = __webpack_require__(16) ? Object.defineProperty : function(O, P, Attributes) {
            if (anObject(O), P = toPrimitive(P, !0), anObject(Attributes), IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
            } catch (e) {}
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
            return "value" in Attributes && (O[P] = Attributes.value), O;
        };
    }, /* 13 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14);
        module.exports = function(it) {
            if (!isObject(it)) throw TypeError(it + " is not an object!");
            return it;
        };
    }, /* 14 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            return "object" == typeof it ? null !== it : "function" == typeof it;
        };
    }, /* 15 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function() {
            return 7 != Object.defineProperty(__webpack_require__(18)("div"), "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 16 */
    /***/
    function(module, exports, __webpack_require__) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !__webpack_require__(17)(function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 17 */
    /***/
    function(module, exports) {
        module.exports = function(exec) {
            try {
                return !!exec();
            } catch (e) {
                return !0;
            }
        };
    }, /* 18 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14), document = __webpack_require__(7).document, is = isObject(document) && isObject(document.createElement);
        module.exports = function(it) {
            return is ? document.createElement(it) : {};
        };
    }, /* 19 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = __webpack_require__(14);
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function(it, S) {
            if (!isObject(it)) return it;
            var fn, val;
            if (S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            if ("function" == typeof (fn = it.valueOf) && !isObject(val = fn.call(it))) return val;
            if (!S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            throw TypeError("Can't convert object to primitive value");
        };
    }, /* 20 */
    /***/
    function(module, exports) {
        module.exports = function(bitmap, value) {
            return {
                enumerable: !(1 & bitmap),
                configurable: !(2 & bitmap),
                writable: !(4 & bitmap),
                value: value
            };
        };
    }, /* 21 */
    /***/
    function(module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
        };
    }, /* 22 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(12), anObject = __webpack_require__(13), getKeys = __webpack_require__(23);
        module.exports = __webpack_require__(16) ? Object.defineProperties : function(O, Properties) {
            anObject(O);
            for (var P, keys = getKeys(Properties), length = keys.length, i = 0; length > i; ) dP.f(O, P = keys[i++], Properties[P]);
            return O;
        };
    }, /* 23 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = __webpack_require__(24), enumBugKeys = __webpack_require__(37);
        module.exports = Object.keys || function(O) {
            return $keys(O, enumBugKeys);
        };
    }, /* 24 */
    /***/
    function(module, exports, __webpack_require__) {
        var has = __webpack_require__(21), toIObject = __webpack_require__(25), arrayIndexOf = __webpack_require__(29)(!1), IE_PROTO = __webpack_require__(33)("IE_PROTO");
        module.exports = function(object, names) {
            var key, O = toIObject(object), i = 0, result = [];
            for (key in O) key != IE_PROTO && has(O, key) && result.push(key);
            // Don't enum bug & hidden keys
            for (;names.length > i; ) has(O, key = names[i++]) && (~arrayIndexOf(result, key) || result.push(key));
            return result;
        };
    }, /* 25 */
    /***/
    function(module, exports, __webpack_require__) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = __webpack_require__(26), defined = __webpack_require__(28);
        module.exports = function(it) {
            return IObject(defined(it));
        };
    }, /* 26 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = __webpack_require__(27);
        // eslint-disable-next-line no-prototype-builtins
        module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return "String" == cof(it) ? it.split("") : Object(it);
        };
    }, /* 27 */
    /***/
    function(module, exports) {
        var toString = {}.toString;
        module.exports = function(it) {
            return toString.call(it).slice(8, -1);
        };
    }, /* 28 */
    /***/
    function(module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function(it) {
            if (void 0 == it) throw TypeError("Can't call method on  " + it);
            return it;
        };
    }, /* 29 */
    /***/
    function(module, exports, __webpack_require__) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = __webpack_require__(25), toLength = __webpack_require__(30), toAbsoluteIndex = __webpack_require__(32);
        module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
                var value, O = toIObject($this), length = toLength(O.length), index = toAbsoluteIndex(fromIndex, length);
                // Array#includes uses SameValueZero equality algorithm
                // eslint-disable-next-line no-self-compare
                if (IS_INCLUDES && el != el) {
                    for (;length > index; ) // eslint-disable-next-line no-self-compare
                    if (value = O[index++], value != value) return !0;
                } else for (;length > index; index++) if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                return !IS_INCLUDES && -1;
            };
        };
    }, /* 30 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.15 ToLength
        var toInteger = __webpack_require__(31), min = Math.min;
        module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
        };
    }, /* 31 */
    /***/
    function(module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil, floor = Math.floor;
        module.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
    }, /* 32 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(31), max = Math.max, min = Math.min;
        module.exports = function(index, length) {
            return index = toInteger(index), index < 0 ? max(index + length, 0) : min(index, length);
        };
    }, /* 33 */
    /***/
    function(module, exports, __webpack_require__) {
        var shared = __webpack_require__(34)("keys"), uid = __webpack_require__(36);
        module.exports = function(key) {
            return shared[key] || (shared[key] = uid(key));
        };
    }, /* 34 */
    /***/
    function(module, exports, __webpack_require__) {
        var core = __webpack_require__(8), global = __webpack_require__(7), SHARED = "__core-js_shared__", store = global[SHARED] || (global[SHARED] = {});
        (module.exports = function(key, value) {
            return store[key] || (store[key] = void 0 !== value ? value : {});
        })("versions", []).push({
            version: core.version,
            mode: __webpack_require__(35) ? "pure" : "global",
            copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
        });
    }, /* 35 */
    /***/
    function(module, exports) {
        module.exports = !0;
    }, /* 36 */
    /***/
    function(module, exports) {
        var id = 0, px = Math.random();
        module.exports = function(key) {
            return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36));
        };
    }, /* 37 */
    /***/
    function(module, exports) {
        // IE 8- don't enum bug keys
        module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, /* 38 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(39),
            __esModule: !0
        };
    }, /* 39 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(40), module.exports = __webpack_require__(8).Object.freeze;
    }, /* 40 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.5 Object.freeze(O)
        var isObject = __webpack_require__(14), meta = __webpack_require__(41).onFreeze;
        __webpack_require__(42)("freeze", function($freeze) {
            return function(it) {
                return $freeze && isObject(it) ? $freeze(meta(it)) : it;
            };
        });
    }, /* 41 */
    /***/
    function(module, exports, __webpack_require__) {
        var META = __webpack_require__(36)("meta"), isObject = __webpack_require__(14), has = __webpack_require__(21), setDesc = __webpack_require__(12).f, id = 0, isExtensible = Object.isExtensible || function() {
            return !0;
        }, FREEZE = !__webpack_require__(17)(function() {
            return isExtensible(Object.preventExtensions({}));
        }), setMeta = function(it) {
            setDesc(it, META, {
                value: {
                    i: "O" + ++id,
                    // object ID
                    w: {}
                }
            });
        }, fastKey = function(it, create) {
            // return primitive with prefix
            if (!isObject(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return "F";
                // not necessary to add metadata
                if (!create) return "E";
                // add missing metadata
                setMeta(it);
            }
            return it[META].i;
        }, getWeak = function(it, create) {
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return !0;
                // not necessary to add metadata
                if (!create) return !1;
                // add missing metadata
                setMeta(it);
            }
            return it[META].w;
        }, onFreeze = function(it) {
            return FREEZE && meta.NEED && isExtensible(it) && !has(it, META) && setMeta(it), 
            it;
        }, meta = module.exports = {
            KEY: META,
            NEED: !1,
            fastKey: fastKey,
            getWeak: getWeak,
            onFreeze: onFreeze
        };
    }, /* 42 */
    /***/
    function(module, exports, __webpack_require__) {
        // most Object methods by ES6 should accept primitives
        var $export = __webpack_require__(6), core = __webpack_require__(8), fails = __webpack_require__(17);
        module.exports = function(KEY, exec) {
            var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
            exp[KEY] = exec(fn), $export($export.S + $export.F * fails(function() {
                fn(1);
            }), "Object", exp);
        };
    }, /* 43 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _isIterable2 = __webpack_require__(44), _isIterable3 = _interopRequireDefault(_isIterable2), _getIterator2 = __webpack_require__(64), _getIterator3 = _interopRequireDefault(_getIterator2);
        exports.default = function() {
            function sliceIterator(arr, i) {
                var _arr = [], _n = !0, _d = !1, _e = void 0;
                try {
                    for (var _s, _i = (0, _getIterator3.default)(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
                    !i || _arr.length !== i); _n = !0) ;
                } catch (err) {
                    _d = !0, _e = err;
                } finally {
                    try {
                        !_n && _i.return && _i.return();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) return arr;
                if ((0, _isIterable3.default)(Object(arr))) return sliceIterator(arr, i);
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            };
        }();
    }, /* 44 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(45),
            __esModule: !0
        };
    }, /* 45 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(46), __webpack_require__(60), module.exports = __webpack_require__(62);
    }, /* 46 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(47);
        for (var global = __webpack_require__(7), hide = __webpack_require__(11), Iterators = __webpack_require__(50), TO_STRING_TAG = __webpack_require__(57)("toStringTag"), DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), i = 0; i < DOMIterables.length; i++) {
            var NAME = DOMIterables[i], Collection = global[NAME], proto = Collection && Collection.prototype;
            proto && !proto[TO_STRING_TAG] && hide(proto, TO_STRING_TAG, NAME), Iterators[NAME] = Iterators.Array;
        }
    }, /* 47 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var addToUnscopables = __webpack_require__(48), step = __webpack_require__(49), Iterators = __webpack_require__(50), toIObject = __webpack_require__(25);
        // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()
        module.exports = __webpack_require__(51)(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated), // target
            this._i = 0, // next index
            this._k = kind;
        }, function() {
            var O = this._t, kind = this._k, index = this._i++;
            return !O || index >= O.length ? (this._t = void 0, step(1)) : "keys" == kind ? step(0, index) : "values" == kind ? step(0, O[index]) : step(0, [ index, O[index] ]);
        }, "values"), // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
        Iterators.Arguments = Iterators.Array, addToUnscopables("keys"), addToUnscopables("values"), 
        addToUnscopables("entries");
    }, /* 48 */
    /***/
    function(module, exports) {
        module.exports = function() {};
    }, /* 49 */
    /***/
    function(module, exports) {
        module.exports = function(done, value) {
            return {
                value: value,
                done: !!done
            };
        };
    }, /* 50 */
    /***/
    function(module, exports) {
        module.exports = {};
    }, /* 51 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var LIBRARY = __webpack_require__(35), $export = __webpack_require__(6), redefine = __webpack_require__(52), hide = __webpack_require__(11), Iterators = __webpack_require__(50), $iterCreate = __webpack_require__(53), setToStringTag = __webpack_require__(56), getPrototypeOf = __webpack_require__(58), ITERATOR = __webpack_require__(57)("iterator"), BUGGY = !([].keys && "next" in [].keys()), FF_ITERATOR = "@@iterator", KEYS = "keys", VALUES = "values", returnThis = function() {
            return this;
        };
        module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var methods, key, IteratorPrototype, getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function() {
                        return new Constructor(this, kind);
                    };

                  case VALUES:
                    return function() {
                        return new Constructor(this, kind);
                    };
                }
                return function() {
                    return new Constructor(this, kind);
                };
            }, TAG = NAME + " Iterator", DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = !1, proto = Base.prototype, $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), $entries = DEFAULT ? DEF_VALUES ? getMethod("entries") : $default : void 0, $anyNative = "Array" == NAME ? proto.entries || $native : $native;
            if (// Fix native
            $anyNative && (IteratorPrototype = getPrototypeOf($anyNative.call(new Base())), 
            IteratorPrototype !== Object.prototype && IteratorPrototype.next && (// Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, !0), // fix for some old engines
            LIBRARY || "function" == typeof IteratorPrototype[ITERATOR] || hide(IteratorPrototype, ITERATOR, returnThis))), 
            // fix Array#{values, @@iterator}.name in V8 / FF
            DEF_VALUES && $native && $native.name !== VALUES && (VALUES_BUG = !0, $default = function() {
                return $native.call(this);
            }), // Define iterator
            LIBRARY && !FORCED || !BUGGY && !VALUES_BUG && proto[ITERATOR] || hide(proto, ITERATOR, $default), 
            // Plug for library
            Iterators[NAME] = $default, Iterators[TAG] = returnThis, DEFAULT) if (methods = {
                values: DEF_VALUES ? $default : getMethod(VALUES),
                keys: IS_SET ? $default : getMethod(KEYS),
                entries: $entries
            }, FORCED) for (key in methods) key in proto || redefine(proto, key, methods[key]); else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
            return methods;
        };
    }, /* 52 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(11);
    }, /* 53 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var create = __webpack_require__(54), descriptor = __webpack_require__(20), setToStringTag = __webpack_require__(56), IteratorPrototype = {};
        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        __webpack_require__(11)(IteratorPrototype, __webpack_require__(57)("iterator"), function() {
            return this;
        }), module.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create(IteratorPrototype, {
                next: descriptor(1, next)
            }), setToStringTag(Constructor, NAME + " Iterator");
        };
    }, /* 54 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = __webpack_require__(13), dPs = __webpack_require__(22), enumBugKeys = __webpack_require__(37), IE_PROTO = __webpack_require__(33)("IE_PROTO"), Empty = function() {}, PROTOTYPE = "prototype", createDict = function() {
            // Thrash, waste and sodomy: IE GC bug
            var iframeDocument, iframe = __webpack_require__(18)("iframe"), i = enumBugKeys.length, lt = "<", gt = ">";
            for (iframe.style.display = "none", __webpack_require__(55).appendChild(iframe), 
            iframe.src = "javascript:", // eslint-disable-line no-script-url
            // createDict = iframe.contentWindow.Object;
            // html.removeChild(iframe);
            iframeDocument = iframe.contentWindow.document, iframeDocument.open(), iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt), 
            iframeDocument.close(), createDict = iframeDocument.F; i--; ) delete createDict[PROTOTYPE][enumBugKeys[i]];
            return createDict();
        };
        module.exports = Object.create || function(O, Properties) {
            var result;
            // add "__proto__" for Object.getPrototypeOf polyfill
            return null !== O ? (Empty[PROTOTYPE] = anObject(O), result = new Empty(), Empty[PROTOTYPE] = null, 
            result[IE_PROTO] = O) : result = createDict(), void 0 === Properties ? result : dPs(result, Properties);
        };
    }, /* 55 */
    /***/
    function(module, exports, __webpack_require__) {
        var document = __webpack_require__(7).document;
        module.exports = document && document.documentElement;
    }, /* 56 */
    /***/
    function(module, exports, __webpack_require__) {
        var def = __webpack_require__(12).f, has = __webpack_require__(21), TAG = __webpack_require__(57)("toStringTag");
        module.exports = function(it, tag, stat) {
            it && !has(it = stat ? it : it.prototype, TAG) && def(it, TAG, {
                configurable: !0,
                value: tag
            });
        };
    }, /* 57 */
    /***/
    function(module, exports, __webpack_require__) {
        var store = __webpack_require__(34)("wks"), uid = __webpack_require__(36), Symbol = __webpack_require__(7).Symbol, USE_SYMBOL = "function" == typeof Symbol, $exports = module.exports = function(name) {
            return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name));
        };
        $exports.store = store;
    }, /* 58 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = __webpack_require__(21), toObject = __webpack_require__(59), IE_PROTO = __webpack_require__(33)("IE_PROTO"), ObjectProto = Object.prototype;
        module.exports = Object.getPrototypeOf || function(O) {
            return O = toObject(O), has(O, IE_PROTO) ? O[IE_PROTO] : "function" == typeof O.constructor && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? ObjectProto : null;
        };
    }, /* 59 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.13 ToObject(argument)
        var defined = __webpack_require__(28);
        module.exports = function(it) {
            return Object(defined(it));
        };
    }, /* 60 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var $at = __webpack_require__(61)(!0);
        // 21.1.3.27 String.prototype[@@iterator]()
        __webpack_require__(51)(String, "String", function(iterated) {
            this._t = String(iterated), // target
            this._i = 0;
        }, function() {
            var point, O = this._t, index = this._i;
            return index >= O.length ? {
                value: void 0,
                done: !0
            } : (point = $at(O, index), this._i += point.length, {
                value: point,
                done: !1
            });
        });
    }, /* 61 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(31), defined = __webpack_require__(28);
        // true  -> String#at
        // false -> String#codePointAt
        module.exports = function(TO_STRING) {
            return function(that, pos) {
                var a, b, s = String(defined(that)), i = toInteger(pos), l = s.length;
                return i < 0 || i >= l ? TO_STRING ? "" : void 0 : (a = s.charCodeAt(i), a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536);
            };
        };
    }, /* 62 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(63), ITERATOR = __webpack_require__(57)("iterator"), Iterators = __webpack_require__(50);
        module.exports = __webpack_require__(8).isIterable = function(it) {
            var O = Object(it);
            return void 0 !== O[ITERATOR] || "@@iterator" in O || Iterators.hasOwnProperty(classof(O));
        };
    }, /* 63 */
    /***/
    function(module, exports, __webpack_require__) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = __webpack_require__(27), TAG = __webpack_require__(57)("toStringTag"), ARG = "Arguments" == cof(function() {
            return arguments;
        }()), tryGet = function(it, key) {
            try {
                return it[key];
            } catch (e) {}
        };
        module.exports = function(it) {
            var O, T, B;
            return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof (T = tryGet(O = Object(it), TAG)) ? T : ARG ? cof(O) : "Object" == (B = cof(O)) && "function" == typeof O.callee ? "Arguments" : B;
        };
    }, /* 64 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(65),
            __esModule: !0
        };
    }, /* 65 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(46), __webpack_require__(60), module.exports = __webpack_require__(66);
    }, /* 66 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), get = __webpack_require__(67);
        module.exports = __webpack_require__(8).getIterator = function(it) {
            var iterFn = get(it);
            if ("function" != typeof iterFn) throw TypeError(it + " is not iterable!");
            return anObject(iterFn.call(it));
        };
    }, /* 67 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(63), ITERATOR = __webpack_require__(57)("iterator"), Iterators = __webpack_require__(50);
        module.exports = __webpack_require__(8).getIteratorMethod = function(it) {
            if (void 0 != it) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
        };
    }, /* 68 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _assign = __webpack_require__(69), _assign2 = _interopRequireDefault(_assign);
        exports.default = _assign2.default || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        };
    }, /* 69 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(70),
            __esModule: !0
        };
    }, /* 70 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(71), module.exports = __webpack_require__(8).Object.assign;
    }, /* 71 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = __webpack_require__(6);
        $export($export.S + $export.F, "Object", {
            assign: __webpack_require__(72)
        });
    }, /* 72 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // 19.1.2.1 Object.assign(target, source, ...)
        var DESCRIPTORS = __webpack_require__(16), getKeys = __webpack_require__(23), gOPS = __webpack_require__(73), pIE = __webpack_require__(74), toObject = __webpack_require__(59), IObject = __webpack_require__(26), $assign = Object.assign;
        // should work with symbols and should have deterministic property order (V8 bug)
        module.exports = !$assign || __webpack_require__(17)(function() {
            var A = {}, B = {}, S = Symbol(), K = "abcdefghijklmnopqrst";
            return A[S] = 7, K.split("").forEach(function(k) {
                B[k] = k;
            }), 7 != $assign({}, A)[S] || Object.keys($assign({}, B)).join("") != K;
        }) ? function(target, source) {
            for (// eslint-disable-line no-unused-vars
            var T = toObject(target), aLen = arguments.length, index = 1, getSymbols = gOPS.f, isEnum = pIE.f; aLen > index; ) for (var key, S = IObject(arguments[index++]), keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S), length = keys.length, j = 0; length > j; ) key = keys[j++], 
            DESCRIPTORS && !isEnum.call(S, key) || (T[key] = S[key]);
            return T;
        } : $assign;
    }, /* 73 */
    /***/
    function(module, exports) {
        exports.f = Object.getOwnPropertySymbols;
    }, /* 74 */
    /***/
    function(module, exports) {
        exports.f = {}.propertyIsEnumerable;
    }, /* 75 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(76),
            __esModule: !0
        };
    }, /* 76 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(77), module.exports = __webpack_require__(8).Object.getPrototypeOf;
    }, /* 77 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 Object.getPrototypeOf(O)
        var toObject = __webpack_require__(59), $getPrototypeOf = __webpack_require__(58);
        __webpack_require__(42)("getPrototypeOf", function() {
            return function(it) {
                return $getPrototypeOf(toObject(it));
            };
        });
    }, /* 78 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0, exports.default = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        };
    }, /* 79 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _defineProperty = __webpack_require__(80), _defineProperty2 = _interopRequireDefault(_defineProperty);
        exports.default = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), (0, _defineProperty2.default)(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
    }, /* 80 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(81),
            __esModule: !0
        };
    }, /* 81 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(82);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(it, key, desc) {
            return $Object.defineProperty(it, key, desc);
        };
    }, /* 82 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
        $export($export.S + $export.F * !__webpack_require__(16), "Object", {
            defineProperty: __webpack_require__(12).f
        });
    }, /* 83 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _typeof2 = __webpack_require__(84), _typeof3 = _interopRequireDefault(_typeof2);
        exports.default = function(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" !== ("undefined" == typeof call ? "undefined" : (0, _typeof3.default)(call)) && "function" != typeof call ? self : call;
        };
    }, /* 84 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _iterator = __webpack_require__(85), _iterator2 = _interopRequireDefault(_iterator), _symbol = __webpack_require__(88), _symbol2 = _interopRequireDefault(_symbol), _typeof = "function" == typeof _symbol2.default && "symbol" == typeof _iterator2.default ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
        };
        exports.default = "function" == typeof _symbol2.default && "symbol" === _typeof(_iterator2.default) ? function(obj) {
            return "undefined" == typeof obj ? "undefined" : _typeof(obj);
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : "undefined" == typeof obj ? "undefined" : _typeof(obj);
        };
    }, /* 85 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(86),
            __esModule: !0
        };
    }, /* 86 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(60), __webpack_require__(46), module.exports = __webpack_require__(87).f("iterator");
    }, /* 87 */
    /***/
    function(module, exports, __webpack_require__) {
        exports.f = __webpack_require__(57);
    }, /* 88 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(89),
            __esModule: !0
        };
    }, /* 89 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(90), __webpack_require__(97), __webpack_require__(98), __webpack_require__(99), 
        module.exports = __webpack_require__(8).Symbol;
    }, /* 90 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // ECMAScript 6 symbols shim
        var global = __webpack_require__(7), has = __webpack_require__(21), DESCRIPTORS = __webpack_require__(16), $export = __webpack_require__(6), redefine = __webpack_require__(52), META = __webpack_require__(41).KEY, $fails = __webpack_require__(17), shared = __webpack_require__(34), setToStringTag = __webpack_require__(56), uid = __webpack_require__(36), wks = __webpack_require__(57), wksExt = __webpack_require__(87), wksDefine = __webpack_require__(91), enumKeys = __webpack_require__(92), isArray = __webpack_require__(93), anObject = __webpack_require__(13), isObject = __webpack_require__(14), toObject = __webpack_require__(59), toIObject = __webpack_require__(25), toPrimitive = __webpack_require__(19), createDesc = __webpack_require__(20), _create = __webpack_require__(54), gOPNExt = __webpack_require__(94), $GOPD = __webpack_require__(96), $GOPS = __webpack_require__(73), $DP = __webpack_require__(12), $keys = __webpack_require__(23), gOPD = $GOPD.f, dP = $DP.f, gOPN = gOPNExt.f, $Symbol = global.Symbol, $JSON = global.JSON, _stringify = $JSON && $JSON.stringify, PROTOTYPE = "prototype", HIDDEN = wks("_hidden"), TO_PRIMITIVE = wks("toPrimitive"), isEnum = {}.propertyIsEnumerable, SymbolRegistry = shared("symbol-registry"), AllSymbols = shared("symbols"), OPSymbols = shared("op-symbols"), ObjectProto = Object[PROTOTYPE], USE_NATIVE = "function" == typeof $Symbol && !!$GOPS.f, QObject = global.QObject, setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild, setSymbolDesc = DESCRIPTORS && $fails(function() {
            return 7 != _create(dP({}, "a", {
                get: function() {
                    return dP(this, "a", {
                        value: 7
                    }).a;
                }
            })).a;
        }) ? function(it, key, D) {
            var protoDesc = gOPD(ObjectProto, key);
            protoDesc && delete ObjectProto[key], dP(it, key, D), protoDesc && it !== ObjectProto && dP(ObjectProto, key, protoDesc);
        } : dP, wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
            return sym._k = tag, sym;
        }, isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
            return "symbol" == typeof it;
        } : function(it) {
            return it instanceof $Symbol;
        }, $defineProperty = function(it, key, D) {
            return it === ObjectProto && $defineProperty(OPSymbols, key, D), anObject(it), key = toPrimitive(key, !0), 
            anObject(D), has(AllSymbols, key) ? (D.enumerable ? (has(it, HIDDEN) && it[HIDDEN][key] && (it[HIDDEN][key] = !1), 
            D = _create(D, {
                enumerable: createDesc(0, !1)
            })) : (has(it, HIDDEN) || dP(it, HIDDEN, createDesc(1, {})), it[HIDDEN][key] = !0), 
            setSymbolDesc(it, key, D)) : dP(it, key, D);
        }, $defineProperties = function(it, P) {
            anObject(it);
            for (var key, keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length; l > i; ) $defineProperty(it, key = keys[i++], P[key]);
            return it;
        }, $create = function(it, P) {
            return void 0 === P ? _create(it) : $defineProperties(_create(it), P);
        }, $propertyIsEnumerable = function(key) {
            var E = isEnum.call(this, key = toPrimitive(key, !0));
            return !(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) && (!(E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]) || E);
        }, $getOwnPropertyDescriptor = function(it, key) {
            if (it = toIObject(it), key = toPrimitive(key, !0), it !== ObjectProto || !has(AllSymbols, key) || has(OPSymbols, key)) {
                var D = gOPD(it, key);
                return !D || !has(AllSymbols, key) || has(it, HIDDEN) && it[HIDDEN][key] || (D.enumerable = !0), 
                D;
            }
        }, $getOwnPropertyNames = function(it) {
            for (var key, names = gOPN(toIObject(it)), result = [], i = 0; names.length > i; ) has(AllSymbols, key = names[i++]) || key == HIDDEN || key == META || result.push(key);
            return result;
        }, $getOwnPropertySymbols = function(it) {
            for (var key, IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0; names.length > i; ) !has(AllSymbols, key = names[i++]) || IS_OP && !has(ObjectProto, key) || result.push(AllSymbols[key]);
            return result;
        };
        // 19.4.1.1 Symbol([description])
        USE_NATIVE || ($Symbol = function() {
            if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
            var tag = uid(arguments.length > 0 ? arguments[0] : void 0), $set = function(value) {
                this === ObjectProto && $set.call(OPSymbols, value), has(this, HIDDEN) && has(this[HIDDEN], tag) && (this[HIDDEN][tag] = !1), 
                setSymbolDesc(this, tag, createDesc(1, value));
            };
            return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
                configurable: !0,
                set: $set
            }), wrap(tag);
        }, redefine($Symbol[PROTOTYPE], "toString", function() {
            return this._k;
        }), $GOPD.f = $getOwnPropertyDescriptor, $DP.f = $defineProperty, __webpack_require__(95).f = gOPNExt.f = $getOwnPropertyNames, 
        __webpack_require__(74).f = $propertyIsEnumerable, $GOPS.f = $getOwnPropertySymbols, 
        DESCRIPTORS && !__webpack_require__(35) && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0), 
        wksExt.f = function(name) {
            return wrap(wks(name));
        }), $export($export.G + $export.W + $export.F * !USE_NATIVE, {
            Symbol: $Symbol
        });
        for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; ) wks(es6Symbols[j++]);
        for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; ) wksDefine(wellKnownSymbols[k++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
            // 19.4.2.1 Symbol.for(key)
            for: function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
            },
            // 19.4.2.5 Symbol.keyFor(sym)
            keyFor: function(sym) {
                if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
                for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
            },
            useSetter: function() {
                setter = !0;
            },
            useSimple: function() {
                setter = !1;
            }
        }), $export($export.S + $export.F * !USE_NATIVE, "Object", {
            // 19.1.2.2 Object.create(O [, Properties])
            create: $create,
            // 19.1.2.4 Object.defineProperty(O, P, Attributes)
            defineProperty: $defineProperty,
            // 19.1.2.3 Object.defineProperties(O, Properties)
            defineProperties: $defineProperties,
            // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            // 19.1.2.7 Object.getOwnPropertyNames(O)
            getOwnPropertyNames: $getOwnPropertyNames,
            // 19.1.2.8 Object.getOwnPropertySymbols(O)
            getOwnPropertySymbols: $getOwnPropertySymbols
        });
        // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
        // https://bugs.chromium.org/p/v8/issues/detail?id=3443
        var FAILS_ON_PRIMITIVES = $fails(function() {
            $GOPS.f(1);
        });
        $export($export.S + $export.F * FAILS_ON_PRIMITIVES, "Object", {
            getOwnPropertySymbols: function(it) {
                return $GOPS.f(toObject(it));
            }
        }), // 24.3.2 JSON.stringify(value [, replacer [, space]])
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
            var S = $Symbol();
            // MS Edge converts symbol values to JSON as {}
            // WebKit converts symbol values to JSON as null
            // V8 throws on boxed symbols
            return "[null]" != _stringify([ S ]) || "{}" != _stringify({
                a: S
            }) || "{}" != _stringify(Object(S));
        })), "JSON", {
            stringify: function(it) {
                for (var replacer, $replacer, args = [ it ], i = 1; arguments.length > i; ) args.push(arguments[i++]);
                if ($replacer = replacer = args[1], (isObject(replacer) || void 0 !== it) && !isSymbol(it)) // IE8 returns string on undefined
                return isArray(replacer) || (replacer = function(key, value) {
                    if ("function" == typeof $replacer && (value = $replacer.call(this, key, value)), 
                    !isSymbol(value)) return value;
                }), args[1] = replacer, _stringify.apply($JSON, args);
            }
        }), // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf), 
        // 19.4.3.5 Symbol.prototype[@@toStringTag]
        setToStringTag($Symbol, "Symbol"), // 20.2.1.9 Math[@@toStringTag]
        setToStringTag(Math, "Math", !0), // 24.3.3 JSON[@@toStringTag]
        setToStringTag(global.JSON, "JSON", !0);
    }, /* 91 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), core = __webpack_require__(8), LIBRARY = __webpack_require__(35), wksExt = __webpack_require__(87), defineProperty = __webpack_require__(12).f;
        module.exports = function(name) {
            var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
            "_" == name.charAt(0) || name in $Symbol || defineProperty($Symbol, name, {
                value: wksExt.f(name)
            });
        };
    }, /* 92 */
    /***/
    function(module, exports, __webpack_require__) {
        // all enumerable object keys, includes symbols
        var getKeys = __webpack_require__(23), gOPS = __webpack_require__(73), pIE = __webpack_require__(74);
        module.exports = function(it) {
            var result = getKeys(it), getSymbols = gOPS.f;
            if (getSymbols) for (var key, symbols = getSymbols(it), isEnum = pIE.f, i = 0; symbols.length > i; ) isEnum.call(it, key = symbols[i++]) && result.push(key);
            return result;
        };
    }, /* 93 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.2.2 IsArray(argument)
        var cof = __webpack_require__(27);
        module.exports = Array.isArray || function(arg) {
            return "Array" == cof(arg);
        };
    }, /* 94 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        var toIObject = __webpack_require__(25), gOPN = __webpack_require__(95).f, toString = {}.toString, windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], getWindowNames = function(it) {
            try {
                return gOPN(it);
            } catch (e) {
                return windowNames.slice();
            }
        };
        module.exports.f = function(it) {
            return windowNames && "[object Window]" == toString.call(it) ? getWindowNames(it) : gOPN(toIObject(it));
        };
    }, /* 95 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
        var $keys = __webpack_require__(24), hiddenKeys = __webpack_require__(37).concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function(O) {
            return $keys(O, hiddenKeys);
        };
    }, /* 96 */
    /***/
    function(module, exports, __webpack_require__) {
        var pIE = __webpack_require__(74), createDesc = __webpack_require__(20), toIObject = __webpack_require__(25), toPrimitive = __webpack_require__(19), has = __webpack_require__(21), IE8_DOM_DEFINE = __webpack_require__(15), gOPD = Object.getOwnPropertyDescriptor;
        exports.f = __webpack_require__(16) ? gOPD : function(O, P) {
            if (O = toIObject(O), P = toPrimitive(P, !0), IE8_DOM_DEFINE) try {
                return gOPD(O, P);
            } catch (e) {}
            if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
        };
    }, /* 97 */
    /***/
    function(module, exports) {}, /* 98 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(91)("asyncIterator");
    }, /* 99 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(91)("observable");
    }, /* 100 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _setPrototypeOf = __webpack_require__(101), _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf), _create = __webpack_require__(105), _create2 = _interopRequireDefault(_create), _typeof2 = __webpack_require__(84), _typeof3 = _interopRequireDefault(_typeof2);
        exports.default = function(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof superClass ? "undefined" : (0, 
            _typeof3.default)(superClass)));
            subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (_setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass);
        };
    }, /* 101 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(102),
            __esModule: !0
        };
    }, /* 102 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(103), module.exports = __webpack_require__(8).Object.setPrototypeOf;
    }, /* 103 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.19 Object.setPrototypeOf(O, proto)
        var $export = __webpack_require__(6);
        $export($export.S, "Object", {
            setPrototypeOf: __webpack_require__(104).set
        });
    }, /* 104 */
    /***/
    function(module, exports, __webpack_require__) {
        // Works with __proto__ only. Old v8 can't work with null proto objects.
        /* eslint-disable no-proto */
        var isObject = __webpack_require__(14), anObject = __webpack_require__(13), check = function(O, proto) {
            if (anObject(O), !isObject(proto) && null !== proto) throw TypeError(proto + ": can't set as prototype!");
        };
        module.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? // eslint-disable-line
            function(test, buggy, set) {
                try {
                    set = __webpack_require__(9)(Function.call, __webpack_require__(96).f(Object.prototype, "__proto__").set, 2), 
                    set(test, []), buggy = !(test instanceof Array);
                } catch (e) {
                    buggy = !0;
                }
                return function(O, proto) {
                    return check(O, proto), buggy ? O.__proto__ = proto : set(O, proto), O;
                };
            }({}, !1) : void 0),
            check: check
        };
    }, /* 105 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(106),
            __esModule: !0
        };
    }, /* 106 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(107);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(P, D) {
            return $Object.create(P, D);
        };
    }, /* 107 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        $export($export.S, "Object", {
            create: __webpack_require__(54)
        });
    }, /* 108 */
    /***/
    function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_108__;
    }, /* 109 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            if ("production" !== process.env.NODE_ENV) {
                var ReactIs = __webpack_require__(111), throwOnDirectAccess = !0;
                module.exports = __webpack_require__(114)(ReactIs.isElement, throwOnDirectAccess);
            } else // By explicitly using `prop-types` you are opting into new production behavior.
            // http://fb.me/prop-types-in-prod
            module.exports = __webpack_require__(118)();
        }).call(exports, __webpack_require__(110));
    }, /* 110 */
    /***/
    function(module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
            return setTimeout(fun, 0);
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
            return clearTimeout(marker);
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
            clearTimeout(marker);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, runClearTimeout(timeout);
            }
        }
        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        // shim for using process in browser
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", // empty string to avoid regexp issues
        process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, 
        process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
        process.listeners = function(name) {
            return [];
        }, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, /* 111 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            "production" === process.env.NODE_ENV ? module.exports = __webpack_require__(112) : module.exports = __webpack_require__(113);
        }).call(exports, __webpack_require__(110));
    }, /* 112 */
    /***/
    function(module, exports) {
        /** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
        "use strict";
        function z(a) {
            if ("object" == typeof a && null !== a) {
                var u = a.$$typeof;
                switch (u) {
                  case c:
                    switch (a = a.type) {
                      case l:
                      case m:
                      case e:
                      case g:
                      case f:
                      case p:
                        return a;

                      default:
                        switch (a = a && a.$$typeof) {
                          case k:
                          case n:
                          case t:
                          case r:
                          case h:
                            return a;

                          default:
                            return u;
                        }
                    }

                  case d:
                    return u;
                }
            }
        }
        function A(a) {
            return z(a) === m;
        }
        var b = "function" == typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
        exports.AsyncMode = l, exports.ConcurrentMode = m, exports.ContextConsumer = k, 
        exports.ContextProvider = h, exports.Element = c, exports.ForwardRef = n, exports.Fragment = e, 
        exports.Lazy = t, exports.Memo = r, exports.Portal = d, exports.Profiler = g, exports.StrictMode = f, 
        exports.Suspense = p, exports.isAsyncMode = function(a) {
            return A(a) || z(a) === l;
        }, exports.isConcurrentMode = A, exports.isContextConsumer = function(a) {
            return z(a) === k;
        }, exports.isContextProvider = function(a) {
            return z(a) === h;
        }, exports.isElement = function(a) {
            return "object" == typeof a && null !== a && a.$$typeof === c;
        }, exports.isForwardRef = function(a) {
            return z(a) === n;
        }, exports.isFragment = function(a) {
            return z(a) === e;
        }, exports.isLazy = function(a) {
            return z(a) === t;
        }, exports.isMemo = function(a) {
            return z(a) === r;
        }, exports.isPortal = function(a) {
            return z(a) === d;
        }, exports.isProfiler = function(a) {
            return z(a) === g;
        }, exports.isStrictMode = function(a) {
            return z(a) === f;
        }, exports.isSuspense = function(a) {
            return z(a) === p;
        }, exports.isValidElementType = function(a) {
            return "string" == typeof a || "function" == typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" == typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
        }, exports.typeOf = z;
    }, /* 113 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /** @license React v16.13.1
	 * react-is.development.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            "production" !== process.env.NODE_ENV && !function() {
                function isValidElementType(type) {
                    // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
                    return "string" == typeof type || "function" == typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" == typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
                }
                function typeOf(object) {
                    if ("object" == typeof object && null !== object) {
                        var $$typeof = object.$$typeof;
                        switch ($$typeof) {
                          case REACT_ELEMENT_TYPE:
                            var type = object.type;
                            switch (type) {
                              case REACT_ASYNC_MODE_TYPE:
                              case REACT_CONCURRENT_MODE_TYPE:
                              case REACT_FRAGMENT_TYPE:
                              case REACT_PROFILER_TYPE:
                              case REACT_STRICT_MODE_TYPE:
                              case REACT_SUSPENSE_TYPE:
                                return type;

                              default:
                                var $$typeofType = type && type.$$typeof;
                                switch ($$typeofType) {
                                  case REACT_CONTEXT_TYPE:
                                  case REACT_FORWARD_REF_TYPE:
                                  case REACT_LAZY_TYPE:
                                  case REACT_MEMO_TYPE:
                                  case REACT_PROVIDER_TYPE:
                                    return $$typeofType;

                                  default:
                                    return $$typeof;
                                }
                            }

                          case REACT_PORTAL_TYPE:
                            return $$typeof;
                        }
                    }
                }
                // AsyncMode should be deprecated
                function isAsyncMode(object) {
                    // Using console['warn'] to evade Babel and ESLint
                    return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, 
                    console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), 
                    isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
                }
                function isConcurrentMode(object) {
                    return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
                }
                function isContextConsumer(object) {
                    return typeOf(object) === REACT_CONTEXT_TYPE;
                }
                function isContextProvider(object) {
                    return typeOf(object) === REACT_PROVIDER_TYPE;
                }
                function isElement(object) {
                    return "object" == typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
                }
                function isForwardRef(object) {
                    return typeOf(object) === REACT_FORWARD_REF_TYPE;
                }
                function isFragment(object) {
                    return typeOf(object) === REACT_FRAGMENT_TYPE;
                }
                function isLazy(object) {
                    return typeOf(object) === REACT_LAZY_TYPE;
                }
                function isMemo(object) {
                    return typeOf(object) === REACT_MEMO_TYPE;
                }
                function isPortal(object) {
                    return typeOf(object) === REACT_PORTAL_TYPE;
                }
                function isProfiler(object) {
                    return typeOf(object) === REACT_PROFILER_TYPE;
                }
                function isStrictMode(object) {
                    return typeOf(object) === REACT_STRICT_MODE_TYPE;
                }
                function isSuspense(object) {
                    return typeOf(object) === REACT_SUSPENSE_TYPE;
                }
                // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
                // nor polyfill, then a plain number is used for performance.
                var hasSymbol = "function" == typeof Symbol && Symbol.for, REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103, REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106, REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107, REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108, REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114, REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109, REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110, REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111, REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111, REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112, REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113, REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120, REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115, REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116, REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121, REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117, REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118, REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119, AsyncMode = REACT_ASYNC_MODE_TYPE, ConcurrentMode = REACT_CONCURRENT_MODE_TYPE, ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1;
                exports.AsyncMode = AsyncMode, exports.ConcurrentMode = ConcurrentMode, exports.ContextConsumer = ContextConsumer, 
                exports.ContextProvider = ContextProvider, exports.Element = Element, exports.ForwardRef = ForwardRef, 
                exports.Fragment = Fragment, exports.Lazy = Lazy, exports.Memo = Memo, exports.Portal = Portal, 
                exports.Profiler = Profiler, exports.StrictMode = StrictMode, exports.Suspense = Suspense, 
                exports.isAsyncMode = isAsyncMode, exports.isConcurrentMode = isConcurrentMode, 
                exports.isContextConsumer = isContextConsumer, exports.isContextProvider = isContextProvider, 
                exports.isElement = isElement, exports.isForwardRef = isForwardRef, exports.isFragment = isFragment, 
                exports.isLazy = isLazy, exports.isMemo = isMemo, exports.isPortal = isPortal, exports.isProfiler = isProfiler, 
                exports.isStrictMode = isStrictMode, exports.isSuspense = isSuspense, exports.isValidElementType = isValidElementType, 
                exports.typeOf = typeOf;
            }();
        }).call(exports, __webpack_require__(110));
    }, /* 114 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            function emptyFunctionThatReturnsNull() {
                return null;
            }
            var ReactIs = __webpack_require__(111), assign = __webpack_require__(115), ReactPropTypesSecret = __webpack_require__(116), checkPropTypes = __webpack_require__(117), has = Function.call.bind(Object.prototype.hasOwnProperty), printWarning = function() {};
            "production" !== process.env.NODE_ENV && (printWarning = function(text) {
                var message = "Warning: " + text;
                "undefined" != typeof console && console.error(message);
                try {
                    // --- Welcome to debugging React ---
                    // This error was thrown as a convenience so that you can use this stack
                    // to find the callsite that caused this warning to fire.
                    throw new Error(message);
                } catch (x) {}
            }), module.exports = function(isValidElement, throwOnDirectAccess) {
                // Before Symbol spec.
                /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
                function getIteratorFn(maybeIterable) {
                    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
                    if ("function" == typeof iteratorFn) return iteratorFn;
                }
                /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
                /*eslint-disable no-self-compare*/
                function is(x, y) {
                    // SameValue algorithm
                    // SameValue algorithm
                    return x === y ? 0 !== x || 1 / x === 1 / y : x !== x && y !== y;
                }
                /*eslint-enable no-self-compare*/
                /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
                function PropTypeError(message) {
                    this.message = message, this.stack = "";
                }
                function createChainableTypeChecker(validate) {
                    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
                        if (componentName = componentName || ANONYMOUS, propFullName = propFullName || propName, 
                        secret !== ReactPropTypesSecret) {
                            if (throwOnDirectAccess) {
                                // New behavior only for users of `prop-types` package
                                var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
                                throw err.name = "Invariant Violation", err;
                            }
                            if ("production" !== process.env.NODE_ENV && "undefined" != typeof console) {
                                // Old behavior for people using React.PropTypes
                                var cacheKey = componentName + ":" + propName;
                                !manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                                manualPropTypeWarningCount < 3 && (printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."), 
                                manualPropTypeCallCache[cacheKey] = !0, manualPropTypeWarningCount++);
                            }
                        }
                        return null == props[propName] ? isRequired ? new PropTypeError(null === props[propName] ? "The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`.") : "The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`.")) : null : validate(props, propName, componentName, location, propFullName);
                    }
                    if ("production" !== process.env.NODE_ENV) var manualPropTypeCallCache = {}, manualPropTypeWarningCount = 0;
                    var chainedCheckType = checkType.bind(null, !1);
                    return chainedCheckType.isRequired = checkType.bind(null, !0), chainedCheckType;
                }
                function createPrimitiveTypeChecker(expectedType) {
                    function validate(props, propName, componentName, location, propFullName, secret) {
                        var propValue = props[propName], propType = getPropType(propValue);
                        if (propType !== expectedType) {
                            // `propValue` being instance of, say, date/regexp, pass the 'object'
                            // check, but we can offer a more precise error message here rather than
                            // 'of type `object`'.
                            var preciseType = getPreciseType(propValue);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createAnyTypeChecker() {
                    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
                }
                function createArrayOfTypeChecker(typeChecker) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if ("function" != typeof typeChecker) return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
                        var propValue = props[propName];
                        if (!Array.isArray(propValue)) {
                            var propType = getPropType(propValue);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
                        }
                        for (var i = 0; i < propValue.length; i++) {
                            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
                            if (error instanceof Error) return error;
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createElementTypeChecker() {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName];
                        if (!isValidElement(propValue)) {
                            var propType = getPropType(propValue);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createElementTypeTypeChecker() {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName];
                        if (!ReactIs.isValidElementType(propValue)) {
                            var propType = getPropType(propValue);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createInstanceTypeChecker(expectedClass) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if (!(props[propName] instanceof expectedClass)) {
                            var expectedClassName = expectedClass.name || ANONYMOUS, actualClassName = getClassName(props[propName]);
                            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createEnumTypeChecker(expectedValues) {
                    function validate(props, propName, componentName, location, propFullName) {
                        for (var propValue = props[propName], i = 0; i < expectedValues.length; i++) if (is(propValue, expectedValues[i])) return null;
                        var valuesString = JSON.stringify(expectedValues, function(key, value) {
                            var type = getPreciseType(value);
                            return "symbol" === type ? String(value) : value;
                        });
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
                    }
                    return Array.isArray(expectedValues) ? createChainableTypeChecker(validate) : ("production" !== process.env.NODE_ENV && printWarning(arguments.length > 1 ? "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])." : "Invalid argument supplied to oneOf, expected an array."), 
                    emptyFunctionThatReturnsNull);
                }
                function createObjectOfTypeChecker(typeChecker) {
                    function validate(props, propName, componentName, location, propFullName) {
                        if ("function" != typeof typeChecker) return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
                        var propValue = props[propName], propType = getPropType(propValue);
                        if ("object" !== propType) return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
                        for (var key in propValue) if (has(propValue, key)) {
                            var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                            if (error instanceof Error) return error;
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createUnionTypeChecker(arrayOfTypeCheckers) {
                    function validate(props, propName, componentName, location, propFullName) {
                        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                            var checker = arrayOfTypeCheckers[i];
                            if (null == checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret)) return null;
                        }
                        return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
                    }
                    if (!Array.isArray(arrayOfTypeCheckers)) return "production" !== process.env.NODE_ENV ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0, 
                    emptyFunctionThatReturnsNull;
                    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                        var checker = arrayOfTypeCheckers[i];
                        if ("function" != typeof checker) return printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."), 
                        emptyFunctionThatReturnsNull;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createNodeChecker() {
                    function validate(props, propName, componentName, location, propFullName) {
                        return isNode(props[propName]) ? null : new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
                    }
                    return createChainableTypeChecker(validate);
                }
                function createShapeTypeChecker(shapeTypes) {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName], propType = getPropType(propValue);
                        if ("object" !== propType) return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                        for (var key in shapeTypes) {
                            var checker = shapeTypes[key];
                            if (checker) {
                                var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                                if (error) return error;
                            }
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function createStrictShapeTypeChecker(shapeTypes) {
                    function validate(props, propName, componentName, location, propFullName) {
                        var propValue = props[propName], propType = getPropType(propValue);
                        if ("object" !== propType) return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                        // We need to check all keys in case some are required but missing from
                        // props.
                        var allKeys = assign({}, props[propName], shapeTypes);
                        for (var key in allKeys) {
                            var checker = shapeTypes[key];
                            if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
                            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                            if (error) return error;
                        }
                        return null;
                    }
                    return createChainableTypeChecker(validate);
                }
                function isNode(propValue) {
                    switch (typeof propValue) {
                      case "number":
                      case "string":
                      case "undefined":
                        return !0;

                      case "boolean":
                        return !propValue;

                      case "object":
                        if (Array.isArray(propValue)) return propValue.every(isNode);
                        if (null === propValue || isValidElement(propValue)) return !0;
                        var iteratorFn = getIteratorFn(propValue);
                        if (!iteratorFn) return !1;
                        var step, iterator = iteratorFn.call(propValue);
                        if (iteratorFn !== propValue.entries) {
                            for (;!(step = iterator.next()).done; ) if (!isNode(step.value)) return !1;
                        } else // Iterator will provide entry [k,v] tuples rather than values.
                        for (;!(step = iterator.next()).done; ) {
                            var entry = step.value;
                            if (entry && !isNode(entry[1])) return !1;
                        }
                        return !0;

                      default:
                        return !1;
                    }
                }
                function isSymbol(propType, propValue) {
                    // Native Symbol.
                    // Native Symbol.
                    // falsy value can't be a Symbol
                    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
                    return "symbol" === propType || !!propValue && ("Symbol" === propValue["@@toStringTag"] || "function" == typeof Symbol && propValue instanceof Symbol);
                }
                // Equivalent of `typeof` but with special handling for array and regexp.
                function getPropType(propValue) {
                    var propType = typeof propValue;
                    return Array.isArray(propValue) ? "array" : propValue instanceof RegExp ? "object" : isSymbol(propType, propValue) ? "symbol" : propType;
                }
                // This handles more types than `getPropType`. Only used for error messages.
                // See `createPrimitiveTypeChecker`.
                function getPreciseType(propValue) {
                    if ("undefined" == typeof propValue || null === propValue) return "" + propValue;
                    var propType = getPropType(propValue);
                    if ("object" === propType) {
                        if (propValue instanceof Date) return "date";
                        if (propValue instanceof RegExp) return "regexp";
                    }
                    return propType;
                }
                // Returns a string that is postfixed to a warning about an invalid type.
                // For example, "undefined" or "of type array"
                function getPostfixForTypeWarning(value) {
                    var type = getPreciseType(value);
                    switch (type) {
                      case "array":
                      case "object":
                        return "an " + type;

                      case "boolean":
                      case "date":
                      case "regexp":
                        return "a " + type;

                      default:
                        return type;
                    }
                }
                // Returns class name of the object, if any.
                function getClassName(propValue) {
                    return propValue.constructor && propValue.constructor.name ? propValue.constructor.name : ANONYMOUS;
                }
                /* global Symbol */
                var ITERATOR_SYMBOL = "function" == typeof Symbol && Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator", ANONYMOUS = "<<anonymous>>", ReactPropTypes = {
                    array: createPrimitiveTypeChecker("array"),
                    bool: createPrimitiveTypeChecker("boolean"),
                    func: createPrimitiveTypeChecker("function"),
                    number: createPrimitiveTypeChecker("number"),
                    object: createPrimitiveTypeChecker("object"),
                    string: createPrimitiveTypeChecker("string"),
                    symbol: createPrimitiveTypeChecker("symbol"),
                    any: createAnyTypeChecker(),
                    arrayOf: createArrayOfTypeChecker,
                    element: createElementTypeChecker(),
                    elementType: createElementTypeTypeChecker(),
                    instanceOf: createInstanceTypeChecker,
                    node: createNodeChecker(),
                    objectOf: createObjectOfTypeChecker,
                    oneOf: createEnumTypeChecker,
                    oneOfType: createUnionTypeChecker,
                    shape: createShapeTypeChecker,
                    exact: createStrictShapeTypeChecker
                };
                // Make `instanceof Error` still work for returned errors.
                return PropTypeError.prototype = Error.prototype, ReactPropTypes.checkPropTypes = checkPropTypes, 
                ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache, ReactPropTypes.PropTypes = ReactPropTypes, 
                ReactPropTypes;
            };
        }).call(exports, __webpack_require__(110));
    }, /* 115 */
    /***/
    function(module, exports) {
        /*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
        "use strict";
        function toObject(val) {
            if (null === val || void 0 === val) throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(val);
        }
        function shouldUseNative() {
            try {
                if (!Object.assign) return !1;
                // Detect buggy property enumeration order in older V8 versions.
                // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                var test1 = new String("abc");
                if (// eslint-disable-line no-new-wrappers
                test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                    return test2[n];
                });
                if ("0123456789" !== order2.join("")) return !1;
                // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                var test3 = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                    test3[letter] = letter;
                }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
            } catch (err) {
                // We don't expect any of the above to throw, but better to be safe.
                return !1;
            }
        }
        /* eslint-disable no-unused-vars */
        var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
        module.exports = shouldUseNative() ? Object.assign : function(target, source) {
            for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                }
            }
            return to;
        };
    }, /* 116 */
    /***/
    function(module, exports) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
        "use strict";
        var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        module.exports = ReactPropTypesSecret;
    }, /* 117 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            /**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
            function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
                if ("production" !== process.env.NODE_ENV) for (var typeSpecName in typeSpecs) if (has(typeSpecs, typeSpecName)) {
                    var error;
                    // Prop type validation may throw. In case they do, we don't want to
                    // fail the render phase where it didn't fail before. So we log it.
                    // After these have been cleaned up, we'll let them throw.
                    try {
                        // This is intentionally an invariant that gets caught. It's the same
                        // behavior as without this statement except with a better message.
                        if ("function" != typeof typeSpecs[typeSpecName]) {
                            var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.");
                            throw err.name = "Invariant Violation", err;
                        }
                        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                    } catch (ex) {
                        error = ex;
                    }
                    if (!error || error instanceof Error || printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."), 
                    error instanceof Error && !(error.message in loggedTypeFailures)) {
                        // Only monitor this failure once because there tends to be a lot of the
                        // same error.
                        loggedTypeFailures[error.message] = !0;
                        var stack = getStack ? getStack() : "";
                        printWarning("Failed " + location + " type: " + error.message + (null != stack ? stack : ""));
                    }
                }
            }
            var printWarning = function() {};
            if ("production" !== process.env.NODE_ENV) {
                var ReactPropTypesSecret = __webpack_require__(116), loggedTypeFailures = {}, has = Function.call.bind(Object.prototype.hasOwnProperty);
                printWarning = function(text) {
                    var message = "Warning: " + text;
                    "undefined" != typeof console && console.error(message);
                    try {
                        // --- Welcome to debugging React ---
                        // This error was thrown as a convenience so that you can use this stack
                        // to find the callsite that caused this warning to fire.
                        throw new Error(message);
                    } catch (x) {}
                };
            }
            /**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
            checkPropTypes.resetWarningCache = function() {
                "production" !== process.env.NODE_ENV && (loggedTypeFailures = {});
            }, module.exports = checkPropTypes;
        }).call(exports, __webpack_require__(110));
    }, /* 118 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
        "use strict";
        function emptyFunction() {}
        function emptyFunctionWithReset() {}
        var ReactPropTypesSecret = __webpack_require__(116);
        emptyFunctionWithReset.resetWarningCache = emptyFunction, module.exports = function() {
            function shim(props, propName, componentName, location, propFullName, secret) {
                if (secret !== ReactPropTypesSecret) {
                    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                    throw err.name = "Invariant Violation", err;
                }
            }
            function getShim() {
                return shim;
            }
            shim.isRequired = shim;
            // Important!
            // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
            var ReactPropTypes = {
                array: shim,
                bool: shim,
                func: shim,
                number: shim,
                object: shim,
                string: shim,
                symbol: shim,
                any: shim,
                arrayOf: getShim,
                element: shim,
                elementType: shim,
                instanceOf: getShim,
                node: shim,
                objectOf: getShim,
                oneOf: getShim,
                oneOfType: getShim,
                shape: getShim,
                exact: getShim,
                checkPropTypes: emptyFunctionWithReset,
                resetWarningCache: emptyFunction
            };
            return ReactPropTypes.PropTypes = ReactPropTypes, ReactPropTypes;
        };
    }, /* 119 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function normalizeLineEndings(str) {
            return str ? str.replace(/\r\n|\r/g, "\n") : str;
        }
        var React = __webpack_require__(108), PropTypes = (__webpack_require__(120), __webpack_require__(109)), className = __webpack_require__(121), debounce = __webpack_require__(122), isEqual = __webpack_require__(123), createReactClass = __webpack_require__(125), CodeMirror = createReactClass({
            propTypes: {
                autoFocus: PropTypes.bool,
                className: PropTypes.any,
                codeMirrorInstance: PropTypes.func,
                defaultValue: PropTypes.string,
                name: PropTypes.string,
                onChange: PropTypes.func,
                onCursorActivity: PropTypes.func,
                onFocusChange: PropTypes.func,
                onScroll: PropTypes.func,
                options: PropTypes.object,
                path: PropTypes.string,
                value: PropTypes.string,
                preserveScrollPosition: PropTypes.bool
            },
            getDefaultProps: function() {
                return {
                    preserveScrollPosition: !1
                };
            },
            getCodeMirrorInstance: function() {
                return this.props.codeMirrorInstance || __webpack_require__(131);
            },
            getInitialState: function() {
                return {
                    isFocused: !1
                };
            },
            componentWillMount: function() {
                this.componentWillReceiveProps = debounce(this.componentWillReceiveProps, 0), this.props.path && console.error("Warning: react-codemirror: the `path` prop has been changed to `name`");
            },
            componentDidMount: function() {
                var codeMirrorInstance = this.getCodeMirrorInstance();
                this.codeMirror = codeMirrorInstance.fromTextArea(this.textareaNode, this.props.options), 
                this.codeMirror.on("change", this.codemirrorValueChanged), this.codeMirror.on("cursorActivity", this.cursorActivity), 
                this.codeMirror.on("focus", this.focusChanged.bind(this, !0)), this.codeMirror.on("blur", this.focusChanged.bind(this, !1)), 
                this.codeMirror.on("scroll", this.scrollChanged), this.codeMirror.setValue(this.props.defaultValue || this.props.value || "");
            },
            componentWillUnmount: function() {
                // is there a lighter-weight way to remove the cm instance?
                this.codeMirror && this.codeMirror.toTextArea();
            },
            componentWillReceiveProps: function(nextProps) {
                if (this.codeMirror && void 0 !== nextProps.value && nextProps.value !== this.props.value && normalizeLineEndings(this.codeMirror.getValue()) !== normalizeLineEndings(nextProps.value)) if (this.props.preserveScrollPosition) {
                    var prevScrollPosition = this.codeMirror.getScrollInfo();
                    this.codeMirror.setValue(nextProps.value), this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
                } else this.codeMirror.setValue(nextProps.value);
                if ("object" == typeof nextProps.options) for (var optionName in nextProps.options) nextProps.options.hasOwnProperty(optionName) && this.setOptionIfChanged(optionName, nextProps.options[optionName]);
            },
            setOptionIfChanged: function(optionName, newValue) {
                var oldValue = this.codeMirror.getOption(optionName);
                isEqual(oldValue, newValue) || this.codeMirror.setOption(optionName, newValue);
            },
            getCodeMirror: function() {
                return this.codeMirror;
            },
            focus: function() {
                this.codeMirror && this.codeMirror.focus();
            },
            focusChanged: function(focused) {
                this.setState({
                    isFocused: focused
                }), this.props.onFocusChange && this.props.onFocusChange(focused);
            },
            cursorActivity: function(cm) {
                this.props.onCursorActivity && this.props.onCursorActivity(cm);
            },
            scrollChanged: function(cm) {
                this.props.onScroll && this.props.onScroll(cm.getScrollInfo());
            },
            codemirrorValueChanged: function(doc, change) {
                this.props.onChange && "setValue" !== change.origin && this.props.onChange(doc.getValue(), change);
            },
            render: function() {
                var _this = this, editorClassName = className("ReactCodeMirror", this.state.isFocused ? "ReactCodeMirror--focused" : null, this.props.className);
                return React.createElement("div", {
                    className: editorClassName
                }, React.createElement("textarea", {
                    ref: function(ref) {
                        return _this.textareaNode = ref;
                    },
                    name: this.props.name || this.props.path,
                    defaultValue: this.props.value,
                    autoComplete: "off",
                    autoFocus: this.props.autoFocus
                }));
            }
        });
        module.exports = CodeMirror;
    }, /* 120 */
    /***/
    function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_120__;
    }, /* 121 */
    /***/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
	  Copyright (c) 2017 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
        /* global define */
        !function() {
            "use strict";
            function classNames() {
                for (var classes = [], i = 0; i < arguments.length; i++) {
                    var arg = arguments[i];
                    if (arg) {
                        var argType = typeof arg;
                        if ("string" === argType || "number" === argType) classes.push(arg); else if (Array.isArray(arg) && arg.length) {
                            var inner = classNames.apply(null, arg);
                            inner && classes.push(inner);
                        } else if ("object" === argType) for (var key in arg) hasOwn.call(arg, key) && arg[key] && classes.push(key);
                    }
                }
                return classes.join(" ");
            }
            var hasOwn = {}.hasOwnProperty;
            "undefined" != typeof module && module.exports ? (classNames.default = classNames, 
            module.exports = classNames) : (__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return classNames;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), // register as 'classnames', consistent with npm package name
            !(void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)));
        }();
    }, /* 122 */
    /***/
    function(module, exports) {
        /* WEBPACK VAR INJECTION */
        (function(global) {
            /**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
            function debounce(func, wait, options) {
                function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
                }
                function leadingEdge(time) {
                    // Invoke the leading edge.
                    // Reset any `maxWait` timer.
                    // Start the timer for the trailing edge.
                    return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                }
                function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    // Either this is the first call, activity has stopped and we're at the
                    // trailing edge, the system time has gone backwards and we're treating
                    // it as the trailing edge, or we've hit the `maxWait` limit.
                    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                    var time = now();
                    // Restart the timer.
                    return shouldInvoke(time) ? trailingEdge(time) : void (timerId = setTimeout(timerExpired, remainingWait(time)));
                }
                function trailingEdge(time) {
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, 
                    result);
                }
                function cancel() {
                    void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
                }
                function flush() {
                    return void 0 === timerId ? result : trailingEdge(now());
                }
                function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                        if (void 0 === timerId) return leadingEdge(lastCallTime);
                        if (maxing) // Handle invocations in a tight loop.
                        return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
                    }
                    return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
                }
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, 
                maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, 
                trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, 
                debounced.flush = flush, debounced;
            }
            /**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
            function isObject(value) {
                var type = typeof value;
                return !!value && ("object" == type || "function" == type);
            }
            /**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
            function isObjectLike(value) {
                return !!value && "object" == typeof value;
            }
            /**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
            function isSymbol(value) {
                return "symbol" == typeof value || isObjectLike(value) && objectToString.call(value) == symbolTag;
            }
            /**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
            function toNumber(value) {
                if ("number" == typeof value) return value;
                if (isSymbol(value)) return NAN;
                if (isObject(value)) {
                    var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                    value = isObject(other) ? other + "" : other;
                }
                if ("string" != typeof value) return 0 === value ? value : +value;
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            /**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
            /** Used as the `TypeError` message for "Functions" methods. */
            var FUNC_ERROR_TEXT = "Expected a function", NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), objectProto = Object.prototype, objectToString = objectProto.toString, nativeMax = Math.max, nativeMin = Math.min, now = function() {
                return root.Date.now();
            };
            module.exports = debounce;
        }).call(exports, function() {
            return this;
        }());
    }, /* 123 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(global, module) {
            /**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
            function arrayFilter(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                    var value = array[index];
                    predicate(value, index, array) && (result[resIndex++] = value);
                }
                return result;
            }
            /**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
            function arrayPush(array, values) {
                for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
                return array;
            }
            /**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
            function arraySome(array, predicate) {
                for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) if (predicate(array[index], index, array)) return !0;
                return !1;
            }
            /**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
            function baseTimes(n, iteratee) {
                for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
                return result;
            }
            /**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
            function baseUnary(func) {
                return function(value) {
                    return func(value);
                };
            }
            /**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function cacheHas(cache, key) {
                return cache.has(key);
            }
            /**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
            function getValue(object, key) {
                return null == object ? void 0 : object[key];
            }
            /**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
            function mapToArray(map) {
                var index = -1, result = Array(map.size);
                return map.forEach(function(value, key) {
                    result[++index] = [ key, value ];
                }), result;
            }
            /**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
            function overArg(func, transform) {
                return function(arg) {
                    return func(transform(arg));
                };
            }
            /**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
            function setToArray(set) {
                var index = -1, result = Array(set.size);
                return set.forEach(function(value) {
                    result[++index] = value;
                }), result;
            }
            /**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function Hash(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            /**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
            function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
            }
            /**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                return this.size -= result ? 1 : 0, result;
            }
            /**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
            }
            /**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
            }
            /**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
            function hashSet(key, value) {
                var data = this.__data__;
                return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? HASH_UNDEFINED : value, 
                this;
            }
            /**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function ListCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            /**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
            function listCacheClear() {
                this.__data__ = [], this.size = 0;
            }
            /**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) return !1;
                var lastIndex = data.length - 1;
                return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, 
                !0;
            }
            /**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
            }
            /**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
            }
            /**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
            function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? (++this.size, data.push([ key, value ])) : data[index][1] = value, 
                this;
            }
            /**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function MapCache(entries) {
                var index = -1, length = null == entries ? 0 : entries.length;
                for (this.clear(); ++index < length; ) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                }
            }
            /**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
            function mapCacheClear() {
                this.size = 0, this.__data__ = {
                    hash: new Hash(),
                    map: new (Map || ListCache)(),
                    string: new Hash()
                };
            }
            /**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function mapCacheDelete(key) {
                var result = getMapData(this, key).delete(key);
                return this.size -= result ? 1 : 0, result;
            }
            /**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function mapCacheGet(key) {
                return getMapData(this, key).get(key);
            }
            /**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function mapCacheHas(key) {
                return getMapData(this, key).has(key);
            }
            /**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
            function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
            }
            /**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
            function SetCache(values) {
                var index = -1, length = null == values ? 0 : values.length;
                for (this.__data__ = new MapCache(); ++index < length; ) this.add(values[index]);
            }
            /**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
            function setCacheAdd(value) {
                return this.__data__.set(value, HASH_UNDEFINED), this;
            }
            /**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
            function setCacheHas(value) {
                return this.__data__.has(value);
            }
            /**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
            function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
            }
            /**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
            function stackClear() {
                this.__data__ = new ListCache(), this.size = 0;
            }
            /**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
            function stackDelete(key) {
                var data = this.__data__, result = data.delete(key);
                return this.size = data.size, result;
            }
            /**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
            function stackGet(key) {
                return this.__data__.get(key);
            }
            /**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
            function stackHas(key) {
                return this.__data__.has(key);
            }
            /**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
            function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key, value ]), 
                    this.size = ++data.size, this;
                    data = this.__data__ = new MapCache(pairs);
                }
                return data.set(key, value), this.size = data.size, this;
            }
            /**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
            function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && (// Safari 9 has enumerable `arguments.length` in strict mode.
                "length" == key || // Node.js 0.10 has enumerable non-index properties on buffers.
                isBuff && ("offset" == key || "parent" == key) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || // Skip index properties.
                isIndex(key, length)) || result.push(key);
                return result;
            }
            /**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
            function assocIndexOf(array, key) {
                for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
                return -1;
            }
            /**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
            }
            /**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
            function baseGetTag(value) {
                return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
            }
            /**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
            function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
            }
            /**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
            function baseIsEqual(value, other, bitmask, customizer, stack) {
                return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack));
            }
            /**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
            function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) return !1;
                    objIsArr = !0, objIsObj = !1;
                }
                if (isSameTag && !objIsObj) return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                    if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                        return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                    }
                }
                return !!isSameTag && (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack));
            }
            /**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
            function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) return !1;
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
            }
            /**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
            function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
            }
            /**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
            function baseKeys(object) {
                if (!isPrototype(object)) return nativeKeys(object);
                var result = [];
                for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
                return result;
            }
            /**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
            function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
                // Assume cyclic values are equal.
                var stacked = stack.get(array);
                if (stacked && stack.get(other)) return stacked == other;
                var index = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
                // Ignore non-index properties.
                for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
                    var arrValue = array[index], othValue = other[index];
                    if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                    if (void 0 !== compared) {
                        if (compared) continue;
                        result = !1;
                        break;
                    }
                    // Recursively compare arrays (susceptible to call stack limits).
                    if (seen) {
                        if (!arraySome(other, function(othValue, othIndex) {
                            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                        })) {
                            result = !1;
                            break;
                        }
                    } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                        result = !1;
                        break;
                    }
                }
                return stack.delete(array), stack.delete(other), result;
            }
            /**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
            function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                    object = object.buffer, other = other.buffer;

                  case arrayBufferTag:
                    return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));

                  case boolTag:
                  case dateTag:
                  case numberTag:
                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                    // Invalid dates are coerced to `NaN`.
                    return eq(+object, +other);

                  case errorTag:
                    return object.name == other.name && object.message == other.message;

                  case regexpTag:
                  case stringTag:
                    // Coerce regexes to strings and treat strings, primitives and objects,
                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                    // for more details.
                    return object == other + "";

                  case mapTag:
                    var convert = mapToArray;

                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                    // Assume cyclic values are equal.
                    var stacked = stack.get(object);
                    if (stacked) return stacked == other;
                    bitmask |= COMPARE_UNORDERED_FLAG, // Recursively compare objects (susceptible to call stack limits).
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    return stack.delete(object), result;

                  case symbolTag:
                    if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
                return !1;
            }
            /**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
            function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) return !1;
                for (var index = objLength; index--; ) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked && stack.get(other)) return stacked == other;
                var result = !0;
                stack.set(object, other), stack.set(other, object);
                for (var skipCtor = isPartial; ++index < objLength; ) {
                    key = objProps[index];
                    var objValue = object[key], othValue = other[key];
                    if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                    // Recursively compare objects (susceptible to call stack limits).
                    if (!(void 0 === compared ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                        result = !1;
                        break;
                    }
                    skipCtor || (skipCtor = "constructor" == key);
                }
                if (result && !skipCtor) {
                    var objCtor = object.constructor, othCtor = other.constructor;
                    // Non `Object` object instances with different constructors are not equal.
                    objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1);
                }
                return stack.delete(object), stack.delete(other), result;
            }
            /**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
            function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
            }
            /**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
            function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
            }
            /**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
            function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
            }
            /**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
            function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                    value[symToStringTag] = void 0;
                    var unmasked = !0;
                } catch (e) {}
                var result = nativeObjectToString.call(value);
                return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), 
                result;
            }
            /**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
            function isIndex(value, length) {
                return length = null == length ? MAX_SAFE_INTEGER : length, !!length && ("number" == typeof value || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
            }
            /**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
            function isKeyable(value) {
                var type = typeof value;
                return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
            }
            /**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
            function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
            }
            /**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
            function isPrototype(value) {
                var Ctor = value && value.constructor, proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
                return value === proto;
            }
            /**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
            function objectToString(value) {
                return nativeObjectToString.call(value);
            }
            /**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
            function toSource(func) {
                if (null != func) {
                    try {
                        return funcToString.call(func);
                    } catch (e) {}
                    try {
                        return func + "";
                    } catch (e) {}
                }
                return "";
            }
            /**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
            function eq(value, other) {
                return value === other || value !== value && other !== other;
            }
            /**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
            function isArrayLike(value) {
                return null != value && isLength(value.length) && !isFunction(value);
            }
            /**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
            function isEqual(value, other) {
                return baseIsEqual(value, other);
            }
            /**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
            function isFunction(value) {
                if (!isObject(value)) return !1;
                // The use of `Object#toString` avoids issues with the `typeof` operator
                // in Safari 9 which returns 'object' for typed arrays and other constructors.
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
            }
            /**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
            function isLength(value) {
                return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
            }
            /**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
            function isObject(value) {
                var type = typeof value;
                return null != value && ("object" == type || "function" == type);
            }
            /**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
            function isObjectLike(value) {
                return null != value && "object" == typeof value;
            }
            /**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
            function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
            }
            /**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
            function stubArray() {
                return [];
            }
            /**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
            function stubFalse() {
                return !1;
            }
            /**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
            /** Used as the size to enable large array optimizations. */
            var LARGE_ARRAY_SIZE = 200, HASH_UNDEFINED = "__lodash_hash_undefined__", COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, MAX_SAFE_INTEGER = 9007199254740991, argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsUint = /^(?:0|[1-9]\d*)$/, typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, 
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
            /** Detect free variable `global` from Node.js. */
            var freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
                try {
                    return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {}
            }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype, coreJsData = root["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
            }(), nativeObjectToString = objectProto.toString, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Buffer = moduleExports ? root.Buffer : void 0, Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : void 0, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object), DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create"), dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
            // Add methods to `Hash`.
            Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, 
            Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, // Add methods to `ListCache`.
            ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, 
            ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, 
            ListCache.prototype.set = listCacheSet, // Add methods to `MapCache`.
            MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, 
            MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, 
            // Add methods to `SetCache`.
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, 
            // Add methods to `Stack`.
            Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, 
            Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
            /**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
            var getSymbols = nativeGetSymbols ? function(object) {
                return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                }));
            } : stubArray, getTag = baseGetTag;
            // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
            (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) && (getTag = function(value) {
                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
                if (ctorString) switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;

                  case mapCtorString:
                    return mapTag;

                  case promiseCtorString:
                    return promiseTag;

                  case setCtorString:
                    return setTag;

                  case weakMapCtorString:
                    return weakMapTag;
                }
                return result;
            });
            /**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
            var isArguments = baseIsArguments(function() {
                return arguments;
            }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
            }, isArray = Array.isArray, isBuffer = nativeIsBuffer || stubFalse, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
            module.exports = isEqual;
        }).call(exports, function() {
            return this;
        }(), __webpack_require__(124)(module));
    }, /* 124 */
    /***/
    function(module, exports) {
        module.exports = function(module) {
            // module.parent = undefined by default
            return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [], 
            module.children = [], module.webpackPolyfill = 1), module;
        };
    }, /* 125 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
        "use strict";
        var React = __webpack_require__(108), factory = __webpack_require__(126);
        if ("undefined" == typeof React) throw Error("create-react-class could not find the React object. If you are using script tags, make sure that React is being loaded before create-react-class.");
        // Hack to grab NoopUpdateQueue from isomorphic React
        var ReactNoopUpdateQueue = new React.Component().updater;
        module.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);
    }, /* 126 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            // Helper function to allow the creation of anonymous functions which do not
            // have .name set to the name of the variable being assigned to.
            function identity(fn) {
                return fn;
            }
            function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
                function validateTypeDef(Constructor, typeDef, location) {
                    for (var propName in typeDef) typeDef.hasOwnProperty(propName) && "production" !== process.env.NODE_ENV && warning("function" == typeof typeDef[propName], "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.", Constructor.displayName || "ReactClass", ReactPropTypeLocationNames[location], propName);
                }
                function validateMethodOverride(isAlreadyDefined, name) {
                    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
                    // Disallow overriding of base class methods unless explicitly allowed.
                    ReactClassMixin.hasOwnProperty(name) && _invariant("OVERRIDE_BASE" === specPolicy, "ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.", name), 
                    // Disallow defining methods more than once unless explicitly allowed.
                    isAlreadyDefined && _invariant("DEFINE_MANY" === specPolicy || "DEFINE_MANY_MERGED" === specPolicy, "ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name);
                }
                /**
	   * Mixin helper which handles policy validation and reserved
	   * specification keys when building React classes.
	   */
                function mixSpecIntoComponent(Constructor, spec) {
                    if (spec) {
                        _invariant("function" != typeof spec, "ReactClass: You're attempting to use a component class or function as a mixin. Instead, just use a regular object."), 
                        _invariant(!isValidElement(spec), "ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object.");
                        var proto = Constructor.prototype, autoBindPairs = proto.__reactAutoBindPairs;
                        // By handling mixins before any other properties, we ensure the same
                        // chaining order is applied to methods with DEFINE_MANY policy, whether
                        // mixins are listed before or after these methods in the spec.
                        spec.hasOwnProperty(MIXINS_KEY) && RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
                        for (var name in spec) if (spec.hasOwnProperty(name) && name !== MIXINS_KEY) {
                            var property = spec[name], isAlreadyDefined = proto.hasOwnProperty(name);
                            if (validateMethodOverride(isAlreadyDefined, name), RESERVED_SPEC_KEYS.hasOwnProperty(name)) RESERVED_SPEC_KEYS[name](Constructor, property); else {
                                // Setup methods on prototype:
                                // The following member methods should not be automatically bound:
                                // 1. Expected ReactClass methods (in the "interface").
                                // 2. Overridden methods (that were mixed in).
                                var isReactClassMethod = ReactClassInterface.hasOwnProperty(name), isFunction = "function" == typeof property, shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== !1;
                                if (shouldAutoBind) autoBindPairs.push(name, property), proto[name] = property; else if (isAlreadyDefined) {
                                    var specPolicy = ReactClassInterface[name];
                                    // These cases should already be caught by validateMethodOverride.
                                    _invariant(isReactClassMethod && ("DEFINE_MANY_MERGED" === specPolicy || "DEFINE_MANY" === specPolicy), "ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.", specPolicy, name), 
                                    // For methods which are defined more than once, call the existing
                                    // methods before calling the new property, merging if appropriate.
                                    "DEFINE_MANY_MERGED" === specPolicy ? proto[name] = createMergedResultFunction(proto[name], property) : "DEFINE_MANY" === specPolicy && (proto[name] = createChainedFunction(proto[name], property));
                                } else proto[name] = property, "production" !== process.env.NODE_ENV && "function" == typeof property && spec.displayName && (proto[name].displayName = spec.displayName + "_" + name);
                            }
                        }
                    } else if ("production" !== process.env.NODE_ENV) {
                        var typeofSpec = typeof spec, isMixinValid = "object" === typeofSpec && null !== spec;
                        "production" !== process.env.NODE_ENV && warning(isMixinValid, "%s: You're attempting to include a mixin that is either null or not an object. Check the mixins included by the component, as well as any mixins they include themselves. Expected object but got %s.", Constructor.displayName || "ReactClass", null === spec ? null : typeofSpec);
                    }
                }
                function mixStaticSpecIntoComponent(Constructor, statics) {
                    if (statics) for (var name in statics) {
                        var property = statics[name];
                        if (statics.hasOwnProperty(name)) {
                            var isReserved = name in RESERVED_SPEC_KEYS;
                            _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name);
                            var isAlreadyDefined = name in Constructor;
                            if (isAlreadyDefined) {
                                var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;
                                return _invariant("DEFINE_MANY_MERGED" === specPolicy, "ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.", name), 
                                void (Constructor[name] = createMergedResultFunction(Constructor[name], property));
                            }
                            Constructor[name] = property;
                        }
                    }
                }
                /**
	   * Merge two objects, but throw if both contain the same key.
	   *
	   * @param {object} one The first object, which is mutated.
	   * @param {object} two The second object
	   * @return {object} one after it has been mutated to contain everything in two.
	   */
                function mergeIntoWithNoDuplicateKeys(one, two) {
                    _invariant(one && two && "object" == typeof one && "object" == typeof two, "mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");
                    for (var key in two) two.hasOwnProperty(key) && (_invariant(void 0 === one[key], "mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.", key), 
                    one[key] = two[key]);
                    return one;
                }
                /**
	   * Creates a function that invokes two functions and merges their return values.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
                function createMergedResultFunction(one, two) {
                    return function() {
                        var a = one.apply(this, arguments), b = two.apply(this, arguments);
                        if (null == a) return b;
                        if (null == b) return a;
                        var c = {};
                        return mergeIntoWithNoDuplicateKeys(c, a), mergeIntoWithNoDuplicateKeys(c, b), c;
                    };
                }
                /**
	   * Creates a function that invokes two functions and ignores their return vales.
	   *
	   * @param {function} one Function to invoke first.
	   * @param {function} two Function to invoke second.
	   * @return {function} Function that invokes the two argument functions.
	   * @private
	   */
                function createChainedFunction(one, two) {
                    return function() {
                        one.apply(this, arguments), two.apply(this, arguments);
                    };
                }
                /**
	   * Binds a method to the component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   * @param {function} method Method to be bound.
	   * @return {function} The bound method.
	   */
                function bindAutoBindMethod(component, method) {
                    var boundMethod = method.bind(component);
                    if ("production" !== process.env.NODE_ENV) {
                        boundMethod.__reactBoundContext = component, boundMethod.__reactBoundMethod = method, 
                        boundMethod.__reactBoundArguments = null;
                        var componentName = component.constructor.displayName, _bind = boundMethod.bind;
                        boundMethod.bind = function(newThis) {
                            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                            // User is trying to bind() an autobound method; we effectively will
                            // ignore the value of "this" that the user is trying to use, so
                            // let's warn.
                            if (newThis !== component && null !== newThis) "production" !== process.env.NODE_ENV && warning(!1, "bind(): React component methods may only be bound to the component instance. See %s", componentName); else if (!args.length) return "production" !== process.env.NODE_ENV && warning(!1, "bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See %s", componentName), 
                            boundMethod;
                            var reboundMethod = _bind.apply(boundMethod, arguments);
                            return reboundMethod.__reactBoundContext = component, reboundMethod.__reactBoundMethod = method, 
                            reboundMethod.__reactBoundArguments = args, reboundMethod;
                        };
                    }
                    return boundMethod;
                }
                /**
	   * Binds all auto-bound methods in a component.
	   *
	   * @param {object} component Component whose method is going to be bound.
	   */
                function bindAutoBindMethods(component) {
                    for (var pairs = component.__reactAutoBindPairs, i = 0; i < pairs.length; i += 2) {
                        var autoBindKey = pairs[i], method = pairs[i + 1];
                        component[autoBindKey] = bindAutoBindMethod(component, method);
                    }
                }
                /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
                function createClass(spec) {
                    // To keep our warnings more understandable, we'll use a little hack here to
                    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
                    // unnecessarily identify a class without displayName as 'Constructor'.
                    var Constructor = identity(function(props, context, updater) {
                        // This constructor gets overridden by mocks. The argument is used
                        // by mocks to assert on what gets mounted.
                        "production" !== process.env.NODE_ENV && warning(this instanceof Constructor, "Something is calling a React component directly. Use a factory or JSX instead. See: https://fb.me/react-legacyfactory"), 
                        // Wire up auto-binding
                        this.__reactAutoBindPairs.length && bindAutoBindMethods(this), this.props = props, 
                        this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue, 
                        this.state = null;
                        // ReactClasses doesn't have constructors. Instead, they use the
                        // getInitialState and componentWillMount methods for initialization.
                        var initialState = this.getInitialState ? this.getInitialState() : null;
                        "production" !== process.env.NODE_ENV && void 0 === initialState && this.getInitialState._isMockFunction && (// This is probably bad practice. Consider warning here and
                        // deprecating this convenience.
                        initialState = null), _invariant("object" == typeof initialState && !Array.isArray(initialState), "%s.getInitialState(): must return an object or null", Constructor.displayName || "ReactCompositeComponent"), 
                        this.state = initialState;
                    });
                    Constructor.prototype = new ReactClassComponent(), Constructor.prototype.constructor = Constructor, 
                    Constructor.prototype.__reactAutoBindPairs = [], injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor)), 
                    mixSpecIntoComponent(Constructor, IsMountedPreMixin), mixSpecIntoComponent(Constructor, spec), 
                    mixSpecIntoComponent(Constructor, IsMountedPostMixin), // Initialize the defaultProps property after all mixins have been merged.
                    Constructor.getDefaultProps && (Constructor.defaultProps = Constructor.getDefaultProps()), 
                    "production" !== process.env.NODE_ENV && (// This is a tag to indicate that the use of these method names is ok,
                    // since it's used with createClass. If it's not, then it's likely a
                    // mistake so we'll warn you to use the static property, property
                    // initializer or constructor respectively.
                    Constructor.getDefaultProps && (Constructor.getDefaultProps.isReactClassApproved = {}), 
                    Constructor.prototype.getInitialState && (Constructor.prototype.getInitialState.isReactClassApproved = {})), 
                    _invariant(Constructor.prototype.render, "createClass(...): Class specification must implement a `render` method."), 
                    "production" !== process.env.NODE_ENV && (warning(!Constructor.prototype.componentShouldUpdate, "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", spec.displayName || "A component"), 
                    warning(!Constructor.prototype.componentWillRecieveProps, "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", spec.displayName || "A component"), 
                    warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", spec.displayName || "A component"));
                    // Reduce time spent doing lookups by setting these on the prototype.
                    for (var methodName in ReactClassInterface) Constructor.prototype[methodName] || (Constructor.prototype[methodName] = null);
                    return Constructor;
                }
                /**
	   * Policies that describe methods in `ReactClassInterface`.
	   */
                var injectedMixins = [], ReactClassInterface = {
                    /**
	     * An array of Mixin objects to include when defining your component.
	     *
	     * @type {array}
	     * @optional
	     */
                    mixins: "DEFINE_MANY",
                    /**
	     * An object containing properties and methods that should be defined on
	     * the component's constructor instead of its prototype (static methods).
	     *
	     * @type {object}
	     * @optional
	     */
                    statics: "DEFINE_MANY",
                    /**
	     * Definition of prop types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
                    propTypes: "DEFINE_MANY",
                    /**
	     * Definition of context types for this component.
	     *
	     * @type {object}
	     * @optional
	     */
                    contextTypes: "DEFINE_MANY",
                    /**
	     * Definition of context types this component sets for its children.
	     *
	     * @type {object}
	     * @optional
	     */
                    childContextTypes: "DEFINE_MANY",
                    // ==== Definition methods ====
                    /**
	     * Invoked when the component is mounted. Values in the mapping will be set on
	     * `this.props` if that prop is not specified (i.e. using an `in` check).
	     *
	     * This method is invoked before `getInitialState` and therefore cannot rely
	     * on `this.state` or use `this.setState`.
	     *
	     * @return {object}
	     * @optional
	     */
                    getDefaultProps: "DEFINE_MANY_MERGED",
                    /**
	     * Invoked once before the component is mounted. The return value will be used
	     * as the initial value of `this.state`.
	     *
	     *   getInitialState: function() {
	     *     return {
	     *       isOn: false,
	     *       fooBaz: new BazFoo()
	     *     }
	     *   }
	     *
	     * @return {object}
	     * @optional
	     */
                    getInitialState: "DEFINE_MANY_MERGED",
                    /**
	     * @return {object}
	     * @optional
	     */
                    getChildContext: "DEFINE_MANY_MERGED",
                    /**
	     * Uses props from `this.props` and state from `this.state` to render the
	     * structure of the component.
	     *
	     * No guarantees are made about when or how often this method is invoked, so
	     * it must not have side effects.
	     *
	     *   render: function() {
	     *     var name = this.props.name;
	     *     return <div>Hello, {name}!</div>;
	     *   }
	     *
	     * @return {ReactComponent}
	     * @required
	     */
                    render: "DEFINE_ONCE",
                    // ==== Delegate methods ====
                    /**
	     * Invoked when the component is initially created and about to be mounted.
	     * This may have side effects, but any external subscriptions or data created
	     * by this method must be cleaned up in `componentWillUnmount`.
	     *
	     * @optional
	     */
                    componentWillMount: "DEFINE_MANY",
                    /**
	     * Invoked when the component has been mounted and has a DOM representation.
	     * However, there is no guarantee that the DOM node is in the document.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been mounted (initialized and rendered) for the first time.
	     *
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
                    componentDidMount: "DEFINE_MANY",
                    /**
	     * Invoked before the component receives new props.
	     *
	     * Use this as an opportunity to react to a prop transition by updating the
	     * state using `this.setState`. Current props are accessed via `this.props`.
	     *
	     *   componentWillReceiveProps: function(nextProps, nextContext) {
	     *     this.setState({
	     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	     *     });
	     *   }
	     *
	     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	     * transition may cause a state change, but the opposite is not true. If you
	     * need it, you are probably looking for `componentWillUpdate`.
	     *
	     * @param {object} nextProps
	     * @optional
	     */
                    componentWillReceiveProps: "DEFINE_MANY",
                    /**
	     * Invoked while deciding if the component should be updated as a result of
	     * receiving new props, state and/or context.
	     *
	     * Use this as an opportunity to `return false` when you're certain that the
	     * transition to the new props/state/context will not require a component
	     * update.
	     *
	     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	     *     return !equal(nextProps, this.props) ||
	     *       !equal(nextState, this.state) ||
	     *       !equal(nextContext, this.context);
	     *   }
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @return {boolean} True if the component should update.
	     * @optional
	     */
                    shouldComponentUpdate: "DEFINE_ONCE",
                    /**
	     * Invoked when the component is about to update due to a transition from
	     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	     * and `nextContext`.
	     *
	     * Use this as an opportunity to perform preparation before an update occurs.
	     *
	     * NOTE: You **cannot** use `this.setState()` in this method.
	     *
	     * @param {object} nextProps
	     * @param {?object} nextState
	     * @param {?object} nextContext
	     * @param {ReactReconcileTransaction} transaction
	     * @optional
	     */
                    componentWillUpdate: "DEFINE_MANY",
                    /**
	     * Invoked when the component's DOM representation has been updated.
	     *
	     * Use this as an opportunity to operate on the DOM when the component has
	     * been updated.
	     *
	     * @param {object} prevProps
	     * @param {?object} prevState
	     * @param {?object} prevContext
	     * @param {DOMElement} rootNode DOM element representing the component.
	     * @optional
	     */
                    componentDidUpdate: "DEFINE_MANY",
                    /**
	     * Invoked when the component is about to be removed from its parent and have
	     * its DOM representation destroyed.
	     *
	     * Use this as an opportunity to deallocate any external resources.
	     *
	     * NOTE: There is no `componentDidUnmount` since your component will have been
	     * destroyed by that point.
	     *
	     * @optional
	     */
                    componentWillUnmount: "DEFINE_MANY",
                    /**
	     * Replacement for (deprecated) `componentWillMount`.
	     *
	     * @optional
	     */
                    UNSAFE_componentWillMount: "DEFINE_MANY",
                    /**
	     * Replacement for (deprecated) `componentWillReceiveProps`.
	     *
	     * @optional
	     */
                    UNSAFE_componentWillReceiveProps: "DEFINE_MANY",
                    /**
	     * Replacement for (deprecated) `componentWillUpdate`.
	     *
	     * @optional
	     */
                    UNSAFE_componentWillUpdate: "DEFINE_MANY",
                    // ==== Advanced methods ====
                    /**
	     * Updates the component's currently mounted DOM representation.
	     *
	     * By default, this implements React's rendering and reconciliation algorithm.
	     * Sophisticated clients may wish to override this.
	     *
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     * @overridable
	     */
                    updateComponent: "OVERRIDE_BASE"
                }, ReactClassStaticInterface = {
                    /**
	     * This method is invoked after a component is instantiated and when it
	     * receives new props. Return an object to update state in response to
	     * prop changes. Return null to indicate no change to state.
	     *
	     * If an object is returned, its keys will be merged into the existing state.
	     *
	     * @return {object || null}
	     * @optional
	     */
                    getDerivedStateFromProps: "DEFINE_MANY_MERGED"
                }, RESERVED_SPEC_KEYS = {
                    displayName: function(Constructor, displayName) {
                        Constructor.displayName = displayName;
                    },
                    mixins: function(Constructor, mixins) {
                        if (mixins) for (var i = 0; i < mixins.length; i++) mixSpecIntoComponent(Constructor, mixins[i]);
                    },
                    childContextTypes: function(Constructor, childContextTypes) {
                        "production" !== process.env.NODE_ENV && validateTypeDef(Constructor, childContextTypes, "childContext"), 
                        Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
                    },
                    contextTypes: function(Constructor, contextTypes) {
                        "production" !== process.env.NODE_ENV && validateTypeDef(Constructor, contextTypes, "context"), 
                        Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
                    },
                    /**
	     * Special case getDefaultProps which should move into statics but requires
	     * automatic merging.
	     */
                    getDefaultProps: function(Constructor, getDefaultProps) {
                        Constructor.getDefaultProps ? Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps) : Constructor.getDefaultProps = getDefaultProps;
                    },
                    propTypes: function(Constructor, propTypes) {
                        "production" !== process.env.NODE_ENV && validateTypeDef(Constructor, propTypes, "prop"), 
                        Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
                    },
                    statics: function(Constructor, statics) {
                        mixStaticSpecIntoComponent(Constructor, statics);
                    },
                    autobind: function() {}
                }, IsMountedPreMixin = {
                    componentDidMount: function() {
                        this.__isMounted = !0;
                    }
                }, IsMountedPostMixin = {
                    componentWillUnmount: function() {
                        this.__isMounted = !1;
                    }
                }, ReactClassMixin = {
                    /**
	     * TODO: This will be deprecated because state should always keep a consistent
	     * type signature and the only use case for this, is to avoid that.
	     */
                    replaceState: function(newState, callback) {
                        this.updater.enqueueReplaceState(this, newState, callback);
                    },
                    /**
	     * Checks whether or not this composite component is mounted.
	     * @return {boolean} True if mounted, false otherwise.
	     * @protected
	     * @final
	     */
                    isMounted: function() {
                        return "production" !== process.env.NODE_ENV && (warning(this.__didWarnIsMounted, "%s: isMounted is deprecated. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.", this.constructor && this.constructor.displayName || this.name || "Component"), 
                        this.__didWarnIsMounted = !0), !!this.__isMounted;
                    }
                }, ReactClassComponent = function() {};
                return _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin), 
                createClass;
            }
            var _assign = __webpack_require__(115), emptyObject = __webpack_require__(127), _invariant = __webpack_require__(128);
            if ("production" !== process.env.NODE_ENV) var warning = __webpack_require__(129);
            var ReactPropTypeLocationNames, MIXINS_KEY = "mixins";
            ReactPropTypeLocationNames = "production" !== process.env.NODE_ENV ? {
                prop: "prop",
                context: "context",
                childContext: "child context"
            } : {}, module.exports = factory;
        }).call(exports, __webpack_require__(110));
    }, /* 127 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            var emptyObject = {};
            "production" !== process.env.NODE_ENV && Object.freeze(emptyObject), module.exports = emptyObject;
        }).call(exports, __webpack_require__(110));
    }, /* 128 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            function invariant(condition, format, a, b, c, d, e, f) {
                if (validateFormat(format), !condition) {
                    var error;
                    if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
                        var args = [ a, b, c, d, e, f ], argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        })), error.name = "Invariant Violation";
                    }
                    // we don't care about invariant's own frame
                    throw error.framesToPop = 1, error;
                }
            }
            /**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
            var validateFormat = function(format) {};
            "production" !== process.env.NODE_ENV && (validateFormat = function(format) {
                if (void 0 === format) throw new Error("invariant requires an error message argument");
            }), module.exports = invariant;
        }).call(exports, __webpack_require__(110));
    }, /* 129 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
            "use strict";
            var emptyFunction = __webpack_require__(130), warning = emptyFunction;
            if ("production" !== process.env.NODE_ENV) {
                var printWarning = function(format) {
                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                    var argIndex = 0, message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    "undefined" != typeof console && console.error(message);
                    try {
                        // --- Welcome to debugging React ---
                        // This error was thrown as a convenience so that you can use this stack
                        // to find the callsite that caused this warning to fire.
                        throw new Error(message);
                    } catch (x) {}
                };
                warning = function(condition, format) {
                    if (void 0 === format) throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
                    if (0 !== format.indexOf("Failed Composite propType: ") && !condition) {
                        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) args[_key2 - 2] = arguments[_key2];
                        printWarning.apply(void 0, [ format ].concat(args));
                    }
                };
            }
            module.exports = warning;
        }).call(exports, __webpack_require__(110));
    }, /* 130 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
        function makeEmptyFunction(arg) {
            return function() {
                return arg;
            };
        }
        /**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
        var emptyFunction = function() {};
        emptyFunction.thatReturns = makeEmptyFunction, emptyFunction.thatReturnsFalse = makeEmptyFunction(!1), 
        emptyFunction.thatReturnsTrue = makeEmptyFunction(!0), emptyFunction.thatReturnsNull = makeEmptyFunction(null), 
        emptyFunction.thatReturnsThis = function() {
            return this;
        }, emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
        }, module.exports = emptyFunction;
    }, /* 131 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: https://codemirror.net/LICENSE
        // This is CodeMirror (https://codemirror.net), a code editor
        // implemented in JavaScript on top of the browser's DOM.
        //
        // You can find some technical background for some of the code below
        // at http://marijnhaverbeke.nl/blog/#cm-internals .
        !function(global, factory) {
            module.exports = factory();
        }(this, function() {
            "use strict";
            function classTest(cls) {
                return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
            }
            function removeChildren(e) {
                for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
                return e;
            }
            function removeChildrenAndAdd(parent, e) {
                return removeChildren(parent).appendChild(e);
            }
            function elt(tag, content, className, style) {
                var e = document.createElement(tag);
                if (className && (e.className = className), style && (e.style.cssText = style), 
                "string" == typeof content) e.appendChild(document.createTextNode(content)); else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
                return e;
            }
            // wrapper for elt, which removes the elt from the accessibility tree
            function eltP(tag, content, className, style) {
                var e = elt(tag, content, className, style);
                return e.setAttribute("role", "presentation"), e;
            }
            function contains(parent, child) {
                if (3 == child.nodeType && (child = child.parentNode), parent.contains) return parent.contains(child);
                do if (11 == child.nodeType && (child = child.host), child == parent) return !0; while (child = child.parentNode);
            }
            function activeElt() {
                // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
                // IE < 10 will throw when accessed while the page is loading or in an iframe.
                // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
                var activeElement;
                try {
                    activeElement = document.activeElement;
                } catch (e) {
                    activeElement = document.body || null;
                }
                for (;activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement; ) activeElement = activeElement.shadowRoot.activeElement;
                return activeElement;
            }
            function addClass(node, cls) {
                var current = node.className;
                classTest(cls).test(current) || (node.className += (current ? " " : "") + cls);
            }
            function joinClasses(a, b) {
                for (var as = a.split(" "), i = 0; i < as.length; i++) as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
                return b;
            }
            function bind(f) {
                var args = Array.prototype.slice.call(arguments, 1);
                return function() {
                    return f.apply(null, args);
                };
            }
            function copyObj(obj, target, overwrite) {
                target || (target = {});
                for (var prop in obj) !obj.hasOwnProperty(prop) || overwrite === !1 && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
                return target;
            }
            // Counts the column offset in a string, taking tabs into account.
            // Used mostly to find indentation.
            function countColumn(string, end, tabSize, startIndex, startValue) {
                null == end && (end = string.search(/[^\s\u00a0]/), end == -1 && (end = string.length));
                for (var i = startIndex || 0, n = startValue || 0; ;) {
                    var nextTab = string.indexOf("\t", i);
                    if (nextTab < 0 || nextTab >= end) return n + (end - i);
                    n += nextTab - i, n += tabSize - n % tabSize, i = nextTab + 1;
                }
            }
            function indexOf(array, elt) {
                for (var i = 0; i < array.length; ++i) if (array[i] == elt) return i;
                return -1;
            }
            // The inverse of countColumn -- find the offset that corresponds to
            // a particular column.
            function findColumn(string, goal, tabSize) {
                for (var pos = 0, col = 0; ;) {
                    var nextTab = string.indexOf("\t", pos);
                    nextTab == -1 && (nextTab = string.length);
                    var skipped = nextTab - pos;
                    if (nextTab == string.length || col + skipped >= goal) return pos + Math.min(skipped, goal - col);
                    if (col += nextTab - pos, col += tabSize - col % tabSize, pos = nextTab + 1, col >= goal) return pos;
                }
            }
            function spaceStr(n) {
                for (;spaceStrs.length <= n; ) spaceStrs.push(lst(spaceStrs) + " ");
                return spaceStrs[n];
            }
            function lst(arr) {
                return arr[arr.length - 1];
            }
            function map(array, f) {
                for (var out = [], i = 0; i < array.length; i++) out[i] = f(array[i], i);
                return out;
            }
            function insertSorted(array, value, score) {
                for (var pos = 0, priority = score(value); pos < array.length && score(array[pos]) <= priority; ) pos++;
                array.splice(pos, 0, value);
            }
            function nothing() {}
            function createObj(base, props) {
                var inst;
                return Object.create ? inst = Object.create(base) : (nothing.prototype = base, inst = new nothing()), 
                props && copyObj(props, inst), inst;
            }
            function isWordCharBasic(ch) {
                return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
            }
            function isWordChar(ch, helper) {
                return helper ? !!(helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) || helper.test(ch) : isWordCharBasic(ch);
            }
            function isEmpty(obj) {
                for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return !1;
                return !0;
            }
            function isExtendingChar(ch) {
                return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
            }
            // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
            function skipExtendingChars(str, pos, dir) {
                for (;(dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos)); ) pos += dir;
                return pos;
            }
            // Returns the value from the range [`from`; `to`] that satisfies
            // `pred` and is closest to `from`. Assumes that at least `to`
            // satisfies `pred`. Supports `from` being greater than `to`.
            function findFirst(pred, from, to) {
                for (// At any point we are certain `to` satisfies `pred`, don't know
                // whether `from` does.
                var dir = from > to ? -1 : 1; ;) {
                    if (from == to) return from;
                    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
                    if (mid == from) return pred(mid) ? from : to;
                    pred(mid) ? to = mid : from = mid + dir;
                }
            }
            // BIDI HELPERS
            function iterateBidiSections(order, from, to, f) {
                if (!order) return f(from, to, "ltr", 0);
                for (var found = !1, i = 0; i < order.length; ++i) {
                    var part = order[i];
                    (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr", i), 
                    found = !0);
                }
                found || f(from, to, "ltr");
            }
            function getBidiPartAt(order, ch, sticky) {
                var found;
                bidiOther = null;
                for (var i = 0; i < order.length; ++i) {
                    var cur = order[i];
                    if (cur.from < ch && cur.to > ch) return i;
                    cur.to == ch && (cur.from != cur.to && "before" == sticky ? found = i : bidiOther = i), 
                    cur.from == ch && (cur.from != cur.to && "before" != sticky ? found = i : bidiOther = i);
                }
                return null != found ? found : bidiOther;
            }
            // Get the bidi ordering for the given line (and cache it). Returns
            // false for lines that are fully left-to-right, and an array of
            // BidiSpan objects otherwise.
            function getOrder(line, direction) {
                var order = line.order;
                return null == order && (order = line.order = bidiOrdering(line.text, direction)), 
                order;
            }
            function getHandlers(emitter, type) {
                return emitter._handlers && emitter._handlers[type] || noHandlers;
            }
            function off(emitter, type, f) {
                if (emitter.removeEventListener) emitter.removeEventListener(type, f, !1); else if (emitter.detachEvent) emitter.detachEvent("on" + type, f); else {
                    var map = emitter._handlers, arr = map && map[type];
                    if (arr) {
                        var index = indexOf(arr, f);
                        index > -1 && (map[type] = arr.slice(0, index).concat(arr.slice(index + 1)));
                    }
                }
            }
            function signal(emitter, type) {
                var handlers = getHandlers(emitter, type);
                if (handlers.length) for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
            }
            // The DOM events that CodeMirror handles can be overridden by
            // registering a (non-DOM) handler on the editor for the event name,
            // and preventDefault-ing the event in that handler.
            function signalDOMEvent(cm, e, override) {
                return "string" == typeof e && (e = {
                    type: e,
                    preventDefault: function() {
                        this.defaultPrevented = !0;
                    }
                }), signal(cm, override || e.type, cm, e), e_defaultPrevented(e) || e.codemirrorIgnore;
            }
            function signalCursorActivity(cm) {
                var arr = cm._handlers && cm._handlers.cursorActivity;
                if (arr) for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i) indexOf(set, arr[i]) == -1 && set.push(arr[i]);
            }
            function hasHandler(emitter, type) {
                return getHandlers(emitter, type).length > 0;
            }
            // Add on and off methods to a constructor's prototype, to make
            // registering events on such objects more convenient.
            function eventMixin(ctor) {
                ctor.prototype.on = function(type, f) {
                    on(this, type, f);
                }, ctor.prototype.off = function(type, f) {
                    off(this, type, f);
                };
            }
            // Due to the fact that we still support jurassic IE versions, some
            // compatibility wrappers are needed.
            function e_preventDefault(e) {
                e.preventDefault ? e.preventDefault() : e.returnValue = !1;
            }
            function e_stopPropagation(e) {
                e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
            }
            function e_defaultPrevented(e) {
                return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue;
            }
            function e_stop(e) {
                e_preventDefault(e), e_stopPropagation(e);
            }
            function e_target(e) {
                return e.target || e.srcElement;
            }
            function e_button(e) {
                var b = e.which;
                return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)), 
                mac && e.ctrlKey && 1 == b && (b = 3), b;
            }
            function zeroWidthElement(measure) {
                if (null == zwspSupported) {
                    var test = elt("span", "​");
                    removeChildrenAndAdd(measure, elt("span", [ test, document.createTextNode("x") ])), 
                    0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8));
                }
                var node = zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
                return node.setAttribute("cm-text", ""), node;
            }
            function hasBadBidiRects(measure) {
                if (null != badBidiRects) return badBidiRects;
                var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA")), r0 = range(txt, 0, 1).getBoundingClientRect(), r1 = range(txt, 1, 2).getBoundingClientRect();
                return removeChildren(measure), !(!r0 || r0.left == r0.right) && (badBidiRects = r1.right - r0.right < 3);
            }
            function hasBadZoomedRects(measure) {
                if (null != badZoomedRects) return badZoomedRects;
                var node = removeChildrenAndAdd(measure, elt("span", "x")), normal = node.getBoundingClientRect(), fromRange = range(node, 0, 1).getBoundingClientRect();
                return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
            }
            // Extra arguments are stored as the mode's dependencies, which is
            // used by (legacy) mechanisms like loadmode.js to automatically
            // load a mode. (Preferred mechanism is the require/define calls.)
            function defineMode(name, mode) {
                arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2)), 
                modes[name] = mode;
            }
            function defineMIME(mime, spec) {
                mimeModes[mime] = spec;
            }
            // Given a MIME type, a {name, ...options} config object, or a name
            // string, return a mode config object.
            function resolveMode(spec) {
                if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec]; else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
                    var found = mimeModes[spec.name];
                    "string" == typeof found && (found = {
                        name: found
                    }), spec = createObj(found, spec), spec.name = found.name;
                } else {
                    if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return resolveMode("application/xml");
                    if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) return resolveMode("application/json");
                }
                return "string" == typeof spec ? {
                    name: spec
                } : spec || {
                    name: "null"
                };
            }
            // Given a mode spec (anything that resolveMode accepts), find and
            // initialize an actual mode object.
            function getMode(options, spec) {
                spec = resolveMode(spec);
                var mfactory = modes[spec.name];
                if (!mfactory) return getMode(options, "text/plain");
                var modeObj = mfactory(options, spec);
                if (modeExtensions.hasOwnProperty(spec.name)) {
                    var exts = modeExtensions[spec.name];
                    for (var prop in exts) exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]), 
                    modeObj[prop] = exts[prop]);
                }
                if (modeObj.name = spec.name, spec.helperType && (modeObj.helperType = spec.helperType), 
                spec.modeProps) for (var prop$1 in spec.modeProps) modeObj[prop$1] = spec.modeProps[prop$1];
                return modeObj;
            }
            function extendMode(mode, properties) {
                var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
                copyObj(properties, exts);
            }
            function copyState(mode, state) {
                if (state === !0) return state;
                if (mode.copyState) return mode.copyState(state);
                var nstate = {};
                for (var n in state) {
                    var val = state[n];
                    val instanceof Array && (val = val.concat([])), nstate[n] = val;
                }
                return nstate;
            }
            // Given a mode and a state (for that mode), find the inner mode and
            // state at the position that the state refers to.
            function innerMode(mode, state) {
                for (var info; mode.innerMode && (info = mode.innerMode(state), info && info.mode != mode); ) state = info.state, 
                mode = info.mode;
                return info || {
                    mode: mode,
                    state: state
                };
            }
            function startState(mode, a1, a2) {
                return !mode.startState || mode.startState(a1, a2);
            }
            // Find the line object corresponding to the given line number.
            function getLine(doc, n) {
                if (n -= doc.first, n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
                for (var chunk = doc; !chunk.lines; ) for (var i = 0; ;++i) {
                    var child = chunk.children[i], sz = child.chunkSize();
                    if (n < sz) {
                        chunk = child;
                        break;
                    }
                    n -= sz;
                }
                return chunk.lines[n];
            }
            // Get the part of a document between two positions, as an array of
            // strings.
            function getBetween(doc, start, end) {
                var out = [], n = start.line;
                return doc.iter(start.line, end.line + 1, function(line) {
                    var text = line.text;
                    n == end.line && (text = text.slice(0, end.ch)), n == start.line && (text = text.slice(start.ch)), 
                    out.push(text), ++n;
                }), out;
            }
            // Get the lines between from and to, as array of strings.
            function getLines(doc, from, to) {
                var out = [];
                // iter aborts when callback returns truthy value
                return doc.iter(from, to, function(line) {
                    out.push(line.text);
                }), out;
            }
            // Update the height of a line, propagating the height change
            // upwards to parent nodes.
            function updateLineHeight(line, height) {
                var diff = height - line.height;
                if (diff) for (var n = line; n; n = n.parent) n.height += diff;
            }
            // Given a line object, find its line number by walking up through
            // its parent links.
            function lineNo(line) {
                if (null == line.parent) return null;
                for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk, 
                chunk = chunk.parent) for (var i = 0; chunk.children[i] != cur; ++i) no += chunk.children[i].chunkSize();
                return no + cur.first;
            }
            // Find the line at the given vertical position, using the height
            // information in the document tree.
            function lineAtHeight(chunk, h) {
                var n = chunk.first;
                outer: do {
                    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
                        var child = chunk.children[i$1], ch = child.height;
                        if (h < ch) {
                            chunk = child;
                            continue outer;
                        }
                        h -= ch, n += child.chunkSize();
                    }
                    return n;
                } while (!chunk.lines);
                for (var i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i], lh = line.height;
                    if (h < lh) break;
                    h -= lh;
                }
                return n + i;
            }
            function isLine(doc, l) {
                return l >= doc.first && l < doc.first + doc.size;
            }
            function lineNumberFor(options, i) {
                return String(options.lineNumberFormatter(i + options.firstLineNumber));
            }
            // A Pos instance represents a position within the text.
            function Pos(line, ch, sticky) {
                return void 0 === sticky && (sticky = null), this instanceof Pos ? (this.line = line, 
                this.ch = ch, void (this.sticky = sticky)) : new Pos(line, ch, sticky);
            }
            // Compare two positions, return 0 if they are the same, a negative
            // number when a is less, and a positive number otherwise.
            function cmp(a, b) {
                return a.line - b.line || a.ch - b.ch;
            }
            function equalCursorPos(a, b) {
                return a.sticky == b.sticky && 0 == cmp(a, b);
            }
            function copyPos(x) {
                return Pos(x.line, x.ch);
            }
            function maxPos(a, b) {
                return cmp(a, b) < 0 ? b : a;
            }
            function minPos(a, b) {
                return cmp(a, b) < 0 ? a : b;
            }
            // Most of the external API clips given positions to make sure they
            // actually exist within the document.
            function clipLine(doc, n) {
                return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
            }
            function clipPos(doc, pos) {
                if (pos.line < doc.first) return Pos(doc.first, 0);
                var last = doc.first + doc.size - 1;
                return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length);
            }
            function clipToLen(pos, linelen) {
                var ch = pos.ch;
                return null == ch || ch > linelen ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos;
            }
            function clipPosArray(doc, array) {
                for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
                return out;
            }
            // Compute a style array (an array starting with a mode generation
            // -- for invalidation -- followed by pairs of end positions and
            // style strings), which is used to highlight the tokens on the
            // line.
            function highlightLine(cm, line, context, forceToEnd) {
                // A styles array always starts with a number identifying the
                // mode/overlays that it is based on (for easy invalidation).
                var st = [ cm.state.modeGen ], lineClasses = {};
                // Compute the base array of styles
                runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
                    return st.push(end, style);
                }, lineClasses, forceToEnd);
                for (var state = context.state, loop = function(o) {
                    context.baseTokens = st;
                    var overlay = cm.state.overlays[o], i = 1, at = 0;
                    context.state = !0, runMode(cm, line.text, overlay.mode, context, function(end, style) {
                        // Ensure there's a token end at the current position, and that i points at it
                        for (var start = i; at < end; ) {
                            var i_end = st[i];
                            i_end > end && st.splice(i, 1, end, st[i + 1], i_end), i += 2, at = Math.min(end, i_end);
                        }
                        if (style) if (overlay.opaque) st.splice(start, i - start, end, "overlay " + style), 
                        i = start + 2; else for (;start < i; start += 2) {
                            var cur = st[start + 1];
                            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
                        }
                    }, lineClasses), context.state = state, context.baseTokens = null, context.baseTokenPos = 1;
                }, o = 0; o < cm.state.overlays.length; ++o) loop(o);
                return {
                    styles: st,
                    classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
                };
            }
            function getLineStyles(cm, line, updateFrontier) {
                if (!line.styles || line.styles[0] != cm.state.modeGen) {
                    var context = getContextBefore(cm, lineNo(line)), resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state), result = highlightLine(cm, line, context);
                    resetState && (context.state = resetState), line.stateAfter = context.save(!resetState), 
                    line.styles = result.styles, result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null), 
                    updateFrontier === cm.doc.highlightFrontier && (cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier));
                }
                return line.styles;
            }
            function getContextBefore(cm, n, precise) {
                var doc = cm.doc, display = cm.display;
                if (!doc.mode.startState) return new Context(doc, !0, n);
                var start = findStartLine(cm, n, precise), saved = start > doc.first && getLine(doc, start - 1).stateAfter, context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
                return doc.iter(start, n, function(line) {
                    processLine(cm, line.text, context);
                    var pos = context.line;
                    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null, 
                    context.nextLine();
                }), precise && (doc.modeFrontier = context.line), context;
            }
            // Lightweight form of highlight -- proceed over this line and
            // update state, but don't save a style array. Used for lines that
            // aren't currently visible.
            function processLine(cm, text, context, startAt) {
                var mode = cm.doc.mode, stream = new StringStream(text, cm.options.tabSize, context);
                for (stream.start = stream.pos = startAt || 0, "" == text && callBlankLine(mode, context.state); !stream.eol(); ) readToken(mode, stream, context.state), 
                stream.start = stream.pos;
            }
            function callBlankLine(mode, state) {
                if (mode.blankLine) return mode.blankLine(state);
                if (mode.innerMode) {
                    var inner = innerMode(mode, state);
                    return inner.mode.blankLine ? inner.mode.blankLine(inner.state) : void 0;
                }
            }
            function readToken(mode, stream, state, inner) {
                for (var i = 0; i < 10; i++) {
                    inner && (inner[0] = innerMode(mode, state).mode);
                    var style = mode.token(stream, state);
                    if (stream.pos > stream.start) return style;
                }
                throw new Error("Mode " + mode.name + " failed to advance stream.");
            }
            // Utility for getTokenAt and getLineTokens
            function takeToken(cm, pos, precise, asArray) {
                var style, doc = cm.doc, mode = doc.mode;
                pos = clipPos(doc, pos);
                var tokens, line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise), stream = new StringStream(line.text, cm.options.tabSize, context);
                for (asArray && (tokens = []); (asArray || stream.pos < pos.ch) && !stream.eol(); ) stream.start = stream.pos, 
                style = readToken(mode, stream, context.state), asArray && tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
                return asArray ? tokens : new Token(stream, style, context.state);
            }
            function extractLineClasses(type, output) {
                if (type) for (;;) {
                    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                    if (!lineClass) break;
                    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                    var prop = lineClass[1] ? "bgClass" : "textClass";
                    null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop]) || (output[prop] += " " + lineClass[2]);
                }
                return type;
            }
            // Run the given mode's parser over a line, calling f for each token.
            function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
                var flattenSpans = mode.flattenSpans;
                null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
                var style, curStart = 0, curStyle = null, stream = new StringStream(text, cm.options.tabSize, context), inner = cm.options.addModeClass && [ null ];
                for ("" == text && extractLineClasses(callBlankLine(mode, context.state), lineClasses); !stream.eol(); ) {
                    if (stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, forceToEnd && processLine(cm, text, context, stream.pos), 
                    stream.pos = text.length, style = null) : style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses), 
                    inner) {
                        var mName = inner[0].name;
                        mName && (style = "m-" + (style ? mName + " " + style : mName));
                    }
                    if (!flattenSpans || curStyle != style) {
                        for (;curStart < stream.start; ) curStart = Math.min(stream.start, curStart + 5e3), 
                        f(curStart, curStyle);
                        curStyle = style;
                    }
                    stream.start = stream.pos;
                }
                for (;curStart < stream.pos; ) {
                    // Webkit seems to refuse to render text nodes longer than 57444
                    // characters, and returns inaccurate measurements in nodes
                    // starting around 5000 chars.
                    var pos = Math.min(stream.pos, curStart + 5e3);
                    f(pos, curStyle), curStart = pos;
                }
            }
            // Finds the line to start with when starting a parse. Tries to
            // find a line with a stateAfter, so that it can start with a
            // valid state. If that fails, it returns the line with the
            // smallest indentation, which tends to need the least context to
            // parse correctly.
            function findStartLine(cm, n, precise) {
                for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
                    if (search <= doc.first) return doc.first;
                    var line = getLine(doc, search - 1), after = line.stateAfter;
                    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) return search;
                    var indented = countColumn(line.text, null, cm.options.tabSize);
                    (null == minline || minindent > indented) && (minline = search - 1, minindent = indented);
                }
                return minline;
            }
            function retreatFrontier(doc, n) {
                if (doc.modeFrontier = Math.min(doc.modeFrontier, n), !(doc.highlightFrontier < n - 10)) {
                    for (var start = doc.first, line = n - 1; line > start; line--) {
                        var saved = getLine(doc, line).stateAfter;
                        // change is on 3
                        // state on line 1 looked ahead 2 -- so saw 3
                        // test 1 + 2 < 3 should cover this
                        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
                            start = line + 1;
                            break;
                        }
                    }
                    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
                }
            }
            function seeReadOnlySpans() {
                sawReadOnlySpans = !0;
            }
            function seeCollapsedSpans() {
                sawCollapsedSpans = !0;
            }
            // TEXTMARKER SPANS
            function MarkedSpan(marker, from, to) {
                this.marker = marker, this.from = from, this.to = to;
            }
            // Search an array of spans for a span matching the given marker.
            function getMarkedSpanFor(spans, marker) {
                if (spans) for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker) return span;
                }
            }
            // Remove a span from an array, returning undefined if no spans are
            // left (we don't store arrays for lines without spans).
            function removeMarkedSpan(spans, span) {
                for (var r, i = 0; i < spans.length; ++i) spans[i] != span && (r || (r = [])).push(spans[i]);
                return r;
            }
            // Add a span to a line.
            function addMarkedSpan(line, span) {
                line.markedSpans = line.markedSpans ? line.markedSpans.concat([ span ]) : [ span ], 
                span.marker.attachLine(line);
            }
            // Used for the algorithm that adjusts markers for a change in the
            // document. These functions cut an array of spans at a given
            // character position, returning an array of remaining chunks (or
            // undefined if nothing remains).
            function markedSpansBefore(old, startCh, isInsert) {
                var nw;
                if (old) for (var i = 0; i < old.length; ++i) {
                    var span = old[i], marker = span.marker, startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                    }
                }
                return nw;
            }
            function markedSpansAfter(old, endCh, isInsert) {
                var nw;
                if (old) for (var i = 0; i < old.length; ++i) {
                    var span = old[i], marker = span.marker, endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh));
                    }
                }
                return nw;
            }
            // Given a change object, compute the new set of marker spans that
            // cover the line in which the change took place. Removes spans
            // entirely within the change, reconnects spans belonging to the
            // same marker that appear on both sides of the change, and cuts off
            // spans partially within the change. Returns an array of span
            // arrays with one element for each line in (after) the change.
            function stretchSpansOverChange(doc, change) {
                if (change.full) return null;
                var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans, oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
                if (!oldFirst && !oldLast) return null;
                var startCh = change.from.ch, endCh = change.to.ch, isInsert = 0 == cmp(change.from, change.to), first = markedSpansBefore(oldFirst, startCh, isInsert), last = markedSpansAfter(oldLast, endCh, isInsert), sameLine = 1 == change.text.length, offset = lst(change.text).length + (sameLine ? startCh : 0);
                if (first) // Fix up .to properties of first
                for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (null == span.to) {
                        var found = getMarkedSpanFor(last, span.marker);
                        found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh;
                    }
                }
                if (last) // Fix up .from in last (or move them into first in case of sameLine)
                for (var i$1 = 0; i$1 < last.length; ++i$1) {
                    var span$1 = last[i$1];
                    if (null != span$1.to && (span$1.to += offset), null == span$1.from) {
                        var found$1 = getMarkedSpanFor(first, span$1.marker);
                        found$1 || (span$1.from = offset, sameLine && (first || (first = [])).push(span$1));
                    } else span$1.from += offset, sameLine && (first || (first = [])).push(span$1);
                }
                // Make sure we didn't create any zero-length spans
                first && (first = clearEmptySpans(first)), last && last != first && (last = clearEmptySpans(last));
                var newMarkers = [ first ];
                if (!sameLine) {
                    // Fill gap with whole-line-spans
                    var gapMarkers, gap = change.text.length - 2;
                    if (gap > 0 && first) for (var i$2 = 0; i$2 < first.length; ++i$2) null == first[i$2].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
                    for (var i$3 = 0; i$3 < gap; ++i$3) newMarkers.push(gapMarkers);
                    newMarkers.push(last);
                }
                return newMarkers;
            }
            // Remove spans that are empty and don't have a clearWhenEmpty
            // option of false.
            function clearEmptySpans(spans) {
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    null != span.from && span.from == span.to && span.marker.clearWhenEmpty !== !1 && spans.splice(i--, 1);
                }
                return spans.length ? spans : null;
            }
            // Used to 'clip' out readOnly ranges when making a change.
            function removeReadOnlyRanges(doc, from, to) {
                var markers = null;
                if (doc.iter(from.line, to.line + 1, function(line) {
                    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                        var mark = line.markedSpans[i].marker;
                        !mark.readOnly || markers && indexOf(markers, mark) != -1 || (markers || (markers = [])).push(mark);
                    }
                }), !markers) return null;
                for (var parts = [ {
                    from: from,
                    to: to
                } ], i = 0; i < markers.length; ++i) for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
                    var p = parts[j];
                    if (!(cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)) {
                        var newParts = [ j, 1 ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                        (dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push({
                            from: p.from,
                            to: m.from
                        }), (dto > 0 || !mk.inclusiveRight && !dto) && newParts.push({
                            from: m.to,
                            to: p.to
                        }), parts.splice.apply(parts, newParts), j += newParts.length - 3;
                    }
                }
                return parts;
            }
            // Connect or disconnect spans from a line.
            function detachMarkedSpans(line) {
                var spans = line.markedSpans;
                if (spans) {
                    for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
                    line.markedSpans = null;
                }
            }
            function attachMarkedSpans(line, spans) {
                if (spans) {
                    for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
                    line.markedSpans = spans;
                }
            }
            // Helpers used when computing which overlapping collapsed span
            // counts as the larger one.
            function extraLeft(marker) {
                return marker.inclusiveLeft ? -1 : 0;
            }
            function extraRight(marker) {
                return marker.inclusiveRight ? 1 : 0;
            }
            // Returns a number indicating which of two overlapping collapsed
            // spans is larger (and thus includes the other). Falls back to
            // comparing ids when the spans cover exactly the same range.
            function compareCollapsedMarkers(a, b) {
                var lenDiff = a.lines.length - b.lines.length;
                if (0 != lenDiff) return lenDiff;
                var aPos = a.find(), bPos = b.find(), fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
                if (fromCmp) return -fromCmp;
                var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
                return toCmp ? toCmp : b.id - a.id;
            }
            // Find out whether a line ends or starts in a collapsed span. If
            // so, return the marker for that span.
            function collapsedSpanAtSide(line, start) {
                var found, sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) sp = sps[i], sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
                return found;
            }
            function collapsedSpanAtStart(line) {
                return collapsedSpanAtSide(line, !0);
            }
            function collapsedSpanAtEnd(line) {
                return collapsedSpanAtSide(line, !1);
            }
            function collapsedSpanAround(line, ch) {
                var found, sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var i = 0; i < sps.length; ++i) {
                    var sp = sps[i];
                    sp.marker.collapsed && (null == sp.from || sp.from < ch) && (null == sp.to || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
                }
                return found;
            }
            // Test whether there exists a collapsed span that partially
            // overlaps (covers the start or end, but not both) of a new span.
            // Such overlap is not allowed.
            function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
                var line = getLine(doc, lineNo), sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var i = 0; i < sps.length; ++i) {
                    var sp = sps[i];
                    if (sp.marker.collapsed) {
                        var found = sp.marker.find(0), fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker), toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                        if (!(fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) && (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))) return !0;
                    }
                }
            }
            // A visual line is a line as drawn on the screen. Folding, for
            // example, can cause multiple logical lines to appear on the same
            // visual line. This finds the start of the visual line that the
            // given line is part of (usually that is the line itself).
            function visualLine(line) {
                for (var merged; merged = collapsedSpanAtStart(line); ) line = merged.find(-1, !0).line;
                return line;
            }
            function visualLineEnd(line) {
                for (var merged; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
                return line;
            }
            // Returns an array of logical lines that continue the visual line
            // started by the argument, or undefined if there are no such lines.
            function visualLineContinued(line) {
                for (var merged, lines; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line, 
                (lines || (lines = [])).push(line);
                return lines;
            }
            // Get the line number of the start of the visual line that the
            // given line number is part of.
            function visualLineNo(doc, lineN) {
                var line = getLine(doc, lineN), vis = visualLine(line);
                return line == vis ? lineN : lineNo(vis);
            }
            // Get the line number of the start of the next visual line after
            // the given line.
            function visualLineEndNo(doc, lineN) {
                if (lineN > doc.lastLine()) return lineN;
                var merged, line = getLine(doc, lineN);
                if (!lineIsHidden(doc, line)) return lineN;
                for (;merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
                return lineNo(line) + 1;
            }
            // Compute whether a line is hidden. Lines count as hidden when they
            // are part of a visual line that starts with another line, or when
            // they are entirely covered by collapsed, non-widget span.
            function lineIsHidden(doc, line) {
                var sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) if (sp = sps[i], sp.marker.collapsed) {
                    if (null == sp.from) return !0;
                    if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return !0;
                }
            }
            function lineIsHiddenInner(doc, line, span) {
                if (null == span.to) {
                    var end = span.marker.find(1, !0);
                    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
                }
                if (span.marker.inclusiveRight && span.to == line.text.length) return !0;
                for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) if (sp = line.markedSpans[i], 
                sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return !0;
            }
            // Find the height above the given line.
            function heightAtLine(lineObj) {
                lineObj = visualLine(lineObj);
                for (var h = 0, chunk = lineObj.parent, i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i];
                    if (line == lineObj) break;
                    h += line.height;
                }
                for (var p = chunk.parent; p; chunk = p, p = chunk.parent) for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
                    var cur = p.children[i$1];
                    if (cur == chunk) break;
                    h += cur.height;
                }
                return h;
            }
            // Compute the character length of a line, taking into account
            // collapsed ranges (see markText) that might hide parts, and join
            // other lines onto it.
            function lineLength(line) {
                if (0 == line.height) return 0;
                for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur); ) {
                    var found = merged.find(0, !0);
                    cur = found.from.line, len += found.from.ch - found.to.ch;
                }
                for (cur = line; merged = collapsedSpanAtEnd(cur); ) {
                    var found$1 = merged.find(0, !0);
                    len -= cur.text.length - found$1.from.ch, cur = found$1.to.line, len += cur.text.length - found$1.to.ch;
                }
                return len;
            }
            // Find the longest line in the document.
            function findMaxLine(cm) {
                var d = cm.display, doc = cm.doc;
                d.maxLine = getLine(doc, doc.first), d.maxLineLength = lineLength(d.maxLine), d.maxLineChanged = !0, 
                doc.iter(function(line) {
                    var len = lineLength(line);
                    len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line);
                });
            }
            // Change the content (text, markers) of a line. Automatically
            // invalidates cached information and tries to re-estimate the
            // line's height.
            function updateLine(line, text, markedSpans, estimateHeight) {
                line.text = text, line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null), 
                null != line.order && (line.order = null), detachMarkedSpans(line), attachMarkedSpans(line, markedSpans);
                var estHeight = estimateHeight ? estimateHeight(line) : 1;
                estHeight != line.height && updateLineHeight(line, estHeight);
            }
            // Detach a line from the document tree and its markers.
            function cleanUpLine(line) {
                line.parent = null, detachMarkedSpans(line);
            }
            function interpretTokenStyle(style, options) {
                if (!style || /^\s*$/.test(style)) return null;
                var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
                return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
            }
            // Render the DOM representation of the text of a line. Also builds
            // up a 'line map', which points at the DOM nodes that represent
            // specific stretches of text, and is used by the measuring code.
            // The returned object contains the DOM node, this map, and
            // information about line-wide styles that were set by the mode.
            function buildLineContent(cm, lineView) {
                // The padding-right forces the element to have a 'border', which
                // is needed on Webkit to be able to get line-level bounding
                // rectangles for it (in measureChar).
                var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null), builder = {
                    pre: eltP("pre", [ content ], "CodeMirror-line"),
                    content: content,
                    col: 0,
                    pos: 0,
                    cm: cm,
                    trailingSpace: !1,
                    splitSpaces: cm.getOption("lineWrapping")
                };
                lineView.measure = {};
                // Iterate over the logical lines that make up this visual line.
                for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
                    var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0;
                    builder.pos = 0, builder.addToken = buildToken, // Optionally wire in some hacks into the token-rendering
                    // algorithm, to deal with browser quirks.
                    hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order)), 
                    builder.map = [];
                    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
                    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate)), 
                    line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")), 
                    line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))), 
                    // Ensure at least a single node is present, for measuring.
                    0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))), 
                    // Store the map and a cache object for the current logical line
                    0 == i ? (lineView.measure.map = builder.map, lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map), 
                    (lineView.measure.caches || (lineView.measure.caches = [])).push({}));
                }
                // See issue #2901
                if (webkit) {
                    var last = builder.content.lastChild;
                    (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) && (builder.content.className = "cm-tab-wrap-hack");
                }
                return signal(cm, "renderLine", cm, lineView.line, builder.pre), builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")), 
                builder;
            }
            function defaultSpecialCharPlaceholder(ch) {
                var token = elt("span", "•", "cm-invalidchar");
                return token.title = "\\u" + ch.charCodeAt(0).toString(16), token.setAttribute("aria-label", token.title), 
                token;
            }
            // Build up the DOM representation for a single token, and add it to
            // the line map. Takes care to render special characters separately.
            function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
                if (text) {
                    var content, displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text, special = builder.cm.state.specialChars, mustWrap = !1;
                    if (special.test(text)) {
                        content = document.createDocumentFragment();
                        for (var pos = 0; ;) {
                            special.lastIndex = pos;
                            var m = special.exec(text), skipped = m ? m.index - pos : text.length - pos;
                            if (skipped) {
                                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                                ie && ie_version < 9 ? content.appendChild(elt("span", [ txt ])) : content.appendChild(txt), 
                                builder.map.push(builder.pos, builder.pos + skipped, txt), builder.col += skipped, 
                                builder.pos += skipped;
                            }
                            if (!m) break;
                            pos += skipped + 1;
                            var txt$1 = void 0;
                            if ("\t" == m[0]) {
                                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab")), txt$1.setAttribute("role", "presentation"), 
                                txt$1.setAttribute("cm-text", "\t"), builder.col += tabWidth;
                            } else "\r" == m[0] || "\n" == m[0] ? (txt$1 = content.appendChild(elt("span", "\r" == m[0] ? "␍" : "␤", "cm-invalidchar")), 
                            txt$1.setAttribute("cm-text", m[0]), builder.col += 1) : (txt$1 = builder.cm.options.specialCharPlaceholder(m[0]), 
                            txt$1.setAttribute("cm-text", m[0]), ie && ie_version < 9 ? content.appendChild(elt("span", [ txt$1 ])) : content.appendChild(txt$1), 
                            builder.col += 1);
                            builder.map.push(builder.pos, builder.pos + 1, txt$1), builder.pos++;
                        }
                    } else builder.col += text.length, content = document.createTextNode(displayText), 
                    builder.map.push(builder.pos, builder.pos + text.length, content), ie && ie_version < 9 && (mustWrap = !0), 
                    builder.pos += text.length;
                    if (builder.trailingSpace = 32 == displayText.charCodeAt(text.length - 1), style || startStyle || endStyle || mustWrap || css || attributes) {
                        var fullStyle = style || "";
                        startStyle && (fullStyle += startStyle), endStyle && (fullStyle += endStyle);
                        var token = elt("span", [ content ], fullStyle, css);
                        if (attributes) for (var attr in attributes) attributes.hasOwnProperty(attr) && "style" != attr && "class" != attr && token.setAttribute(attr, attributes[attr]);
                        return builder.content.appendChild(token);
                    }
                    builder.content.appendChild(content);
                }
            }
            // Change some spaces to NBSP to prevent the browser from collapsing
            // trailing spaces at the end of a line when rendering text (issue #1362).
            function splitSpaces(text, trailingBefore) {
                if (text.length > 1 && !/  /.test(text)) return text;
                for (var spaceBefore = trailingBefore, result = "", i = 0; i < text.length; i++) {
                    var ch = text.charAt(i);
                    " " != ch || !spaceBefore || i != text.length - 1 && 32 != text.charCodeAt(i + 1) || (ch = " "), 
                    result += ch, spaceBefore = " " == ch;
                }
                return result;
            }
            // Work around nonsense dimensions being reported for stretches of
            // right-to-left text.
            function buildTokenBadBidi(inner, order) {
                return function(builder, text, style, startStyle, endStyle, css, attributes) {
                    style = style ? style + " cm-force-border" : "cm-force-border";
                    for (var start = builder.pos, end = start + text.length; ;) {
                        for (var part = void 0, i = 0; i < order.length && (part = order[i], !(part.to > start && part.from <= start)); i++) ;
                        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, css, attributes);
                        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes), 
                        startStyle = null, text = text.slice(part.to - start), start = part.to;
                    }
                };
            }
            function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
                var widget = !ignoreWidget && marker.widgetNode;
                widget && builder.map.push(builder.pos, builder.pos + size, widget), !ignoreWidget && builder.cm.display.input.needsContentAttribute && (widget || (widget = builder.content.appendChild(document.createElement("span"))), 
                widget.setAttribute("cm-marker", marker.id)), widget && (builder.cm.display.input.setUneditable(widget), 
                builder.content.appendChild(widget)), builder.pos += size, builder.trailingSpace = !1;
            }
            // Outputs a number of spans to make up a line, taking highlighting
            // and marked text into account.
            function insertLineContent(line, builder, styles) {
                var spans = line.markedSpans, allText = line.text, at = 0;
                if (spans) for (var style, css, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0; ;) {
                    if (nextChange == pos) {
                        // Update current marker set
                        spanStyle = spanEndStyle = spanStartStyle = css = "", attributes = null, collapsed = null, 
                        nextChange = 1 / 0;
                        for (var foundBookmarks = [], endStyles = void 0, j = 0; j < spans.length; ++j) {
                            var sp = spans[j], m = sp.marker;
                            if ("bookmark" == m.type && sp.from == pos && m.widgetNode) foundBookmarks.push(m); else if (sp.from <= pos && (null == sp.to || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                                if (null != sp.to && sp.to != pos && nextChange > sp.to && (nextChange = sp.to, 
                                spanEndStyle = ""), m.className && (spanStyle += " " + m.className), m.css && (css = (css ? css + ";" : "") + m.css), 
                                m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), m.endStyle && sp.to == nextChange && (endStyles || (endStyles = [])).push(m.endStyle, sp.to), 
                                // support for the old title property
                                // https://github.com/codemirror/CodeMirror/pull/5673
                                m.title && ((attributes || (attributes = {})).title = m.title), m.attributes) for (var attr in m.attributes) (attributes || (attributes = {}))[attr] = m.attributes[attr];
                                m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp);
                            } else sp.from > pos && nextChange > sp.from && (nextChange = sp.from);
                        }
                        if (endStyles) for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) endStyles[j$1 + 1] == nextChange && (spanEndStyle += " " + endStyles[j$1]);
                        if (!collapsed || collapsed.from == pos) for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                        if (collapsed && (collapsed.from || 0) == pos) {
                            if (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from), 
                            null == collapsed.to) return;
                            collapsed.to == pos && (collapsed = !1);
                        }
                    }
                    if (pos >= len) break;
                    for (var upto = Math.min(len, nextChange); ;) {
                        if (text) {
                            var end = pos + text.length;
                            if (!collapsed) {
                                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
                            }
                            if (end >= upto) {
                                text = text.slice(upto - pos), pos = upto;
                                break;
                            }
                            pos = end, spanStartStyle = "";
                        }
                        text = allText.slice(at, at = styles[i++]), style = interpretTokenStyle(styles[i++], builder.cm.options);
                    }
                } else for (var i$1 = 1; i$1 < styles.length; i$1 += 2) builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
            }
            // These objects are used to represent the visible (currently drawn)
            // part of the document. A LineView may correspond to multiple
            // logical lines, if those are connected by collapsed ranges.
            function LineView(doc, line, lineN) {
                // The starting line
                this.line = line, // Continuing lines, if any
                this.rest = visualLineContinued(line), // Number of logical lines in this visual line
                this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1, this.node = this.text = null, 
                this.hidden = lineIsHidden(doc, line);
            }
            // Create a range of LineView objects for the given lines.
            function buildViewArray(cm, from, to) {
                for (var nextPos, array = [], pos = from; pos < to; pos = nextPos) {
                    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
                    nextPos = pos + view.size, array.push(view);
                }
                return array;
            }
            function pushOperation(op) {
                operationGroup ? operationGroup.ops.push(op) : op.ownsGroup = operationGroup = {
                    ops: [ op ],
                    delayedCallbacks: []
                };
            }
            function fireCallbacksForOps(group) {
                // Calls delayed callbacks and cursorActivity handlers until no
                // new ones appear
                var callbacks = group.delayedCallbacks, i = 0;
                do {
                    for (;i < callbacks.length; i++) callbacks[i].call(null);
                    for (var j = 0; j < group.ops.length; j++) {
                        var op = group.ops[j];
                        if (op.cursorActivityHandlers) for (;op.cursorActivityCalled < op.cursorActivityHandlers.length; ) op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                    }
                } while (i < callbacks.length);
            }
            function finishOperation(op, endCb) {
                var group = op.ownsGroup;
                if (group) try {
                    fireCallbacksForOps(group);
                } finally {
                    operationGroup = null, endCb(group);
                }
            }
            // Often, we want to signal events at a point where we are in the
            // middle of some work, but don't want the handler to start calling
            // other methods on the editor, which might be in an inconsistent
            // state or simply not expect any other events to happen.
            // signalLater looks whether there are any handlers, and schedules
            // them to be executed when the last operation ends, or, if no
            // operation is active, when a timeout fires.
            function signalLater(emitter, type) {
                var arr = getHandlers(emitter, type);
                if (arr.length) {
                    var list, args = Array.prototype.slice.call(arguments, 2);
                    operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [], 
                    setTimeout(fireOrphanDelayed, 0));
                    for (var loop = function(i) {
                        list.push(function() {
                            return arr[i].apply(null, args);
                        });
                    }, i = 0; i < arr.length; ++i) loop(i);
                }
            }
            function fireOrphanDelayed() {
                var delayed = orphanDelayedCallbacks;
                orphanDelayedCallbacks = null;
                for (var i = 0; i < delayed.length; ++i) delayed[i]();
            }
            // When an aspect of a line changes, a string is added to
            // lineView.changes. This updates the relevant part of the line's
            // DOM structure.
            function updateLineForChanges(cm, lineView, lineN, dims) {
                for (var j = 0; j < lineView.changes.length; j++) {
                    var type = lineView.changes[j];
                    "text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(cm, lineView) : "widget" == type && updateLineWidgets(cm, lineView, dims);
                }
                lineView.changes = null;
            }
            // Lines with gutter elements, widgets or a background class need to
            // be wrapped, and have the extra elements added to the wrapper div
            function ensureLineWrapped(lineView) {
                return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"), 
                lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text), 
                lineView.node.appendChild(lineView.text), ie && ie_version < 8 && (lineView.node.style.zIndex = 2)), 
                lineView.node;
            }
            function updateLineBackground(cm, lineView) {
                var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
                if (cls && (cls += " CodeMirror-linebackground"), lineView.background) cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background), 
                lineView.background = null); else if (cls) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild), 
                    cm.display.input.setUneditable(lineView.background);
                }
            }
            // Wrapper around buildLineContent which will reuse the structure
            // in display.externalMeasured when possible.
            function getLineContent(cm, lineView) {
                var ext = cm.display.externalMeasured;
                return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null, lineView.measure = ext.measure, 
                ext.built) : buildLineContent(cm, lineView);
            }
            // Redraw the line's text. Interacts with the background and text
            // classes because the mode may output tokens that influence these
            // classes.
            function updateLineText(cm, lineView) {
                var cls = lineView.text.className, built = getLineContent(cm, lineView);
                lineView.text == lineView.node && (lineView.node = built.pre), lineView.text.parentNode.replaceChild(built.pre, lineView.text), 
                lineView.text = built.pre, built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass, 
                lineView.textClass = built.textClass, updateLineClasses(cm, lineView)) : cls && (lineView.text.className = cls);
            }
            function updateLineClasses(cm, lineView) {
                updateLineBackground(cm, lineView), lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
                var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
                lineView.text.className = textClass || "";
            }
            function updateLineGutter(cm, lineView, lineN, dims) {
                if (lineView.gutter && (lineView.node.removeChild(lineView.gutter), lineView.gutter = null), 
                lineView.gutterBackground && (lineView.node.removeChild(lineView.gutterBackground), 
                lineView.gutterBackground = null), lineView.line.gutterClass) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"), 
                    cm.display.input.setUneditable(lineView.gutterBackground), wrap.insertBefore(lineView.gutterBackground, lineView.text);
                }
                var markers = lineView.line.gutterMarkers;
                if (cm.options.lineNumbers || markers) {
                    var wrap$1 = ensureLineWrapped(lineView), gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
                    if (cm.display.input.setUneditable(gutterWrap), wrap$1.insertBefore(gutterWrap, lineView.text), 
                    lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass), 
                    !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))), 
                    markers) for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
                        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
                        found && gutterWrap.appendChild(elt("div", [ found ], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                    }
                }
            }
            function updateLineWidgets(cm, lineView, dims) {
                lineView.alignable && (lineView.alignable = null);
                for (var isWidget = classTest("CodeMirror-linewidget"), node = lineView.node.firstChild, next = void 0; node; node = next) next = node.nextSibling, 
                isWidget.test(node.className) && lineView.node.removeChild(node);
                insertLineWidgets(cm, lineView, dims);
            }
            // Build a line's DOM representation from scratch
            function buildLineElement(cm, lineView, lineN, dims) {
                var built = getLineContent(cm, lineView);
                return lineView.text = lineView.node = built.pre, built.bgClass && (lineView.bgClass = built.bgClass), 
                built.textClass && (lineView.textClass = built.textClass), updateLineClasses(cm, lineView), 
                updateLineGutter(cm, lineView, lineN, dims), insertLineWidgets(cm, lineView, dims), 
                lineView.node;
            }
            // A lineView may contain multiple logical lines (when merged by
            // collapsed spans). The widgets for all of them need to be drawn.
            function insertLineWidgets(cm, lineView, dims) {
                if (insertLineWidgetsFor(cm, lineView.line, lineView, dims, !0), lineView.rest) for (var i = 0; i < lineView.rest.length; i++) insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, !1);
            }
            function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
                if (line.widgets) for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i], node = elt("div", [ widget.node ], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
                    widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true"), positionLineWidget(widget, node, lineView, dims), 
                    cm.display.input.setUneditable(node), allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node), 
                    signalLater(widget, "redraw");
                }
            }
            function positionLineWidget(widget, node, lineView, dims) {
                if (widget.noHScroll) {
                    (lineView.alignable || (lineView.alignable = [])).push(node);
                    var width = dims.wrapperWidth;
                    node.style.left = dims.fixedPos + "px", widget.coverGutter || (width -= dims.gutterTotalWidth, 
                    node.style.paddingLeft = dims.gutterTotalWidth + "px"), node.style.width = width + "px";
                }
                widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative", 
                widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"));
            }
            function widgetHeight(widget) {
                if (null != widget.height) return widget.height;
                var cm = widget.doc.cm;
                if (!cm) return 0;
                if (!contains(document.body, widget.node)) {
                    var parentStyle = "position: relative;";
                    widget.coverGutter && (parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"), 
                    widget.noHScroll && (parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"), 
                    removeChildrenAndAdd(cm.display.measure, elt("div", [ widget.node ], null, parentStyle));
                }
                return widget.height = widget.node.parentNode.offsetHeight;
            }
            // Return true when the given mouse event happened in a widget
            function eventInWidget(display, e) {
                for (var n = e_target(e); n != display.wrapper; n = n.parentNode) if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover) return !0;
            }
            // POSITION MEASUREMENT
            function paddingTop(display) {
                return display.lineSpace.offsetTop;
            }
            function paddingVert(display) {
                return display.mover.offsetHeight - display.lineSpace.offsetHeight;
            }
            function paddingH(display) {
                if (display.cachedPaddingH) return display.cachedPaddingH;
                var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like")), style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, data = {
                    left: parseInt(style.paddingLeft),
                    right: parseInt(style.paddingRight)
                };
                return isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data), 
                data;
            }
            function scrollGap(cm) {
                return scrollerGap - cm.display.nativeBarWidth;
            }
            function displayWidth(cm) {
                return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
            }
            function displayHeight(cm) {
                return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
            }
            // Ensure the lineView.wrapping.heights array is populated. This is
            // an array of bottom offsets for the lines that make up a drawn
            // line. When lineWrapping is on, there might be more than one
            // height.
            function ensureLineHeights(cm, lineView, rect) {
                var wrapping = cm.options.lineWrapping, curWidth = wrapping && displayWidth(cm);
                if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
                    var heights = lineView.measure.heights = [];
                    if (wrapping) {
                        lineView.measure.width = curWidth;
                        for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                            var cur = rects[i], next = rects[i + 1];
                            Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top);
                        }
                    }
                    heights.push(rect.bottom - rect.top);
                }
            }
            // Find a line map (mapping character offsets to text nodes) and a
            // measurement cache for the given line number. (A line view might
            // contain multiple lines when collapsed ranges are present.)
            function mapFromLineView(lineView, line, lineN) {
                if (lineView.line == line) return {
                    map: lineView.measure.map,
                    cache: lineView.measure.cache
                };
                for (var i = 0; i < lineView.rest.length; i++) if (lineView.rest[i] == line) return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
                for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) if (lineNo(lineView.rest[i$1]) > lineN) return {
                    map: lineView.measure.maps[i$1],
                    cache: lineView.measure.caches[i$1],
                    before: !0
                };
            }
            // Render a line into the hidden node display.externalMeasured. Used
            // when measurement is needed for a line that's not in the viewport.
            function updateExternalMeasurement(cm, line) {
                line = visualLine(line);
                var lineN = lineNo(line), view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
                view.lineN = lineN;
                var built = view.built = buildLineContent(cm, view);
                return view.text = built.pre, removeChildrenAndAdd(cm.display.lineMeasure, built.pre), 
                view;
            }
            // Get a {top, bottom, left, right} box (in line-local coordinates)
            // for a given character.
            function measureChar(cm, line, ch, bias) {
                return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
            }
            // Find a line view that corresponds to the given line number.
            function findViewForLine(cm, lineN) {
                if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) return cm.display.view[findViewIndex(cm, lineN)];
                var ext = cm.display.externalMeasured;
                return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size ? ext : void 0;
            }
            // Measurement can be split in two steps, the set-up work that
            // applies to the whole line, and the measurement of the actual
            // character. Functions like coordsChar, that need to do a lot of
            // measurements in a row, can thus ensure that the set-up work is
            // only done once.
            function prepareMeasureForLine(cm, line) {
                var lineN = lineNo(line), view = findViewForLine(cm, lineN);
                view && !view.text ? view = null : view && view.changes && (updateLineForChanges(cm, view, lineN, getDimensions(cm)), 
                cm.curOp.forceUpdate = !0), view || (view = updateExternalMeasurement(cm, line));
                var info = mapFromLineView(view, line, lineN);
                return {
                    line: line,
                    view: view,
                    rect: null,
                    map: info.map,
                    cache: info.cache,
                    before: info.before,
                    hasHeights: !1
                };
            }
            // Given a prepared measurement object, measures the position of an
            // actual character (or fetches it from the cache).
            function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
                prepared.before && (ch = -1);
                var found, key = ch + (bias || "");
                return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()), 
                prepared.hasHeights || (ensureLineHeights(cm, prepared.view, prepared.rect), prepared.hasHeights = !0), 
                found = measureCharInner(cm, prepared, ch, bias), found.bogus || (prepared.cache[key] = found)), 
                {
                    left: found.left,
                    right: found.right,
                    top: varHeight ? found.rtop : found.top,
                    bottom: varHeight ? found.rbottom : found.bottom
                };
            }
            function nodeAndOffsetInLineMap(map, ch, bias) {
                // First, search the line map for the text node corresponding to,
                // or closest to, the target character.
                for (var node, start, end, collapse, mStart, mEnd, i = 0; i < map.length; i += 3) if (mStart = map[i], 
                mEnd = map[i + 1], ch < mStart ? (start = 0, end = 1, collapse = "left") : ch < mEnd ? (start = ch - mStart, 
                end = start + 1) : (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) && (end = mEnd - mStart, 
                start = end - 1, ch >= mEnd && (collapse = "right")), null != start) {
                    if (node = map[i + 2], mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias), 
                    "left" == bias && 0 == start) for (;i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft; ) node = map[(i -= 3) + 2], 
                    collapse = "left";
                    if ("right" == bias && start == mEnd - mStart) for (;i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft; ) node = map[(i += 3) + 2], 
                    collapse = "right";
                    break;
                }
                return {
                    node: node,
                    start: start,
                    end: end,
                    collapse: collapse,
                    coverStart: mStart,
                    coverEnd: mEnd
                };
            }
            function getUsefulRect(rects, bias) {
                var rect = nullRect;
                if ("left" == bias) for (var i = 0; i < rects.length && (rect = rects[i]).left == rect.right; i++) ; else for (var i$1 = rects.length - 1; i$1 >= 0 && (rect = rects[i$1]).left == rect.right; i$1--) ;
                return rect;
            }
            function measureCharInner(cm, prepared, ch, bias) {
                var rect, place = nodeAndOffsetInLineMap(prepared.map, ch, bias), node = place.node, start = place.start, end = place.end, collapse = place.collapse;
                if (3 == node.nodeType) {
                    // If it is a text node, use a range to retrieve the coordinates.
                    for (var i$1 = 0; i$1 < 4; i$1++) {
                        // Retry a maximum of 4 times when nonsense rectangles are returned
                        for (;start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)); ) --start;
                        for (;place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)); ) ++end;
                        if (rect = ie && ie_version < 9 && 0 == start && end == place.coverEnd - place.coverStart ? node.parentNode.getBoundingClientRect() : getUsefulRect(range(node, start, end).getClientRects(), bias), 
                        rect.left || rect.right || 0 == start) break;
                        end = start, start -= 1, collapse = "right";
                    }
                    ie && ie_version < 11 && (rect = maybeUpdateRectForZooming(cm.display.measure, rect));
                } else {
                    // If it is a widget, simply get the box for the whole widget.
                    start > 0 && (collapse = bias = "right");
                    var rects;
                    rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect();
                }
                if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
                    var rSpan = node.parentNode.getClientRects()[0];
                    rect = rSpan ? {
                        left: rSpan.left,
                        right: rSpan.left + charWidth(cm.display),
                        top: rSpan.top,
                        bottom: rSpan.bottom
                    } : nullRect;
                }
                for (var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (rtop + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++) ;
                var top = i ? heights[i - 1] : 0, bot = heights[i], result = {
                    left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
                    right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
                    top: top,
                    bottom: bot
                };
                return rect.left || rect.right || (result.bogus = !0), cm.options.singleCursorHeightPerLine || (result.rtop = rtop, 
                result.rbottom = rbot), result;
            }
            // Work around problem with bounding client rects on ranges being
            // returned incorrectly when zoomed on IE10 and below.
            function maybeUpdateRectForZooming(measure, rect) {
                if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) return rect;
                var scaleX = screen.logicalXDPI / screen.deviceXDPI, scaleY = screen.logicalYDPI / screen.deviceYDPI;
                return {
                    left: rect.left * scaleX,
                    right: rect.right * scaleX,
                    top: rect.top * scaleY,
                    bottom: rect.bottom * scaleY
                };
            }
            function clearLineMeasurementCacheFor(lineView) {
                if (lineView.measure && (lineView.measure.cache = {}, lineView.measure.heights = null, 
                lineView.rest)) for (var i = 0; i < lineView.rest.length; i++) lineView.measure.caches[i] = {};
            }
            function clearLineMeasurementCache(cm) {
                cm.display.externalMeasure = null, removeChildren(cm.display.lineMeasure);
                for (var i = 0; i < cm.display.view.length; i++) clearLineMeasurementCacheFor(cm.display.view[i]);
            }
            function clearCaches(cm) {
                clearLineMeasurementCache(cm), cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null, 
                cm.options.lineWrapping || (cm.display.maxLineChanged = !0), cm.display.lineNumChars = null;
            }
            function pageScrollX() {
                // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
                // which causes page_Offset and bounding client rects to use
                // different reference viewports and invalidate our calculations.
                // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
                // which causes page_Offset and bounding client rects to use
                // different reference viewports and invalidate our calculations.
                return chrome && android ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft;
            }
            function pageScrollY() {
                return chrome && android ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop;
            }
            function widgetTopHeight(lineObj) {
                var height = 0;
                if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) lineObj.widgets[i].above && (height += widgetHeight(lineObj.widgets[i]));
                return height;
            }
            // Converts a {top, bottom, left, right} box from line-local
            // coordinates into another coordinate system. Context may be one of
            // "line", "div" (display.lineDiv), "local"./null (editor), "window",
            // or "page".
            function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
                if (!includeWidgets) {
                    var height = widgetTopHeight(lineObj);
                    rect.top += height, rect.bottom += height;
                }
                if ("line" == context) return rect;
                context || (context = "local");
                var yOff = heightAtLine(lineObj);
                if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset, 
                "page" == context || "window" == context) {
                    var lOff = cm.display.lineSpace.getBoundingClientRect();
                    yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
                    var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
                    rect.left += xOff, rect.right += xOff;
                }
                return rect.top += yOff, rect.bottom += yOff, rect;
            }
            // Coverts a box from "div" coords to another coordinate system.
            // Context may be "window", "page", "div", or "local"./null.
            function fromCoordSystem(cm, coords, context) {
                if ("div" == context) return coords;
                var left = coords.left, top = coords.top;
                // First move into "page" coordinate system
                if ("page" == context) left -= pageScrollX(), top -= pageScrollY(); else if ("local" == context || !context) {
                    var localBox = cm.display.sizer.getBoundingClientRect();
                    left += localBox.left, top += localBox.top;
                }
                var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
                return {
                    left: left - lineSpaceBox.left,
                    top: top - lineSpaceBox.top
                };
            }
            function charCoords(cm, pos, context, lineObj, bias) {
                return lineObj || (lineObj = getLine(cm.doc, pos.line)), intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
            }
            // Returns a box for a given cursor position, which may have an
            // 'other' property containing the position of the secondary cursor
            // on a bidi boundary.
            // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
            // and after `char - 1` in writing order of `char - 1`
            // A cursor Pos(line, char, "after") is on the same visual line as `char`
            // and before `char` in writing order of `char`
            // Examples (upper-case letters are RTL, lower-case are LTR):
            //     Pos(0, 1, ...)
            //     before   after
            // ab     a|b     a|b
            // aB     a|B     aB|
            // Ab     |Ab     A|b
            // AB     B|A     B|A
            // Every position after the last character on a line is considered to stick
            // to the last character on the line.
            function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
                function get(ch, right) {
                    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
                    return right ? m.left = m.right : m.right = m.left, intoCoordSystem(cm, lineObj, m, context);
                }
                function getBidi(ch, partPos, invert) {
                    var part = order[partPos], right = 1 == part.level;
                    return get(invert ? ch - 1 : ch, right != invert);
                }
                lineObj = lineObj || getLine(cm.doc, pos.line), preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
                var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
                if (ch >= lineObj.text.length ? (ch = lineObj.text.length, sticky = "before") : ch <= 0 && (ch = 0, 
                sticky = "after"), !order) return get("before" == sticky ? ch - 1 : ch, "before" == sticky);
                var partPos = getBidiPartAt(order, ch, sticky), other = bidiOther, val = getBidi(ch, partPos, "before" == sticky);
                return null != other && (val.other = getBidi(ch, other, "before" != sticky)), val;
            }
            // Used to cheaply estimate the coordinates for a position. Used for
            // intermediate scroll updates.
            function estimateCoords(cm, pos) {
                var left = 0;
                pos = clipPos(cm.doc, pos), cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
                var lineObj = getLine(cm.doc, pos.line), top = heightAtLine(lineObj) + paddingTop(cm.display);
                return {
                    left: left,
                    right: left,
                    top: top,
                    bottom: top + lineObj.height
                };
            }
            // Positions returned by coordsChar contain some extra information.
            // xRel is the relative x position of the input coordinates compared
            // to the found position (so xRel > 0 means the coordinates are to
            // the right of the character position, for example). When outside
            // is true, that means the coordinates lie outside the line's
            // vertical range.
            function PosWithInfo(line, ch, sticky, outside, xRel) {
                var pos = Pos(line, ch, sticky);
                return pos.xRel = xRel, outside && (pos.outside = outside), pos;
            }
            // Compute the character position closest to the given coordinates.
            // Input must be lineSpace-local ("div" coordinate system).
            function coordsChar(cm, x, y) {
                var doc = cm.doc;
                if (y += cm.display.viewOffset, y < 0) return PosWithInfo(doc.first, 0, null, -1, -1);
                var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
                if (lineN > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
                x < 0 && (x = 0);
                for (var lineObj = getLine(doc, lineN); ;) {
                    var found = coordsCharInner(cm, lineObj, lineN, x, y), collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
                    if (!collapsed) return found;
                    var rangeEnd = collapsed.find(1);
                    if (rangeEnd.line == lineN) return rangeEnd;
                    lineObj = getLine(doc, lineN = rangeEnd.line);
                }
            }
            function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
                y -= widgetTopHeight(lineObj);
                var end = lineObj.text.length, begin = findFirst(function(ch) {
                    return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
                }, end, 0);
                return end = findFirst(function(ch) {
                    return measureCharPrepared(cm, preparedMeasure, ch).top > y;
                }, begin, end), {
                    begin: begin,
                    end: end
                };
            }
            function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
                preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
                var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
                return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
            }
            // Returns true if the given side of a box is after the given
            // coordinates, in top-to-bottom, left-to-right order.
            function boxIsAfter(box, x, y, left) {
                return !(box.bottom <= y) && (box.top > y || (left ? box.left : box.right) > x);
            }
            function coordsCharInner(cm, lineObj, lineNo, x, y) {
                // Move y into line-local coordinate space
                y -= heightAtLine(lineObj);
                var preparedMeasure = prepareMeasureForLine(cm, lineObj), widgetHeight = widgetTopHeight(lineObj), begin = 0, end = lineObj.text.length, ltr = !0, order = getOrder(lineObj, cm.doc.direction);
                // If the line isn't plain left-to-right text, first figure out
                // which bidi section the coordinates fall into.
                if (order) {
                    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);
                    ltr = 1 != part.level, // The awkward -1 offsets are needed because findFirst (called
                    // on these below) will treat its first bound as inclusive,
                    // second as exclusive, but we want to actually address the
                    // characters in the part's range
                    begin = ltr ? part.from : part.to - 1, end = ltr ? part.to : part.from - 1;
                }
                // A binary search to find the first character whose bounding box
                // starts after the coordinates. If we run across any whose box wrap
                // the coordinates, store that.
                var baseX, sticky, chAround = null, boxAround = null, ch = findFirst(function(ch) {
                    var box = measureCharPrepared(cm, preparedMeasure, ch);
                    return box.top += widgetHeight, box.bottom += widgetHeight, !!boxIsAfter(box, x, y, !1) && (box.top <= y && box.left <= x && (chAround = ch, 
                    boxAround = box), !0);
                }, begin, end), outside = !1;
                // If a box around the coordinates was found, use that
                if (boxAround) {
                    // Distinguish coordinates nearer to the left or right side of the box
                    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
                    ch = chAround + (atStart ? 0 : 1), sticky = atStart ? "after" : "before", baseX = atLeft ? boxAround.left : boxAround.right;
                } else {
                    // (Adjust for extended bound, if necessary.)
                    ltr || ch != end && ch != begin || ch++, // To determine which side to associate with, get the box to the
                    // left of the character and compare it's vertical position to the
                    // coordinates
                    sticky = 0 == ch ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? "after" : "before";
                    // Now get accurate coordinates for this place, in order to get a
                    // base X position
                    var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
                    baseX = coords.left, outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
                }
                return ch = skipExtendingChars(lineObj.text, ch, 1), PosWithInfo(lineNo, ch, sticky, outside, x - baseX);
            }
            function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
                // Bidi parts are sorted left-to-right, and in a non-line-wrapping
                // situation, we can take this ordering to correspond to the visual
                // ordering. This finds the first part whose end is after the given
                // coordinates.
                var index = findFirst(function(i) {
                    var part = order[i], ltr = 1 != part.level;
                    return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, !0);
                }, 0, order.length - 1), part = order[index];
                // If this isn't the first part, the part's start is also after
                // the coordinates, and the coordinates aren't on the same line as
                // that start, move one part back.
                if (index > 0) {
                    var ltr = 1 != part.level, start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
                    boxIsAfter(start, x, y, !0) && start.top > y && (part = order[index - 1]);
                }
                return part;
            }
            function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
                // In a wrapped line, rtl text on wrapping boundaries can do things
                // that don't correspond to the ordering in our `order` array at
                // all, so a binary search doesn't work, and we want to return a
                // part that only spans one line so that the binary search in
                // coordsCharInner is safe. As such, we first find the extent of the
                // wrapped line, and then do a flat search in which we discard any
                // spans that aren't on the line.
                var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = ref.begin, end = ref.end;
                /\s/.test(lineObj.text.charAt(end - 1)) && end--;
                for (var part = null, closestDist = null, i = 0; i < order.length; i++) {
                    var p = order[i];
                    if (!(p.from >= end || p.to <= begin)) {
                        var ltr = 1 != p.level, endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right, dist = endX < x ? x - endX + 1e9 : endX - x;
                        (!part || closestDist > dist) && (part = p, closestDist = dist);
                    }
                }
                // Clip the part to the wrapped line.
                return part || (part = order[order.length - 1]), part.from < begin && (part = {
                    from: begin,
                    to: part.to,
                    level: part.level
                }), part.to > end && (part = {
                    from: part.from,
                    to: end,
                    level: part.level
                }), part;
            }
            // Compute the default text height.
            function textHeight(display) {
                if (null != display.cachedTextHeight) return display.cachedTextHeight;
                if (null == measureText) {
                    measureText = elt("pre", null, "CodeMirror-line-like");
                    // Measure a bunch of lines, for browsers that compute
                    // fractional heights.
                    for (var i = 0; i < 49; ++i) measureText.appendChild(document.createTextNode("x")), 
                    measureText.appendChild(elt("br"));
                    measureText.appendChild(document.createTextNode("x"));
                }
                removeChildrenAndAdd(display.measure, measureText);
                var height = measureText.offsetHeight / 50;
                return height > 3 && (display.cachedTextHeight = height), removeChildren(display.measure), 
                height || 1;
            }
            // Compute the default character width.
            function charWidth(display) {
                if (null != display.cachedCharWidth) return display.cachedCharWidth;
                var anchor = elt("span", "xxxxxxxxxx"), pre = elt("pre", [ anchor ], "CodeMirror-line-like");
                removeChildrenAndAdd(display.measure, pre);
                var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
                return width > 2 && (display.cachedCharWidth = width), width || 10;
            }
            // Do a bulk-read of the DOM positions and sizes needed to draw the
            // view, so that we don't interleave reading and writing to the DOM.
            function getDimensions(cm) {
                for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, 
                ++i) {
                    var id = cm.display.gutterSpecs[i].className;
                    left[id] = n.offsetLeft + n.clientLeft + gutterLeft, width[id] = n.clientWidth;
                }
                return {
                    fixedPos: compensateForHScroll(d),
                    gutterTotalWidth: d.gutters.offsetWidth,
                    gutterLeft: left,
                    gutterWidth: width,
                    wrapperWidth: d.wrapper.clientWidth
                };
            }
            // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
            // but using getBoundingClientRect to get a sub-pixel-accurate
            // result.
            function compensateForHScroll(display) {
                return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
            }
            // Returns a function that estimates the height of a line, to use as
            // first approximation until the line becomes visible (and is thus
            // properly measurable).
            function estimateHeight(cm) {
                var th = textHeight(cm.display), wrapping = cm.options.lineWrapping, perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
                return function(line) {
                    if (lineIsHidden(cm.doc, line)) return 0;
                    var widgetsHeight = 0;
                    if (line.widgets) for (var i = 0; i < line.widgets.length; i++) line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
                    return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th;
                };
            }
            function estimateLineHeights(cm) {
                var doc = cm.doc, est = estimateHeight(cm);
                doc.iter(function(line) {
                    var estHeight = est(line);
                    estHeight != line.height && updateLineHeight(line, estHeight);
                });
            }
            // Given a mouse event, find the corresponding position. If liberal
            // is false, it checks whether a gutter or scrollbar was clicked,
            // and returns null if it was. forRect is used by rectangular
            // selections, and tries to estimate a character position even for
            // coordinates beyond the right of the text.
            function posFromMouse(cm, e, liberal, forRect) {
                var display = cm.display;
                if (!liberal && "true" == e_target(e).getAttribute("cm-not-content")) return null;
                var x, y, space = display.lineSpace.getBoundingClientRect();
                // Fails unpredictably on IE[67] when mouse is dragged around quickly.
                try {
                    x = e.clientX - space.left, y = e.clientY - space.top;
                } catch (e$1) {
                    return null;
                }
                var line, coords = coordsChar(cm, x, y);
                if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
                    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
                    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
                }
                return coords;
            }
            // Find the view element corresponding to a given line. Return null
            // when the line isn't visible.
            function findViewIndex(cm, n) {
                if (n >= cm.display.viewTo) return null;
                if (n -= cm.display.viewFrom, n < 0) return null;
                for (var view = cm.display.view, i = 0; i < view.length; i++) if (n -= view[i].size, 
                n < 0) return i;
            }
            // Updates the display.view data structure for a given change to the
            // document. From and to are in pre-change coordinates. Lendiff is
            // the amount of lines added or subtracted by the change. This is
            // used for changes that span multiple lines, or change the way
            // lines are divided into visual lines. regLineChange (below)
            // registers single-line changes.
            function regChange(cm, from, to, lendiff) {
                null == from && (from = cm.doc.first), null == to && (to = cm.doc.first + cm.doc.size), 
                lendiff || (lendiff = 0);
                var display = cm.display;
                if (lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from), 
                cm.curOp.viewChanged = !0, from >= display.viewTo) // Change after
                sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm); else if (to <= display.viewFrom) // Change before
                sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff, 
                display.viewTo += lendiff); else if (from <= display.viewFrom && to >= display.viewTo) // Full overlap
                resetView(cm); else if (from <= display.viewFrom) {
                    // Top overlap
                    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
                    cut ? (display.view = display.view.slice(cut.index), display.viewFrom = cut.lineN, 
                    display.viewTo += lendiff) : resetView(cm);
                } else if (to >= display.viewTo) {
                    // Bottom overlap
                    var cut$1 = viewCuttingPoint(cm, from, from, -1);
                    cut$1 ? (display.view = display.view.slice(0, cut$1.index), display.viewTo = cut$1.lineN) : resetView(cm);
                } else {
                    // Gap in the middle
                    var cutTop = viewCuttingPoint(cm, from, from, -1), cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
                    cutTop && cutBot ? (display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)), 
                    display.viewTo += lendiff) : resetView(cm);
                }
                var ext = display.externalMeasured;
                ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null));
            }
            // Register a change to a single line. Type must be one of "text",
            // "gutter", "class", "widget"
            function regLineChange(cm, line, type) {
                cm.curOp.viewChanged = !0;
                var display = cm.display, ext = cm.display.externalMeasured;
                if (ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null), 
                !(line < display.viewFrom || line >= display.viewTo)) {
                    var lineView = display.view[findViewIndex(cm, line)];
                    if (null != lineView.node) {
                        var arr = lineView.changes || (lineView.changes = []);
                        indexOf(arr, type) == -1 && arr.push(type);
                    }
                }
            }
            // Clear the view.
            function resetView(cm) {
                cm.display.viewFrom = cm.display.viewTo = cm.doc.first, cm.display.view = [], cm.display.viewOffset = 0;
            }
            function viewCuttingPoint(cm, oldN, newN, dir) {
                var diff, index = findViewIndex(cm, oldN), view = cm.display.view;
                if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) return {
                    index: index,
                    lineN: newN
                };
                for (var n = cm.display.viewFrom, i = 0; i < index; i++) n += view[i].size;
                if (n != oldN) {
                    if (dir > 0) {
                        if (index == view.length - 1) return null;
                        diff = n + view[index].size - oldN, index++;
                    } else diff = n - oldN;
                    oldN += diff, newN += diff;
                }
                for (;visualLineNo(cm.doc, newN) != newN; ) {
                    if (index == (dir < 0 ? 0 : view.length - 1)) return null;
                    newN += dir * view[index - (dir < 0 ? 1 : 0)].size, index += dir;
                }
                return {
                    index: index,
                    lineN: newN
                };
            }
            // Force the view to cover a given range, adding empty view element
            // or clipping off existing ones as needed.
            function adjustView(cm, from, to) {
                var display = cm.display, view = display.view;
                0 == view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to), 
                display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))), 
                display.viewFrom = from, display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))), 
                display.viewTo = to;
            }
            // Count the number of lines in the view whose DOM representation is
            // out of date (or nonexistent).
            function countDirtyView(cm) {
                for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    lineView.hidden || lineView.node && !lineView.changes || ++dirty;
                }
                return dirty;
            }
            function updateSelection(cm) {
                cm.display.input.showSelection(cm.display.input.prepareSelection());
            }
            function prepareSelection(cm, primary) {
                void 0 === primary && (primary = !0);
                for (var doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++) if (primary || i != doc.sel.primIndex) {
                    var range = doc.sel.ranges[i];
                    if (!(range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom)) {
                        var collapsed = range.empty();
                        (collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range.head, curFragment), 
                        collapsed || drawSelectionRange(cm, range, selFragment);
                    }
                }
                return result;
            }
            // Draws a cursor for the given range
            function drawSelectionCursor(cm, head, output) {
                var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine), cursor = output.appendChild(elt("div", " ", "CodeMirror-cursor"));
                if (cursor.style.left = pos.left + "px", cursor.style.top = pos.top + "px", cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px", 
                pos.other) {
                    // Secondary cursor, shown when on a 'jump' in bi-directional text
                    var otherCursor = output.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
                    otherCursor.style.display = "", otherCursor.style.left = pos.other.left + "px", 
                    otherCursor.style.top = pos.other.top + "px", otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px";
                }
            }
            function cmpCoords(a, b) {
                return a.top - b.top || a.left - b.left;
            }
            // Draws the given range as a highlighted selection
            function drawSelectionRange(cm, range, output) {
                function add(left, top, width, bottom) {
                    top < 0 && (top = 0), top = Math.round(top), bottom = Math.round(bottom), fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
                }
                function drawForLine(line, fromArg, toArg) {
                    function coords(ch, bias) {
                        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
                    }
                    function wrapX(pos, dir, side) {
                        var extent = wrappedLineExtentChar(cm, lineObj, null, pos), prop = "ltr" == dir == ("after" == side) ? "left" : "right", ch = "after" == side ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
                        return coords(ch, prop)[prop];
                    }
                    var start, end, lineObj = getLine(doc, line), lineLen = lineObj.text.length, order = getOrder(lineObj, doc.direction);
                    return iterateBidiSections(order, fromArg || 0, null == toArg ? lineLen : toArg, function(from, to, dir, i) {
                        var ltr = "ltr" == dir, fromPos = coords(from, ltr ? "left" : "right"), toPos = coords(to - 1, ltr ? "right" : "left"), openStart = null == fromArg && 0 == from, openEnd = null == toArg && to == lineLen, first = 0 == i, last = !order || i == order.length - 1;
                        if (toPos.top - fromPos.top <= 3) {
                            // Single line
                            var openLeft = (docLTR ? openStart : openEnd) && first, openRight = (docLTR ? openEnd : openStart) && last, left = openLeft ? leftSide : (ltr ? fromPos : toPos).left, right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                            add(left, fromPos.top, right - left, fromPos.bottom);
                        } else {
                            // Multiple lines
                            var topLeft, topRight, botLeft, botRight;
                            ltr ? (topLeft = docLTR && openStart && first ? leftSide : fromPos.left, topRight = docLTR ? rightSide : wrapX(from, dir, "before"), 
                            botLeft = docLTR ? leftSide : wrapX(to, dir, "after"), botRight = docLTR && openEnd && last ? rightSide : toPos.right) : (topLeft = docLTR ? wrapX(from, dir, "before") : leftSide, 
                            topRight = !docLTR && openStart && first ? rightSide : fromPos.right, botLeft = !docLTR && openEnd && last ? leftSide : toPos.left, 
                            botRight = docLTR ? wrapX(to, dir, "after") : rightSide), add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom), 
                            fromPos.bottom < toPos.top && add(leftSide, fromPos.bottom, null, toPos.top), add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
                        }
                        (!start || cmpCoords(fromPos, start) < 0) && (start = fromPos), cmpCoords(toPos, start) < 0 && (start = toPos), 
                        (!end || cmpCoords(fromPos, end) < 0) && (end = fromPos), cmpCoords(toPos, end) < 0 && (end = toPos);
                    }), {
                        start: start,
                        end: end
                    };
                }
                var display = cm.display, doc = cm.doc, fragment = document.createDocumentFragment(), padding = paddingH(cm.display), leftSide = padding.left, rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right, docLTR = "ltr" == doc.direction, sFrom = range.from(), sTo = range.to();
                if (sFrom.line == sTo.line) drawForLine(sFrom.line, sFrom.ch, sTo.ch); else {
                    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line), singleVLine = visualLine(fromLine) == visualLine(toLine), leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end, rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
                    singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom), 
                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)), 
                    leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top);
                }
                output.appendChild(fragment);
            }
            // Cursor-blinking
            function restartBlink(cm) {
                if (cm.state.focused) {
                    var display = cm.display;
                    clearInterval(display.blinker);
                    var on = !0;
                    display.cursorDiv.style.visibility = "", cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function() {
                        cm.hasFocus() || onBlur(cm), display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
                    }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden");
                }
            }
            function ensureFocus(cm) {
                cm.state.focused || (cm.display.input.focus(), onFocus(cm));
            }
            function delayBlurEvent(cm) {
                cm.state.delayingBlurEvent = !0, setTimeout(function() {
                    cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1, onBlur(cm));
                }, 100);
            }
            function onFocus(cm, e) {
                cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1), "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm, e), 
                cm.state.focused = !0, addClass(cm.display.wrapper, "CodeMirror-focused"), // This test prevents this from firing when a context
                // menu is closed (since the input reset would kill the
                // select-all detection hack)
                cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (cm.display.input.reset(), 
                webkit && setTimeout(function() {
                    return cm.display.input.reset(!0);
                }, 20)), cm.display.input.receivedFocus()), restartBlink(cm));
            }
            function onBlur(cm, e) {
                cm.state.delayingBlurEvent || (cm.state.focused && (signal(cm, "blur", cm, e), cm.state.focused = !1, 
                rmClass(cm.display.wrapper, "CodeMirror-focused")), clearInterval(cm.display.blinker), 
                setTimeout(function() {
                    cm.state.focused || (cm.display.shift = !1);
                }, 150));
            }
            // Read the actual heights of the rendered lines, and update their
            // stored heights to match.
            function updateHeightsInViewport(cm) {
                for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
                    var cur = display.view[i], wrapping = cm.options.lineWrapping, height = void 0, width = 0;
                    if (!cur.hidden) {
                        if (ie && ie_version < 8) {
                            var bot = cur.node.offsetTop + cur.node.offsetHeight;
                            height = bot - prevBottom, prevBottom = bot;
                        } else {
                            var box = cur.node.getBoundingClientRect();
                            height = box.bottom - box.top, // Check that lines don't extend past the right of the current
                            // editor width
                            !wrapping && cur.text.firstChild && (width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1);
                        }
                        var diff = cur.line.height - height;
                        if ((diff > .005 || diff < -.005) && (updateLineHeight(cur.line, height), updateWidgetHeight(cur.line), 
                        cur.rest)) for (var j = 0; j < cur.rest.length; j++) updateWidgetHeight(cur.rest[j]);
                        if (width > cm.display.sizerWidth) {
                            var chWidth = Math.ceil(width / charWidth(cm.display));
                            chWidth > cm.display.maxLineLength && (cm.display.maxLineLength = chWidth, cm.display.maxLine = cur.line, 
                            cm.display.maxLineChanged = !0);
                        }
                    }
                }
            }
            // Read and store the height of line widgets associated with the
            // given line.
            function updateWidgetHeight(line) {
                if (line.widgets) for (var i = 0; i < line.widgets.length; ++i) {
                    var w = line.widgets[i], parent = w.node.parentNode;
                    parent && (w.height = parent.offsetHeight);
                }
            }
            // Compute the lines that are visible in a given viewport (defaults
            // the the current scroll position). viewport may contain top,
            // height, and ensure (see op.scrollToPos) properties.
            function visibleLines(display, doc, viewport) {
                var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
                top = Math.floor(top - paddingTop(display));
                var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight, from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
                // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
                // forces those lines into the viewport (if possible).
                if (viewport && viewport.ensure) {
                    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
                    ensureFrom < from ? (from = ensureFrom, to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)) : Math.min(ensureTo, doc.lastLine()) >= to && (from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight), 
                    to = ensureTo);
                }
                return {
                    from: from,
                    to: Math.max(to, from + 1)
                };
            }
            // SCROLLING THINGS INTO VIEW
            // If an editor sits on the top or bottom of the window, partially
            // scrolled out of view, this ensures that the cursor is visible.
            function maybeScrollWindow(cm, rect) {
                if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
                    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
                    if (rect.top + box.top < 0 ? doScroll = !0 : rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1), 
                    null != doScroll && !phantom) {
                        var scrollNode = elt("div", "​", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
                        cm.display.lineSpace.appendChild(scrollNode), scrollNode.scrollIntoView(doScroll), 
                        cm.display.lineSpace.removeChild(scrollNode);
                    }
                }
            }
            // Scroll a given position into view (immediately), verifying that
            // it actually became visible (as line heights are accurately
            // measured, the position of something may 'drift' during drawing).
            function scrollPosIntoView(cm, pos, end, margin) {
                null == margin && (margin = 0);
                var rect;
                cm.options.lineWrapping || pos != end || (// Set pos and end to the cursor positions around the character pos sticks to
                // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
                // If pos == Pos(_, 0, "before"), pos and end are unchanged
                pos = pos.ch ? Pos(pos.line, "before" == pos.sticky ? pos.ch - 1 : pos.ch, "after") : pos, 
                end = "before" == pos.sticky ? Pos(pos.line, pos.ch + 1, "before") : pos);
                for (var limit = 0; limit < 5; limit++) {
                    var changed = !1, coords = cursorCoords(cm, pos), endCoords = end && end != pos ? cursorCoords(cm, end) : coords;
                    rect = {
                        left: Math.min(coords.left, endCoords.left),
                        top: Math.min(coords.top, endCoords.top) - margin,
                        right: Math.max(coords.left, endCoords.left),
                        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
                    };
                    var scrollPos = calculateScrollPos(cm, rect), startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
                    if (null != scrollPos.scrollTop && (updateScrollTop(cm, scrollPos.scrollTop), Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)), 
                    null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft), Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)), 
                    !changed) break;
                }
                return rect;
            }
            // Scroll a given set of coordinates into view (immediately).
            function scrollIntoView(cm, rect) {
                var scrollPos = calculateScrollPos(cm, rect);
                null != scrollPos.scrollTop && updateScrollTop(cm, scrollPos.scrollTop), null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft);
            }
            // Calculate a new scroll position needed to scroll the given
            // rectangle into view. Returns an object with scrollTop and
            // scrollLeft properties. When these are undefined, the
            // vertical/horizontal position does not need to be adjusted.
            function calculateScrollPos(cm, rect) {
                var display = cm.display, snapMargin = textHeight(cm.display);
                rect.top < 0 && (rect.top = 0);
                var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop, screen = displayHeight(cm), result = {};
                rect.bottom - rect.top > screen && (rect.bottom = rect.top + screen);
                var docBottom = cm.doc.height + paddingVert(display), atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
                if (rect.top < screentop) result.scrollTop = atTop ? 0 : rect.top; else if (rect.bottom > screentop + screen) {
                    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
                    newTop != screentop && (result.scrollTop = newTop);
                }
                var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft, screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0), tooWide = rect.right - rect.left > screenw;
                return tooWide && (rect.right = rect.left + screenw), rect.left < 10 ? result.scrollLeft = 0 : rect.left < screenleft ? result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)) : rect.right > screenw + screenleft - 3 && (result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw), 
                result;
            }
            // Store a relative adjustment to the scroll position in the current
            // operation (to be applied when the operation finishes).
            function addToScrollTop(cm, top) {
                null != top && (resolveScrollToPos(cm), cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top);
            }
            // Make sure that at the end of the operation the current cursor is
            // shown.
            function ensureCursorVisible(cm) {
                resolveScrollToPos(cm);
                var cur = cm.getCursor();
                cm.curOp.scrollToPos = {
                    from: cur,
                    to: cur,
                    margin: cm.options.cursorScrollMargin
                };
            }
            function scrollToCoords(cm, x, y) {
                null == x && null == y || resolveScrollToPos(cm), null != x && (cm.curOp.scrollLeft = x), 
                null != y && (cm.curOp.scrollTop = y);
            }
            function scrollToRange(cm, range) {
                resolveScrollToPos(cm), cm.curOp.scrollToPos = range;
            }
            // When an operation has its scrollToPos property set, and another
            // scroll action is applied before the end of the operation, this
            // 'simulates' scrolling that position into view in a cheap way, so
            // that the effect of intermediate scroll commands is not ignored.
            function resolveScrollToPos(cm) {
                var range = cm.curOp.scrollToPos;
                if (range) {
                    cm.curOp.scrollToPos = null;
                    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
                    scrollToCoordsRange(cm, from, to, range.margin);
                }
            }
            function scrollToCoordsRange(cm, from, to, margin) {
                var sPos = calculateScrollPos(cm, {
                    left: Math.min(from.left, to.left),
                    top: Math.min(from.top, to.top) - margin,
                    right: Math.max(from.right, to.right),
                    bottom: Math.max(from.bottom, to.bottom) + margin
                });
                scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
            }
            // Sync the scrollable area and scrollbars, ensure the viewport
            // covers the visible area.
            function updateScrollTop(cm, val) {
                Math.abs(cm.doc.scrollTop - val) < 2 || (gecko || updateDisplaySimple(cm, {
                    top: val
                }), setScrollTop(cm, val, !0), gecko && updateDisplaySimple(cm), startWorker(cm, 100));
            }
            function setScrollTop(cm, val, forceScroll) {
                val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val)), 
                (cm.display.scroller.scrollTop != val || forceScroll) && (cm.doc.scrollTop = val, 
                cm.display.scrollbars.setScrollTop(val), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val));
            }
            // Sync scroller and scrollbar, ensure the gutter elements are
            // aligned.
            function setScrollLeft(cm, val, isScroller, forceScroll) {
                val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)), 
                (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll || (cm.doc.scrollLeft = val, 
                alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val), 
                cm.display.scrollbars.setScrollLeft(val));
            }
            // SCROLLBARS
            // Prepare DOM reads needed to update the scrollbars. Done in one
            // shot to minimize update/measure roundtrips.
            function measureForScrollbars(cm) {
                var d = cm.display, gutterW = d.gutters.offsetWidth, docH = Math.round(cm.doc.height + paddingVert(cm.display));
                return {
                    clientHeight: d.scroller.clientHeight,
                    viewHeight: d.wrapper.clientHeight,
                    scrollWidth: d.scroller.scrollWidth,
                    clientWidth: d.scroller.clientWidth,
                    viewWidth: d.wrapper.clientWidth,
                    barLeft: cm.options.fixedGutter ? gutterW : 0,
                    docHeight: docH,
                    scrollHeight: docH + scrollGap(cm) + d.barHeight,
                    nativeBarWidth: d.nativeBarWidth,
                    gutterWidth: gutterW
                };
            }
            function updateScrollbars(cm, measure) {
                measure || (measure = measureForScrollbars(cm));
                var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
                updateScrollbarsInner(cm, measure);
                for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm), 
                updateScrollbarsInner(cm, measureForScrollbars(cm)), startWidth = cm.display.barWidth, 
                startHeight = cm.display.barHeight;
            }
            // Re-synchronize the fake scrollbars with the actual size of the
            // content.
            function updateScrollbarsInner(cm, measure) {
                var d = cm.display, sizes = d.scrollbars.update(measure);
                d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px", d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px", 
                d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent", sizes.right && sizes.bottom ? (d.scrollbarFiller.style.display = "block", 
                d.scrollbarFiller.style.height = sizes.bottom + "px", d.scrollbarFiller.style.width = sizes.right + "px") : d.scrollbarFiller.style.display = "", 
                sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block", 
                d.gutterFiller.style.height = sizes.bottom + "px", d.gutterFiller.style.width = measure.gutterWidth + "px") : d.gutterFiller.style.display = "";
            }
            function initScrollbars(cm) {
                cm.display.scrollbars && (cm.display.scrollbars.clear(), cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)), 
                cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
                    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller), // Prevent clicks in the scrollbars from killing focus
                    on(node, "mousedown", function() {
                        cm.state.focused && setTimeout(function() {
                            return cm.display.input.focus();
                        }, 0);
                    }), node.setAttribute("cm-not-content", "true");
                }, function(pos, axis) {
                    "horizontal" == axis ? setScrollLeft(cm, pos) : updateScrollTop(cm, pos);
                }, cm), cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
            // Start a new operation.
            function startOperation(cm) {
                cm.curOp = {
                    cm: cm,
                    viewChanged: !1,
                    // Flag that indicates that lines might need to be redrawn
                    startHeight: cm.doc.height,
                    // Used to detect need to update scrollbar
                    forceUpdate: !1,
                    // Used to force a redraw
                    updateInput: 0,
                    // Whether to reset the input textarea
                    typing: !1,
                    // Whether this reset should be careful to leave existing text (for compositing)
                    changeObjs: null,
                    // Accumulated changes, for firing change events
                    cursorActivityHandlers: null,
                    // Set of handlers to fire cursorActivity on
                    cursorActivityCalled: 0,
                    // Tracks which cursorActivity handlers have been called already
                    selectionChanged: !1,
                    // Whether the selection needs to be redrawn
                    updateMaxLine: !1,
                    // Set when the widest line needs to be determined anew
                    scrollLeft: null,
                    scrollTop: null,
                    // Intermediate scroll position, not pushed to DOM yet
                    scrollToPos: null,
                    // Used to scroll to a specific position
                    focus: !1,
                    id: ++nextOpId
                }, pushOperation(cm.curOp);
            }
            // Finish an operation, updating the display and signalling delayed events
            function endOperation(cm) {
                var op = cm.curOp;
                op && finishOperation(op, function(group) {
                    for (var i = 0; i < group.ops.length; i++) group.ops[i].cm.curOp = null;
                    endOperations(group);
                });
            }
            // The DOM updates done when an operation finishes are batched so
            // that the minimum number of relayouts are required.
            function endOperations(group) {
                for (var ops = group.ops, i = 0; i < ops.length; i++) endOperation_R1(ops[i]);
                for (var i$1 = 0; i$1 < ops.length; i$1++) endOperation_W1(ops[i$1]);
                for (var i$2 = 0; i$2 < ops.length; i$2++) endOperation_R2(ops[i$2]);
                for (var i$3 = 0; i$3 < ops.length; i$3++) endOperation_W2(ops[i$3]);
                for (var i$4 = 0; i$4 < ops.length; i$4++) endOperation_finish(ops[i$4]);
            }
            function endOperation_R1(op) {
                var cm = op.cm, display = cm.display;
                maybeClipScrollbars(cm), op.updateMaxLine && findMaxLine(cm), op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping, 
                op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
                    top: op.scrollTop,
                    ensure: op.scrollToPos
                }, op.forceUpdate);
            }
            function endOperation_W1(op) {
                op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
            }
            function endOperation_R2(op) {
                var cm = op.cm, display = cm.display;
                op.updatedDisplay && updateHeightsInViewport(cm), op.barMeasure = measureForScrollbars(cm), 
                // If the max line changed since it was last measured, measure it,
                // and ensure the document's width matches it.
                // updateDisplay_W2 will use these properties to do the actual resizing
                display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3, 
                cm.display.sizerWidth = op.adjustWidthTo, op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth), 
                op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))), 
                (op.updatedDisplay || op.selectionChanged) && (op.preparedSelection = display.input.prepareSelection());
            }
            function endOperation_W2(op) {
                var cm = op.cm;
                null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px", 
                op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0), 
                cm.display.maxLineChanged = !1);
                var takeFocus = op.focus && op.focus == activeElt();
                op.preparedSelection && cm.display.input.showSelection(op.preparedSelection, takeFocus), 
                (op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure), 
                op.updatedDisplay && setDocumentHeight(cm, op.barMeasure), op.selectionChanged && restartBlink(cm), 
                cm.state.focused && op.updateInput && cm.display.input.reset(op.typing), takeFocus && ensureFocus(op.cm);
            }
            function endOperation_finish(op) {
                var cm = op.cm, display = cm.display, doc = cm.doc;
                // If we need to scroll a specific position into view, do so.
                if (op.updatedDisplay && postUpdateDisplay(cm, op.update), // Abort mouse wheel delta measurement, when scrolling explicitly
                null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null), 
                // Propagate the scroll position to the actual DOM scroller
                null != op.scrollTop && setScrollTop(cm, op.scrollTop, op.forceScroll), null != op.scrollLeft && setScrollLeft(cm, op.scrollLeft, !0, !0), 
                op.scrollToPos) {
                    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
                    maybeScrollWindow(cm, rect);
                }
                // Fire events for markers that are hidden/unidden by editing or
                // undoing
                var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
                if (hidden) for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
                if (unhidden) for (var i$1 = 0; i$1 < unhidden.length; ++i$1) unhidden[i$1].lines.length && signal(unhidden[i$1], "unhide");
                display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop), 
                // Fire change events, and delayed event handlers
                op.changeObjs && signal(cm, "changes", cm, op.changeObjs), op.update && op.update.finish();
            }
            // Run the given function in an operation
            function runInOp(cm, f) {
                if (cm.curOp) return f();
                startOperation(cm);
                try {
                    return f();
                } finally {
                    endOperation(cm);
                }
            }
            // Wraps a function in an operation. Returns the wrapped function.
            function operation(cm, f) {
                return function() {
                    if (cm.curOp) return f.apply(cm, arguments);
                    startOperation(cm);
                    try {
                        return f.apply(cm, arguments);
                    } finally {
                        endOperation(cm);
                    }
                };
            }
            // Used to add methods to editor and doc instances, wrapping them in
            // operations.
            function methodOp(f) {
                return function() {
                    if (this.curOp) return f.apply(this, arguments);
                    startOperation(this);
                    try {
                        return f.apply(this, arguments);
                    } finally {
                        endOperation(this);
                    }
                };
            }
            function docMethodOp(f) {
                return function() {
                    var cm = this.cm;
                    if (!cm || cm.curOp) return f.apply(this, arguments);
                    startOperation(cm);
                    try {
                        return f.apply(this, arguments);
                    } finally {
                        endOperation(cm);
                    }
                };
            }
            // HIGHLIGHT WORKER
            function startWorker(cm, time) {
                cm.doc.highlightFrontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm));
            }
            function highlightWorker(cm) {
                var doc = cm.doc;
                if (!(doc.highlightFrontier >= cm.display.viewTo)) {
                    var end = +new Date() + cm.options.workTime, context = getContextBefore(cm, doc.highlightFrontier), changedLines = [];
                    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
                        if (context.line >= cm.display.viewFrom) {
                            // Visible
                            var oldStyles = line.styles, resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null, highlighted = highlightLine(cm, line, context, !0);
                            resetState && (context.state = resetState), line.styles = highlighted.styles;
                            var oldCls = line.styleClasses, newCls = highlighted.classes;
                            newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
                            for (var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass), i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                            ischange && changedLines.push(context.line), line.stateAfter = context.save(), context.nextLine();
                        } else line.text.length <= cm.options.maxHighlightLength && processLine(cm, line.text, context), 
                        line.stateAfter = context.line % 5 == 0 ? context.save() : null, context.nextLine();
                        if (+new Date() > end) return startWorker(cm, cm.options.workDelay), !0;
                    }), doc.highlightFrontier = context.line, doc.modeFrontier = Math.max(doc.modeFrontier, context.line), 
                    changedLines.length && runInOp(cm, function() {
                        for (var i = 0; i < changedLines.length; i++) regLineChange(cm, changedLines[i], "text");
                    });
                }
            }
            function maybeClipScrollbars(cm) {
                var display = cm.display;
                !display.scrollbarsClipped && display.scroller.offsetWidth && (display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth, 
                display.heightForcer.style.height = scrollGap(cm) + "px", display.sizer.style.marginBottom = -display.nativeBarWidth + "px", 
                display.sizer.style.borderRightWidth = scrollGap(cm) + "px", display.scrollbarsClipped = !0);
            }
            function selectionSnapshot(cm) {
                if (cm.hasFocus()) return null;
                var active = activeElt();
                if (!active || !contains(cm.display.lineDiv, active)) return null;
                var result = {
                    activeElt: active
                };
                if (window.getSelection) {
                    var sel = window.getSelection();
                    sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode) && (result.anchorNode = sel.anchorNode, 
                    result.anchorOffset = sel.anchorOffset, result.focusNode = sel.focusNode, result.focusOffset = sel.focusOffset);
                }
                return result;
            }
            function restoreSelection(snapshot) {
                if (snapshot && snapshot.activeElt && snapshot.activeElt != activeElt() && (snapshot.activeElt.focus(), 
                !/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode))) {
                    var sel = window.getSelection(), range = document.createRange();
                    range.setEnd(snapshot.anchorNode, snapshot.anchorOffset), range.collapse(!1), sel.removeAllRanges(), 
                    sel.addRange(range), sel.extend(snapshot.focusNode, snapshot.focusOffset);
                }
            }
            // Does the actual updating of the line display. Bails out
            // (returning false) when there is nothing to be done and forced is
            // false.
            function updateDisplayIfNeeded(cm, update) {
                var display = cm.display, doc = cm.doc;
                if (update.editorIsHidden) return resetView(cm), !1;
                // Bail out if the visible area is already rendered and nothing changed.
                if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm)) return !1;
                maybeUpdateLineNumberWidth(cm) && (resetView(cm), update.dims = getDimensions(cm));
                // Compute a suitable new viewport (from & to)
                var end = doc.first + doc.size, from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first), to = Math.min(end, update.visible.to + cm.options.viewportMargin);
                display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)), 
                display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)), 
                sawCollapsedSpans && (from = visualLineNo(cm.doc, from), to = visualLineEndNo(cm.doc, to));
                var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
                adjustView(cm, from, to), display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)), 
                // Position the mover div to align with the current scroll position
                cm.display.mover.style.top = display.viewOffset + "px";
                var toUpdate = countDirtyView(cm);
                if (!different && 0 == toUpdate && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo)) return !1;
                // For big changes, we hide the enclosing element during the
                // update, since that speeds up the operations on most browsers.
                var selSnapshot = selectionSnapshot(cm);
                // There might have been a widget with a focused element that got
                // hidden or updated, if so re-focus it.
                // Prevent selection and cursors from interfering with the scroll
                // width and height.
                return toUpdate > 4 && (display.lineDiv.style.display = "none"), patchDisplay(cm, display.updateLineNumbers, update.dims), 
                toUpdate > 4 && (display.lineDiv.style.display = ""), display.renderedView = display.view, 
                restoreSelection(selSnapshot), removeChildren(display.cursorDiv), removeChildren(display.selectionDiv), 
                display.gutters.style.height = display.sizer.style.minHeight = 0, different && (display.lastWrapHeight = update.wrapperHeight, 
                display.lastWrapWidth = update.wrapperWidth, startWorker(cm, 400)), display.updateLineNumbers = null, 
                !0;
            }
            function postUpdateDisplay(cm, update) {
                for (var viewport = update.viewport, first = !0; ;first = !1) {
                    if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm)) first && (update.visible = visibleLines(cm.display, cm.doc, viewport)); else if (// Clip forced viewport to actual scrollable area.
                    viewport && null != viewport.top && (viewport = {
                        top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
                    }), // Updated line heights might result in the drawn area not
                    // actually covering the viewport. Keep looping until it does.
                    update.visible = visibleLines(cm.display, cm.doc, viewport), update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) break;
                    if (!updateDisplayIfNeeded(cm, update)) break;
                    updateHeightsInViewport(cm);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), 
                    update.force = !1;
                }
                update.signal(cm, "update", cm), cm.display.viewFrom == cm.display.reportedViewFrom && cm.display.viewTo == cm.display.reportedViewTo || (update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo), 
                cm.display.reportedViewFrom = cm.display.viewFrom, cm.display.reportedViewTo = cm.display.viewTo);
            }
            function updateDisplaySimple(cm, viewport) {
                var update = new DisplayUpdate(cm, viewport);
                if (updateDisplayIfNeeded(cm, update)) {
                    updateHeightsInViewport(cm), postUpdateDisplay(cm, update);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), 
                    update.finish();
                }
            }
            // Sync the actual display DOM structure with display.view, removing
            // nodes for lines that are no longer in view, and creating the ones
            // that are not there yet, and updating the ones that are out of
            // date.
            function patchDisplay(cm, updateNumbersFrom, dims) {
                function rm(node) {
                    var next = node.nextSibling;
                    // Works around a throw-scroll bug in OS X Webkit
                    return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node), 
                    next;
                }
                // Loop over the elements in the view, syncing cur (the DOM nodes
                // in display.lineDiv) with the view as we go.
                for (var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild, view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    if (lineView.hidden) ; else if (lineView.node && lineView.node.parentNode == container) {
                        // Already drawn
                        for (;cur != lineView.node; ) cur = rm(cur);
                        var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
                        lineView.changes && (indexOf(lineView.changes, "gutter") > -1 && (updateNumber = !1), 
                        updateLineForChanges(cm, lineView, lineN, dims)), updateNumber && (removeChildren(lineView.lineNumber), 
                        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))), 
                        cur = lineView.node.nextSibling;
                    } else {
                        // Not drawn yet
                        var node = buildLineElement(cm, lineView, lineN, dims);
                        container.insertBefore(node, cur);
                    }
                    lineN += lineView.size;
                }
                for (;cur; ) cur = rm(cur);
            }
            function updateGutterSpace(display) {
                var width = display.gutters.offsetWidth;
                display.sizer.style.marginLeft = width + "px";
            }
            function setDocumentHeight(cm, measure) {
                cm.display.sizer.style.minHeight = measure.docHeight + "px", cm.display.heightForcer.style.top = measure.docHeight + "px", 
                cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
            }
            // Re-align line numbers and gutter marks to compensate for
            // horizontal scrolling.
            function alignHorizontally(cm) {
                var display = cm.display, view = display.view;
                if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
                    for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++) if (!view[i].hidden) {
                        cm.options.fixedGutter && (view[i].gutter && (view[i].gutter.style.left = left), 
                        view[i].gutterBackground && (view[i].gutterBackground.style.left = left));
                        var align = view[i].alignable;
                        if (align) for (var j = 0; j < align.length; j++) align[j].style.left = left;
                    }
                    cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px");
                }
            }
            // Used to ensure that the line number gutter is still the right
            // size for the current document size. Returns true when an update
            // is needed.
            function maybeUpdateLineNumberWidth(cm) {
                if (!cm.options.lineNumbers) return !1;
                var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
                if (last.length != display.lineNumChars) {
                    var test = display.measure.appendChild(elt("div", [ elt("div", last) ], "CodeMirror-linenumber CodeMirror-gutter-elt")), innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
                    return display.lineGutter.style.width = "", display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1, 
                    display.lineNumWidth = display.lineNumInnerWidth + padding, display.lineNumChars = display.lineNumInnerWidth ? last.length : -1, 
                    display.lineGutter.style.width = display.lineNumWidth + "px", updateGutterSpace(cm.display), 
                    !0;
                }
                return !1;
            }
            function getGutters(gutters, lineNumbers) {
                for (var result = [], sawLineNumbers = !1, i = 0; i < gutters.length; i++) {
                    var name = gutters[i], style = null;
                    if ("string" != typeof name && (style = name.style, name = name.className), "CodeMirror-linenumbers" == name) {
                        if (!lineNumbers) continue;
                        sawLineNumbers = !0;
                    }
                    result.push({
                        className: name,
                        style: style
                    });
                }
                return lineNumbers && !sawLineNumbers && result.push({
                    className: "CodeMirror-linenumbers",
                    style: null
                }), result;
            }
            // Rebuild the gutter elements, ensure the margin to the left of the
            // code matches their width.
            function renderGutters(display) {
                var gutters = display.gutters, specs = display.gutterSpecs;
                removeChildren(gutters), display.lineGutter = null;
                for (var i = 0; i < specs.length; ++i) {
                    var ref = specs[i], className = ref.className, style = ref.style, gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
                    style && (gElt.style.cssText = style), "CodeMirror-linenumbers" == className && (display.lineGutter = gElt, 
                    gElt.style.width = (display.lineNumWidth || 1) + "px");
                }
                gutters.style.display = specs.length ? "" : "none", updateGutterSpace(display);
            }
            function updateGutters(cm) {
                renderGutters(cm.display), regChange(cm), alignHorizontally(cm);
            }
            // The display handles the DOM integration, both for input reading
            // and content drawing. It holds references to DOM nodes and
            // display-related state.
            function Display(place, doc, input, options) {
                var d = this;
                this.input = input, // Covers bottom-right square when both scrollbars are present.
                d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"), d.scrollbarFiller.setAttribute("cm-not-content", "true"), 
                // Covers bottom of gutter when coverGutterNextToScrollbar is on
                // and h scrollbar is present.
                d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"), d.gutterFiller.setAttribute("cm-not-content", "true"), 
                // Will contain the actual code, positioned to cover the viewport.
                d.lineDiv = eltP("div", null, "CodeMirror-code"), // Elements are added to these to represent selection and cursors.
                d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"), d.cursorDiv = elt("div", null, "CodeMirror-cursors"), 
                // A visibility: hidden element used to find the size of things.
                d.measure = elt("div", null, "CodeMirror-measure"), // When lines outside of the viewport are measured, they are drawn in this.
                d.lineMeasure = elt("div", null, "CodeMirror-measure"), // Wraps everything that needs to exist inside the vertically-padded coordinate system
                d.lineSpace = eltP("div", [ d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv ], null, "position: relative; outline: none");
                var lines = eltP("div", [ d.lineSpace ], "CodeMirror-lines");
                // Moved around its parent to cover visible view.
                d.mover = elt("div", [ lines ], null, "position: relative"), // Set to the height of the document, allowing scrolling.
                d.sizer = elt("div", [ d.mover ], "CodeMirror-sizer"), d.sizerWidth = null, // Behavior of elts with overflow: auto and padding is
                // inconsistent across browsers. This is used to ensure the
                // scrollable area is big enough.
                d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"), 
                // Will contain the gutters, if any.
                d.gutters = elt("div", null, "CodeMirror-gutters"), d.lineGutter = null, // Actual scrollable element.
                d.scroller = elt("div", [ d.sizer, d.heightForcer, d.gutters ], "CodeMirror-scroll"), 
                d.scroller.setAttribute("tabIndex", "-1"), // The element in which the editor lives.
                d.wrapper = elt("div", [ d.scrollbarFiller, d.gutterFiller, d.scroller ], "CodeMirror"), 
                // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
                ie && ie_version < 8 && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0), 
                webkit || gecko && mobile || (d.scroller.draggable = !0), place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)), 
                // Current rendered range (may be bigger than the view window).
                d.viewFrom = d.viewTo = doc.first, d.reportedViewFrom = d.reportedViewTo = doc.first, 
                // Information about the rendered lines.
                d.view = [], d.renderedView = null, // Holds info about a single rendered line when it was rendered
                // for measurement, while not in view.
                d.externalMeasured = null, // Empty space (in pixels) above the view
                d.viewOffset = 0, d.lastWrapHeight = d.lastWrapWidth = 0, d.updateLineNumbers = null, 
                d.nativeBarWidth = d.barHeight = d.barWidth = 0, d.scrollbarsClipped = !1, // Used to only resize the line number gutter when necessary (when
                // the amount of lines crosses a boundary that makes its width change)
                d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null, // Set to true when a non-horizontal-scrolling line widget is
                // added. As an optimization, line widget aligning is skipped when
                // this is false.
                d.alignWidgets = !1, d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, 
                // Tracks the maximum line length so that the horizontal scrollbar
                // can be kept static when scrolling.
                d.maxLine = null, d.maxLineLength = 0, d.maxLineChanged = !1, // Used for measuring wheel scrolling granularity
                d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null, // True when shift is held down.
                d.shift = !1, // Used to track whether anything happened since the context menu
                // was opened.
                d.selForContextMenu = null, d.activeTouch = null, d.gutterSpecs = getGutters(options.gutters, options.lineNumbers), 
                renderGutters(d), input.init(d);
            }
            function wheelEventDelta(e) {
                var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
                return null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail), 
                null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta), 
                {
                    x: dx,
                    y: dy
                };
            }
            function wheelEventPixels(e) {
                var delta = wheelEventDelta(e);
                return delta.x *= wheelPixelsPerUnit, delta.y *= wheelPixelsPerUnit, delta;
            }
            function onScrollWheel(cm, e) {
                var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y, display = cm.display, scroll = display.scroller, canScrollX = scroll.scrollWidth > scroll.clientWidth, canScrollY = scroll.scrollHeight > scroll.clientHeight;
                if (dx && canScrollX || dy && canScrollY) {
                    // Webkit browsers on OS X abort momentum scrolls when the target
                    // of the scroll event is removed from the scrollable element.
                    // This hack (see related code in patchDisplay) makes sure the
                    // element is kept around.
                    if (dy && mac && webkit) outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) for (var i = 0; i < view.length; i++) if (view[i].node == cur) {
                        cm.display.currentWheelTarget = cur;
                        break outer;
                    }
                    // On some browsers, horizontal scrolling will cause redraws to
                    // happen before the gutter has been realigned, causing it to
                    // wriggle around in a most unseemly way. When we have an
                    // estimated pixels/delta value, we just handle horizontal
                    // scrolling entirely here. It'll be slightly off from native, but
                    // better than glitching out.
                    if (dx && !gecko && !presto && null != wheelPixelsPerUnit) // Abort measurement, if in progress
                    // Only prevent default scrolling if vertical scrolling is
                    // actually possible. Otherwise, it causes vertical scroll
                    // jitter on OSX trackpads when deltaX is small and deltaY
                    // is large (issue #3579)
                    return dy && canScrollY && updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)), 
                    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)), (!dy || dy && canScrollY) && e_preventDefault(e), 
                    void (display.wheelStartX = null);
                    // 'Project' the visible viewport to cover the area that is being
                    // scrolled into view (if we know enough to estimate it).
                    if (dy && null != wheelPixelsPerUnit) {
                        var pixels = dy * wheelPixelsPerUnit, top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                        pixels < 0 ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50), 
                        updateDisplaySimple(cm, {
                            top: top,
                            bottom: bot
                        });
                    }
                    wheelSamples < 20 && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft, 
                    display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = dy, 
                    setTimeout(function() {
                        if (null != display.wheelStartX) {
                            var movedX = scroll.scrollLeft - display.wheelStartX, movedY = scroll.scrollTop - display.wheelStartY, sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                            display.wheelStartX = display.wheelStartY = null, sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1), 
                            ++wheelSamples);
                        }
                    }, 200)) : (display.wheelDX += dx, display.wheelDY += dy));
                }
            }
            // Take an unsorted, potentially overlapping set of ranges, and
            // build a selection out of it. 'Consumes' ranges array (modifying
            // it).
            function normalizeSelection(cm, ranges, primIndex) {
                var mayTouch = cm && cm.options.selectionsMayTouch, prim = ranges[primIndex];
                ranges.sort(function(a, b) {
                    return cmp(a.from(), b.from());
                }), primIndex = indexOf(ranges, prim);
                for (var i = 1; i < ranges.length; i++) {
                    var cur = ranges[i], prev = ranges[i - 1], diff = cmp(prev.to(), cur.from());
                    if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
                        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to()), inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                        i <= primIndex && --primIndex, ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
                    }
                }
                return new Selection(ranges, primIndex);
            }
            function simpleSelection(anchor, head) {
                return new Selection([ new Range(anchor, head || anchor) ], 0);
            }
            // Compute the position of the end of a change (its 'to' property
            // refers to the pre-change end).
            function changeEnd(change) {
                return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to;
            }
            // Adjust a position to refer to the post-change position of the
            // same text, or the end of the change if the change covers it.
            function adjustForChange(pos, change) {
                if (cmp(pos, change.from) < 0) return pos;
                if (cmp(pos, change.to) <= 0) return changeEnd(change);
                var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
                return pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch), 
                Pos(line, ch);
            }
            function computeSelAfterChange(doc, change) {
                for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
                    var range = doc.sel.ranges[i];
                    out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
                }
                return normalizeSelection(doc.cm, out, doc.sel.primIndex);
            }
            function offsetPos(pos, old, nw) {
                return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch);
            }
            // Used by replaceSelections to allow moving the selection to the
            // start or around the replaced test. Hint may be "start" or "around".
            function computeReplacedSel(doc, changes, hint) {
                for (var out = [], oldPrev = Pos(doc.first, 0), newPrev = oldPrev, i = 0; i < changes.length; i++) {
                    var change = changes[i], from = offsetPos(change.from, oldPrev, newPrev), to = offsetPos(changeEnd(change), oldPrev, newPrev);
                    if (oldPrev = change.to, newPrev = to, "around" == hint) {
                        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                        out[i] = new Range(inv ? to : from, inv ? from : to);
                    } else out[i] = new Range(from, from);
                }
                return new Selection(out, doc.sel.primIndex);
            }
            // Used to get the editor into a consistent state again when options change.
            function loadMode(cm) {
                cm.doc.mode = getMode(cm.options, cm.doc.modeOption), resetModeState(cm);
            }
            function resetModeState(cm) {
                cm.doc.iter(function(line) {
                    line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null);
                }), cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first, startWorker(cm, 100), 
                cm.state.modeGen++, cm.curOp && regChange(cm);
            }
            // DOCUMENT DATA STRUCTURE
            // By default, updates that start and end at the beginning of a line
            // are treated specially, in order to make the association of line
            // widgets and marker elements with the text behave more intuitive.
            function isWholeLineUpdate(doc, change) {
                return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
            }
            // Perform a change on the document data structure.
            function updateDoc(doc, change, markedSpans, estimateHeight) {
                function spansFor(n) {
                    return markedSpans ? markedSpans[n] : null;
                }
                function update(line, text, spans) {
                    updateLine(line, text, spans, estimateHeight), signalLater(line, "change", line, change);
                }
                function linesFor(start, end) {
                    for (var result = [], i = start; i < end; ++i) result.push(new Line(text[i], spansFor(i), estimateHeight));
                    return result;
                }
                var from = change.from, to = change.to, text = change.text, firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line), lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
                // Adjust the line structure
                if (change.full) doc.insert(0, linesFor(0, text.length)), doc.remove(text.length, doc.size - text.length); else if (isWholeLineUpdate(doc, change)) {
                    // This is a whole-line replace. Treated specially to make
                    // sure line objects move the way they are supposed to.
                    var added = linesFor(0, text.length - 1);
                    update(lastLine, lastLine.text, lastSpans), nlines && doc.remove(from.line, nlines), 
                    added.length && doc.insert(from.line, added);
                } else if (firstLine == lastLine) if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans); else {
                    var added$1 = linesFor(1, text.length - 1);
                    added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight)), 
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), doc.insert(from.line + 1, added$1);
                } else if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)), 
                doc.remove(from.line + 1, nlines); else {
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                    var added$2 = linesFor(1, text.length - 1);
                    nlines > 1 && doc.remove(from.line + 1, nlines - 1), doc.insert(from.line + 1, added$2);
                }
                signalLater(doc, "change", doc, change);
            }
            // Call f for all linked documents.
            function linkedDocs(doc, f, sharedHistOnly) {
                function propagate(doc, skip, sharedHist) {
                    if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc != skip) {
                            var shared = sharedHist && rel.sharedHist;
                            sharedHistOnly && !shared || (f(rel.doc, shared), propagate(rel.doc, doc, shared));
                        }
                    }
                }
                propagate(doc, null, !0);
            }
            // Attach a document to an editor.
            function attachDoc(cm, doc) {
                if (doc.cm) throw new Error("This document is already in use.");
                cm.doc = doc, doc.cm = cm, estimateLineHeights(cm), loadMode(cm), setDirectionClass(cm), 
                cm.options.lineWrapping || findMaxLine(cm), cm.options.mode = doc.modeOption, regChange(cm);
            }
            function setDirectionClass(cm) {
                ("rtl" == cm.doc.direction ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
            }
            function directionChanged(cm) {
                runInOp(cm, function() {
                    setDirectionClass(cm), regChange(cm);
                });
            }
            function History(startGen) {
                // Arrays of change events and selections. Doing something adds an
                // event to done and clears undo. Undoing moves events from done
                // to undone, redoing moves them in the other direction.
                this.done = [], this.undone = [], this.undoDepth = 1 / 0, // Used to track when changes can be merged into a single undo
                // event
                this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, 
                // Used by the isClean() method
                this.generation = this.maxGeneration = startGen || 1;
            }
            // Create a history change event from an updateDoc-style change
            // object.
            function historyChangeFromChange(doc, change) {
                var histChange = {
                    from: copyPos(change.from),
                    to: changeEnd(change),
                    text: getBetween(doc, change.from, change.to)
                };
                return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), 
                linkedDocs(doc, function(doc) {
                    return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
                }, !0), histChange;
            }
            // Pop all selection events off the end of a history array. Stop at
            // a change event.
            function clearSelectionEvents(array) {
                for (;array.length; ) {
                    var last = lst(array);
                    if (!last.ranges) break;
                    array.pop();
                }
            }
            // Find the top change event in the history. Pop off selection
            // events that are in the way.
            function lastChangeEvent(hist, force) {
                return force ? (clearSelectionEvents(hist.done), lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(), 
                lst(hist.done)) : void 0;
            }
            // Register a change in the history. Merges changes that are within
            // a single operation, or are close together with an origin that
            // allows merging (starting with "+") into a single event.
            function addChangeToHistory(doc, change, selAfter, opId) {
                var hist = doc.history;
                hist.undone.length = 0;
                var cur, last, time = +new Date();
                if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) // Merge this change into the last event
                last = lst(cur.changes), 0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? // Optimized case for simple insertion -- don't want to add
                // new changesets for every character typed
                last.to = changeEnd(change) : // Add new sub-event
                cur.changes.push(historyChangeFromChange(doc, change)); else {
                    // Can not be merged, start a new event.
                    var before = lst(hist.done);
                    for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done), cur = {
                        changes: [ historyChangeFromChange(doc, change) ],
                        generation: hist.generation
                    }, hist.done.push(cur); hist.done.length > hist.undoDepth; ) hist.done.shift(), 
                    hist.done[0].ranges || hist.done.shift();
                }
                hist.done.push(selAfter), hist.generation = ++hist.maxGeneration, hist.lastModTime = hist.lastSelTime = time, 
                hist.lastOp = hist.lastSelOp = opId, hist.lastOrigin = hist.lastSelOrigin = change.origin, 
                last || signal(doc, "historyAdded");
            }
            function selectionEventCanBeMerged(doc, origin, prev, sel) {
                var ch = origin.charAt(0);
                return "*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
            }
            // Called whenever the selection changes, sets the new selection as
            // the pending selection in the history, and pushes the old pending
            // selection into the 'done' array when it was significantly
            // different (in number of selected ranges, emptiness, or time).
            function addSelectionToHistory(doc, sel, opId, options) {
                var hist = doc.history, origin = options && options.origin;
                // A new event is started when the previous origin does not match
                // the current, or the origins don't allow matching. Origins
                // starting with * are always merged, those starting with + are
                // merged when similar and close together in time.
                opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done), 
                hist.lastSelTime = +new Date(), hist.lastSelOrigin = origin, hist.lastSelOp = opId, 
                options && options.clearRedo !== !1 && clearSelectionEvents(hist.undone);
            }
            function pushSelectionToHistory(sel, dest) {
                var top = lst(dest);
                top && top.ranges && top.equals(sel) || dest.push(sel);
            }
            // Used to store marked span information in the history.
            function attachLocalSpans(doc, change, from, to) {
                var existing = change["spans_" + doc.id], n = 0;
                doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
                    line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans), 
                    ++n;
                });
            }
            // When un/re-doing restores text containing marked spans, those
            // that have been explicitly cleared should not be restored.
            function removeClearedSpans(spans) {
                if (!spans) return null;
                for (var out, i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
                return out ? out.length ? out : null : spans;
            }
            // Retrieve and filter the old marked spans stored in a change event.
            function getOldSpans(doc, change) {
                var found = change["spans_" + doc.id];
                if (!found) return null;
                for (var nw = [], i = 0; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
                return nw;
            }
            // Used for un/re-doing changes from the history. Combines the
            // result of computing the existing spans with the set of spans that
            // existed in the history (so that deleting around a span and then
            // undoing brings back the span).
            function mergeOldSpans(doc, change) {
                var old = getOldSpans(doc, change), stretched = stretchSpansOverChange(doc, change);
                if (!old) return stretched;
                if (!stretched) return old;
                for (var i = 0; i < old.length; ++i) {
                    var oldCur = old[i], stretchCur = stretched[i];
                    if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j) {
                        for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k) if (oldCur[k].marker == span.marker) continue spans;
                        oldCur.push(span);
                    } else stretchCur && (old[i] = stretchCur);
                }
                return old;
            }
            // Used both to provide a JSON-safe object in .getHistory, and, when
            // detaching a document, to split the history in two
            function copyHistoryArray(events, newGroup, instantiateSel) {
                for (var copy = [], i = 0; i < events.length; ++i) {
                    var event = events[i];
                    if (event.ranges) copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event); else {
                        var changes = event.changes, newChanges = [];
                        copy.push({
                            changes: newChanges
                        });
                        for (var j = 0; j < changes.length; ++j) {
                            var change = changes[j], m = void 0;
                            if (newChanges.push({
                                from: change.from,
                                to: change.to,
                                text: change.text
                            }), newGroup) for (var prop in change) (m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop], 
                            delete change[prop]);
                        }
                    }
                }
                return copy;
            }
            // The 'scroll' parameter given to many of these indicated whether
            // the new cursor position should be scrolled into view after
            // modifying the selection.
            // If shift is held or the extend flag is set, extends a range to
            // include a given position (and optionally a second position).
            // Otherwise, simply returns the range between the given positions.
            // Used for cursor motion and such.
            function extendRange(range, head, other, extend) {
                if (extend) {
                    var anchor = range.anchor;
                    if (other) {
                        var posBefore = cmp(head, anchor) < 0;
                        posBefore != cmp(other, anchor) < 0 ? (anchor = head, head = other) : posBefore != cmp(head, other) < 0 && (head = other);
                    }
                    return new Range(anchor, head);
                }
                return new Range(other || head, head);
            }
            // Extend the primary selection range, discard the rest.
            function extendSelection(doc, head, other, options, extend) {
                null == extend && (extend = doc.cm && (doc.cm.display.shift || doc.extend)), setSelection(doc, new Selection([ extendRange(doc.sel.primary(), head, other, extend) ], 0), options);
            }
            // Extend all selections (pos is an array of selections with length
            // equal the number of selections)
            function extendSelections(doc, heads, options) {
                for (var out = [], extend = doc.cm && (doc.cm.display.shift || doc.extend), i = 0; i < doc.sel.ranges.length; i++) out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
                var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
                setSelection(doc, newSel, options);
            }
            // Updates a single range in the selection.
            function replaceOneSelection(doc, i, range, options) {
                var ranges = doc.sel.ranges.slice(0);
                ranges[i] = range, setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
            }
            // Reset the selection to a single range.
            function setSimpleSelection(doc, anchor, head, options) {
                setSelection(doc, simpleSelection(anchor, head), options);
            }
            // Give beforeSelectionChange handlers a change to influence a
            // selection update.
            function filterSelectionChange(doc, sel, options) {
                var obj = {
                    ranges: sel.ranges,
                    update: function(ranges) {
                        this.ranges = [];
                        for (var i = 0; i < ranges.length; i++) this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
                    },
                    origin: options && options.origin
                };
                return signal(doc, "beforeSelectionChange", doc, obj), doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj), 
                obj.ranges != sel.ranges ? normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) : sel;
            }
            function setSelectionReplaceHistory(doc, sel, options) {
                var done = doc.history.done, last = lst(done);
                last && last.ranges ? (done[done.length - 1] = sel, setSelectionNoUndo(doc, sel, options)) : setSelection(doc, sel, options);
            }
            // Set a new selection.
            function setSelection(doc, sel, options) {
                setSelectionNoUndo(doc, sel, options), addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
            }
            function setSelectionNoUndo(doc, sel, options) {
                (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel, options));
                var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
                setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, !0)), options && options.scroll === !1 || !doc.cm || ensureCursorVisible(doc.cm);
            }
            function setSelectionInner(doc, sel) {
                sel.equals(doc.sel) || (doc.sel = sel, doc.cm && (doc.cm.curOp.updateInput = 1, 
                doc.cm.curOp.selectionChanged = !0, signalCursorActivity(doc.cm)), signalLater(doc, "cursorActivity", doc));
            }
            // Verify that the selection does not partially select any atomic
            // marked ranges.
            function reCheckSelection(doc) {
                setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1));
            }
            // Return a selection that does not partially select any atomic
            // ranges.
            function skipAtomicInSelection(doc, sel, bias, mayClear) {
                for (var out, i = 0; i < sel.ranges.length; i++) {
                    var range = sel.ranges[i], old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i], newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear), newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
                    (out || newAnchor != range.anchor || newHead != range.head) && (out || (out = sel.ranges.slice(0, i)), 
                    out[i] = new Range(newAnchor, newHead));
                }
                return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
            }
            function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
                var line = getLine(doc, pos.line);
                if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i], m = sp.marker, preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft, preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
                    if ((null == sp.from || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (null == sp.to || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                        if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                            if (line.markedSpans) {
                                --i;
                                continue;
                            }
                            break;
                        }
                        if (!m.atomic) continue;
                        if (oldPos) {
                            var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                            if ((dir < 0 ? preventCursorRight : preventCursorLeft) && (near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null)), 
                            near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) return skipAtomicInner(doc, near, pos, dir, mayClear);
                        }
                        var far = m.find(dir < 0 ? -1 : 1);
                        return (dir < 0 ? preventCursorLeft : preventCursorRight) && (far = movePos(doc, far, dir, far.line == pos.line ? line : null)), 
                        far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
                    }
                }
                return pos;
            }
            // Ensure a given position is not inside an atomic range.
            function skipAtomic(doc, pos, oldPos, bias, mayClear) {
                var dir = bias || 1, found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, !0) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, !0);
                return found ? found : (doc.cantEdit = !0, Pos(doc.first, 0));
            }
            function movePos(doc, pos, dir, line) {
                return dir < 0 && 0 == pos.ch ? pos.line > doc.first ? clipPos(doc, Pos(pos.line - 1)) : null : dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length ? pos.line < doc.first + doc.size - 1 ? Pos(pos.line + 1, 0) : null : new Pos(pos.line, pos.ch + dir);
            }
            function selectAll(cm) {
                cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
            }
            // UPDATING
            // Allow "beforeChange" event handlers to influence a change
            function filterChange(doc, change, update) {
                var obj = {
                    canceled: !1,
                    from: change.from,
                    to: change.to,
                    text: change.text,
                    origin: change.origin,
                    cancel: function() {
                        return obj.canceled = !0;
                    }
                };
                return update && (obj.update = function(from, to, text, origin) {
                    from && (obj.from = clipPos(doc, from)), to && (obj.to = clipPos(doc, to)), text && (obj.text = text), 
                    void 0 !== origin && (obj.origin = origin);
                }), signal(doc, "beforeChange", doc, obj), doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj), 
                obj.canceled ? (doc.cm && (doc.cm.curOp.updateInput = 2), null) : {
                    from: obj.from,
                    to: obj.to,
                    text: obj.text,
                    origin: obj.origin
                };
            }
            // Apply a change to a document, and add it to the document's
            // history, and propagating it to all linked documents.
            function makeChange(doc, change, ignoreReadOnly) {
                if (doc.cm) {
                    if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
                    if (doc.cm.state.suppressEdits) return;
                }
                if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
                    // Possibly split or suppress the update based on the presence
                    // of read-only spans in its range.
                    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
                    if (split) for (var i = split.length - 1; i >= 0; --i) makeChangeInner(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: i ? [ "" ] : change.text,
                        origin: change.origin
                    }); else makeChangeInner(doc, change);
                }
            }
            function makeChangeInner(doc, change) {
                if (1 != change.text.length || "" != change.text[0] || 0 != cmp(change.from, change.to)) {
                    var selAfter = computeSelAfterChange(doc, change);
                    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN), makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
                    var rebased = [];
                    linkedDocs(doc, function(doc, sharedHist) {
                        sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), 
                        rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
                    });
                }
            }
            // Revert a change stored in a document's history.
            function makeChangeFromHistory(doc, type, allowSelectionOnly) {
                var suppress = doc.cm && doc.cm.state.suppressEdits;
                if (!suppress || allowSelectionOnly) {
                    for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i], 
                    allowSelectionOnly ? !event.ranges || event.equals(doc.sel) : event.ranges); i++) ;
                    if (i != source.length) {
                        for (hist.lastOrigin = hist.lastSelOrigin = null; ;) {
                            if (event = source.pop(), !event.ranges) {
                                if (suppress) return void source.push(event);
                                break;
                            }
                            if (pushSelectionToHistory(event, dest), allowSelectionOnly && !event.equals(doc.sel)) return void setSelection(doc, event, {
                                clearRedo: !1
                            });
                            selAfter = event;
                        }
                        // Build up a reverse change object to add to the opposite history
                        // stack (redo when undoing, and vice versa).
                        var antiChanges = [];
                        pushSelectionToHistory(selAfter, dest), dest.push({
                            changes: antiChanges,
                            generation: hist.generation
                        }), hist.generation = event.generation || ++hist.maxGeneration;
                        for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), loop = function(i) {
                            var change = event.changes[i];
                            if (change.origin = type, filter && !filterChange(doc, change, !1)) return source.length = 0, 
                            {};
                            antiChanges.push(historyChangeFromChange(doc, change));
                            var after = i ? computeSelAfterChange(doc, change) : lst(source);
                            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)), !i && doc.cm && doc.cm.scrollIntoView({
                                from: change.from,
                                to: changeEnd(change)
                            });
                            var rebased = [];
                            // Propagate to the linked documents
                            linkedDocs(doc, function(doc, sharedHist) {
                                sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), 
                                rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                            });
                        }, i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
                            var returned = loop(i$1);
                            if (returned) return returned.v;
                        }
                    }
                }
            }
            // Sub-views need their line numbers shifted when text is added
            // above or below them in the parent document.
            function shiftDoc(doc, distance) {
                if (0 != distance && (doc.first += distance, doc.sel = new Selection(map(doc.sel.ranges, function(range) {
                    return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
                }), doc.sel.primIndex), doc.cm)) {
                    regChange(doc.cm, doc.first, doc.first - distance, distance);
                    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) regLineChange(doc.cm, l, "gutter");
                }
            }
            // More lower-level change function, handling only a single document
            // (not linked ones).
            function makeChangeSingleDoc(doc, change, selAfter, spans) {
                if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
                if (change.to.line < doc.first) return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
                if (!(change.from.line > doc.lastLine())) {
                    // Clip the change to the size of this doc
                    if (change.from.line < doc.first) {
                        var shift = change.text.length - 1 - (doc.first - change.from.line);
                        shiftDoc(doc, shift), change = {
                            from: Pos(doc.first, 0),
                            to: Pos(change.to.line + shift, change.to.ch),
                            text: [ lst(change.text) ],
                            origin: change.origin
                        };
                    }
                    var last = doc.lastLine();
                    change.to.line > last && (change = {
                        from: change.from,
                        to: Pos(last, getLine(doc, last).text.length),
                        text: [ change.text[0] ],
                        origin: change.origin
                    }), change.removed = getBetween(doc, change.from, change.to), selAfter || (selAfter = computeSelAfterChange(doc, change)), 
                    doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans), 
                    setSelectionNoUndo(doc, selAfter, sel_dontScroll), doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)) && (doc.cantEdit = !1);
                }
            }
            // Handle the interaction of a change to a document with the editor
            // that this document is part of.
            function makeChangeSingleDocInEditor(cm, change, spans) {
                var doc = cm.doc, display = cm.display, from = change.from, to = change.to, recomputeMaxLength = !1, checkWidthStart = from.line;
                cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))), 
                doc.iter(checkWidthStart, to.line + 1, function(line) {
                    if (line == display.maxLine) return recomputeMaxLength = !0, !0;
                })), doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm), 
                updateDoc(doc, change, spans, estimateHeight(cm)), cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
                    var len = lineLength(line);
                    len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len, 
                    display.maxLineChanged = !0, recomputeMaxLength = !1);
                }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0)), retreatFrontier(doc, from.line), 
                startWorker(cm, 400);
                var lendiff = change.text.length - (to.line - from.line) - 1;
                // Remember that these lines changed, for updating the display
                change.full ? regChange(cm) : from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
                var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
                if (changeHandler || changesHandler) {
                    var obj = {
                        from: from,
                        to: to,
                        text: change.text,
                        removed: change.removed,
                        origin: change.origin
                    };
                    changeHandler && signalLater(cm, "change", cm, obj), changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
                }
                cm.display.selForContextMenu = null;
            }
            function replaceRange(doc, code, from, to, origin) {
                var assign;
                to || (to = from), cmp(to, from) < 0 && (assign = [ to, from ], from = assign[0], 
                to = assign[1]), "string" == typeof code && (code = doc.splitLines(code)), makeChange(doc, {
                    from: from,
                    to: to,
                    text: code,
                    origin: origin
                });
            }
            // Rebasing/resetting history to deal with externally-sourced changes
            function rebaseHistSelSingle(pos, from, to, diff) {
                to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, pos.ch = 0);
            }
            // Tries to rebase an array of history events given a change in the
            // document. If the change touches the same lines as the event, the
            // event, and everything 'behind' it, is discarded. If the change is
            // before the event, the event's positions are updated. Uses a
            // copy-on-write scheme for the positions, to avoid having to
            // reallocate them all on every rebase, but also avoid problems with
            // shared position objects being unsafely updated.
            function rebaseHistArray(array, from, to, diff) {
                for (var i = 0; i < array.length; ++i) {
                    var sub = array[i], ok = !0;
                    if (sub.ranges) {
                        sub.copied || (sub = array[i] = sub.deepCopy(), sub.copied = !0);
                        for (var j = 0; j < sub.ranges.length; j++) rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff), 
                        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                    } else {
                        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
                            var cur = sub.changes[j$1];
                            if (to < cur.from.line) cur.from = Pos(cur.from.line + diff, cur.from.ch), cur.to = Pos(cur.to.line + diff, cur.to.ch); else if (from <= cur.to.line) {
                                ok = !1;
                                break;
                            }
                        }
                        ok || (array.splice(0, i + 1), i = 0);
                    }
                }
            }
            function rebaseHist(hist, change) {
                var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
                rebaseHistArray(hist.done, from, to, diff), rebaseHistArray(hist.undone, from, to, diff);
            }
            // Utility for applying a change to a line by handle or number,
            // returning the number and optionally registering the line as
            // changed.
            function changeLine(doc, handle, changeType, op) {
                var no = handle, line = handle;
                return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle), 
                null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType), 
                line);
            }
            // The document is represented as a BTree consisting of leaves, with
            // chunk of lines in them, and branches, with up to ten leaves or
            // other branch nodes below them. The top node is always a branch
            // node, and is the document object itself (meaning it has
            // additional methods and properties).
            //
            // All nodes have parent links. The tree is used both to go from
            // line numbers to line objects, and to go from objects to numbers.
            // It also indexes by height, and is used to convert between height
            // and line object, and to find the total height of the document.
            //
            // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
            function LeafChunk(lines) {
                this.lines = lines, this.parent = null;
                for (var height = 0, i = 0; i < lines.length; ++i) lines[i].parent = this, height += lines[i].height;
                this.height = height;
            }
            function BranchChunk(children) {
                this.children = children;
                for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    size += ch.chunkSize(), height += ch.height, ch.parent = this;
                }
                this.size = size, this.height = height, this.parent = null;
            }
            function adjustScrollWhenAboveVisible(cm, line, diff) {
                heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollTop(cm, diff);
            }
            function addLineWidget(doc, handle, node, options) {
                var widget = new LineWidget(doc, node, options), cm = doc.cm;
                return cm && widget.noHScroll && (cm.display.alignWidgets = !0), changeLine(doc, handle, "widget", function(line) {
                    var widgets = line.widgets || (line.widgets = []);
                    if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget), 
                    widget.line = line, cm && !lineIsHidden(doc, line)) {
                        var aboveVisible = heightAtLine(line) < doc.scrollTop;
                        updateLineHeight(line, line.height + widgetHeight(widget)), aboveVisible && addToScrollTop(cm, widget.height), 
                        cm.curOp.forceUpdate = !0;
                    }
                    return !0;
                }), cm && signalLater(cm, "lineWidgetAdded", cm, widget, "number" == typeof handle ? handle : lineNo(handle)), 
                widget;
            }
            // Create a marker, wire it up to the right lines, and
            function markText(doc, from, to, options, type) {
                // Shared markers (across linked documents) are handled separately
                // (markTextShared will call out to this again, once per
                // document).
                if (options && options.shared) return markTextShared(doc, from, to, options, type);
                // Ensure we are in an operation.
                if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);
                var marker = new TextMarker(doc, type), diff = cmp(from, to);
                // Don't connect empty markers unless clearWhenEmpty is false
                if (options && copyObj(options, marker, !1), diff > 0 || 0 == diff && marker.clearWhenEmpty !== !1) return marker;
                if (marker.replacedWith && (// Showing up as a widget implies collapsed (widget replaces text)
                marker.collapsed = !0, marker.widgetNode = eltP("span", [ marker.replacedWith ], "CodeMirror-widget"), 
                options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true"), 
                options.insertLeft && (marker.widgetNode.insertLeft = !0)), marker.collapsed) {
                    if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
                    seeCollapsedSpans();
                }
                marker.addToHistory && addChangeToHistory(doc, {
                    from: from,
                    to: to,
                    origin: "markText"
                }, doc.sel, NaN);
                var updateMaxLine, curLine = from.line, cm = doc.cm;
                if (doc.iter(curLine, to.line + 1, function(line) {
                    cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0), 
                    marker.collapsed && curLine != from.line && updateLineHeight(line, 0), addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null)), 
                    ++curLine;
                }), // lineIsHidden depends on the presence of the spans, so needs a second pass
                marker.collapsed && doc.iter(from.line, to.line + 1, function(line) {
                    lineIsHidden(doc, line) && updateLineHeight(line, 0);
                }), marker.clearOnEnter && on(marker, "beforeCursorEnter", function() {
                    return marker.clear();
                }), marker.readOnly && (seeReadOnlySpans(), (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()), 
                marker.collapsed && (marker.id = ++nextMarkerId, marker.atomic = !0), cm) {
                    if (// Sync editor state
                    updateMaxLine && (cm.curOp.updateMaxLine = !0), marker.collapsed) regChange(cm, from.line, to.line + 1); else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
                    marker.atomic && reCheckSelection(cm.doc), signalLater(cm, "markerAdded", cm, marker);
                }
                return marker;
            }
            function markTextShared(doc, from, to, options, type) {
                options = copyObj(options), options.shared = !1;
                var markers = [ markText(doc, from, to, options, type) ], primary = markers[0], widget = options.widgetNode;
                return linkedDocs(doc, function(doc) {
                    widget && (options.widgetNode = widget.cloneNode(!0)), markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                    for (var i = 0; i < doc.linked.length; ++i) if (doc.linked[i].isParent) return;
                    primary = lst(markers);
                }), new SharedTextMarker(markers, primary);
            }
            function findSharedMarkers(doc) {
                return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
                    return m.parent;
                });
            }
            function copySharedMarkers(doc, markers) {
                for (var i = 0; i < markers.length; i++) {
                    var marker = markers[i], pos = marker.find(), mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
                    if (cmp(mFrom, mTo)) {
                        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                        marker.markers.push(subMark), subMark.parent = marker;
                    }
                }
            }
            function detachSharedMarkers(markers) {
                for (var loop = function(i) {
                    var marker = markers[i], linked = [ marker.primary.doc ];
                    linkedDocs(marker.primary.doc, function(d) {
                        return linked.push(d);
                    });
                    for (var j = 0; j < marker.markers.length; j++) {
                        var subMarker = marker.markers[j];
                        indexOf(linked, subMarker.doc) == -1 && (subMarker.parent = null, marker.markers.splice(j--, 1));
                    }
                }, i = 0; i < markers.length; i++) loop(i);
            }
            function onDrop(e) {
                var cm = this;
                if (clearDragCursor(cm), !signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
                    e_preventDefault(e), ie && (lastDrop = +new Date());
                    var pos = posFromMouse(cm, e, !0), files = e.dataTransfer.files;
                    if (pos && !cm.isReadOnly()) // Might be a file drop, in which case we simply extract the text
                    // and insert it.
                    if (files && files.length && window.FileReader && window.File) for (var n = files.length, text = Array(n), read = 0, markAsReadAndPasteIfAllFilesAreRead = function() {
                        ++read == n && operation(cm, function() {
                            pos = clipPos(cm.doc, pos);
                            var change = {
                                from: pos,
                                to: pos,
                                text: cm.doc.splitLines(text.filter(function(t) {
                                    return null != t;
                                }).join(cm.doc.lineSeparator())),
                                origin: "paste"
                            };
                            makeChange(cm.doc, change), setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
                        })();
                    }, readTextFromFile = function(file, i) {
                        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) return void markAsReadAndPasteIfAllFilesAreRead();
                        var reader = new FileReader();
                        reader.onerror = function() {
                            return markAsReadAndPasteIfAllFilesAreRead();
                        }, reader.onload = function() {
                            var content = reader.result;
                            return /[\x00-\x08\x0e-\x1f]{2}/.test(content) ? void markAsReadAndPasteIfAllFilesAreRead() : (text[i] = content, 
                            void markAsReadAndPasteIfAllFilesAreRead());
                        }, reader.readAsText(file);
                    }, i = 0; i < files.length; i++) readTextFromFile(files[i], i); else {
                        // Normal drop
                        // Don't do a replace if the drop happened inside of the selected text.
                        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) // Ensure the editor is re-focused
                        return cm.state.draggingText(e), void setTimeout(function() {
                            return cm.display.input.focus();
                        }, 20);
                        try {
                            var text$1 = e.dataTransfer.getData("Text");
                            if (text$1) {
                                var selected;
                                if (cm.state.draggingText && !cm.state.draggingText.copy && (selected = cm.listSelections()), 
                                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)), selected) for (var i$1 = 0; i$1 < selected.length; ++i$1) replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                                cm.replaceSelection(text$1, "around", "paste"), cm.display.input.focus();
                            }
                        } catch (e$1) {}
                    }
                }
            }
            function onDragStart(cm, e) {
                if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) return void e_stop(e);
                if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e) && (e.dataTransfer.setData("Text", cm.getSelection()), 
                e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !safari)) {
                    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
                    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", 
                    presto && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), // Force a relayout, or Opera won't use our image for some obscure reason
                    img._top = img.offsetTop), e.dataTransfer.setDragImage(img, 0, 0), presto && img.parentNode.removeChild(img);
                }
            }
            function onDragOver(cm, e) {
                var pos = posFromMouse(cm, e);
                if (pos) {
                    var frag = document.createDocumentFragment();
                    drawSelectionCursor(cm, pos, frag), cm.display.dragCursor || (cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), 
                    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)), 
                    removeChildrenAndAdd(cm.display.dragCursor, frag);
                }
            }
            function clearDragCursor(cm) {
                cm.display.dragCursor && (cm.display.lineSpace.removeChild(cm.display.dragCursor), 
                cm.display.dragCursor = null);
            }
            // These must be handled carefully, because naively registering a
            // handler for each editor will cause the editors to never be
            // garbage collected.
            function forEachCodeMirror(f) {
                if (document.getElementsByClassName) {
                    for (var byClass = document.getElementsByClassName("CodeMirror"), editors = [], i = 0; i < byClass.length; i++) {
                        var cm = byClass[i].CodeMirror;
                        cm && editors.push(cm);
                    }
                    editors.length && editors[0].operation(function() {
                        for (var i = 0; i < editors.length; i++) f(editors[i]);
                    });
                }
            }
            function ensureGlobalHandlers() {
                globalsRegistered || (registerGlobalHandlers(), globalsRegistered = !0);
            }
            function registerGlobalHandlers() {
                // When the window resizes, we need to refresh active editors.
                var resizeTimer;
                on(window, "resize", function() {
                    null == resizeTimer && (resizeTimer = setTimeout(function() {
                        resizeTimer = null, forEachCodeMirror(onResize);
                    }, 100));
                }), // When the window loses focus, we want to show the editor as blurred
                on(window, "blur", function() {
                    return forEachCodeMirror(onBlur);
                });
            }
            // Called when the window resizes
            function onResize(cm) {
                var d = cm.display;
                // Might be a text scaling operation, clear size caches.
                d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, d.scrollbarsClipped = !1, 
                cm.setSize();
            }
            // KEYMAP DISPATCH
            function normalizeKeyName(name) {
                var parts = name.split(/-(?!$)/);
                name = parts[parts.length - 1];
                for (var alt, ctrl, shift, cmd, i = 0; i < parts.length - 1; i++) {
                    var mod = parts[i];
                    if (/^(cmd|meta|m)$/i.test(mod)) cmd = !0; else if (/^a(lt)?$/i.test(mod)) alt = !0; else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = !0; else {
                        if (!/^s(hift)?$/i.test(mod)) throw new Error("Unrecognized modifier name: " + mod);
                        shift = !0;
                    }
                }
                return alt && (name = "Alt-" + name), ctrl && (name = "Ctrl-" + name), cmd && (name = "Cmd-" + name), 
                shift && (name = "Shift-" + name), name;
            }
            // This is a kludge to keep keymaps mostly working as raw objects
            // (backwards compatibility) while at the same time support features
            // like normalization and multi-stroke key bindings. It compiles a
            // new normalized keymap, and then updates the old object to reflect
            // this.
            function normalizeKeyMap(keymap) {
                var copy = {};
                for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
                    var value = keymap[keyname];
                    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
                    if ("..." == value) {
                        delete keymap[keyname];
                        continue;
                    }
                    for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                        var val = void 0, name = void 0;
                        i == keys.length - 1 ? (name = keys.join(" "), val = value) : (name = keys.slice(0, i + 1).join(" "), 
                        val = "...");
                        var prev = copy[name];
                        if (prev) {
                            if (prev != val) throw new Error("Inconsistent bindings for " + name);
                        } else copy[name] = val;
                    }
                    delete keymap[keyname];
                }
                for (var prop in copy) keymap[prop] = copy[prop];
                return keymap;
            }
            function lookupKey(key, map, handle, context) {
                map = getKeyMap(map);
                var found = map.call ? map.call(key, context) : map[key];
                if (found === !1) return "nothing";
                if ("..." === found) return "multi";
                if (null != found && handle(found)) return "handled";
                if (map.fallthrough) {
                    if ("[object Array]" != Object.prototype.toString.call(map.fallthrough)) return lookupKey(key, map.fallthrough, handle, context);
                    for (var i = 0; i < map.fallthrough.length; i++) {
                        var result = lookupKey(key, map.fallthrough[i], handle, context);
                        if (result) return result;
                    }
                }
            }
            // Modifier key presses don't count as 'real' key presses for the
            // purpose of keymap fallthrough.
            function isModifierKey(value) {
                var name = "string" == typeof value ? value : keyNames[value.keyCode];
                return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name;
            }
            function addModifierNames(name, event, noShift) {
                var base = name;
                return event.altKey && "Alt" != base && (name = "Alt-" + name), (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name), 
                (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Mod" != base && (name = "Cmd-" + name), 
                !noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name), name;
            }
            // Look up the name of a key as indicated by an event object.
            function keyName(event, noShift) {
                if (presto && 34 == event.keyCode && event.char) return !1;
                var name = keyNames[event.keyCode];
                // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
                // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
                return null != name && !event.altGraphKey && (3 == event.keyCode && event.code && (name = event.code), 
                addModifierNames(name, event, noShift));
            }
            function getKeyMap(val) {
                return "string" == typeof val ? keyMap[val] : val;
            }
            // Helper for deleting text near the selection(s), used to implement
            // backspace, delete, and similar functionality.
            function deleteNearSelection(cm, compute) {
                // Build up a set of ranges to kill first, merging overlapping
                // ranges.
                for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
                    for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0; ) {
                        var replaced = kill.pop();
                        if (cmp(replaced.from, toKill.from) < 0) {
                            toKill.from = replaced.from;
                            break;
                        }
                    }
                    kill.push(toKill);
                }
                // Next, remove those actual ranges.
                runInOp(cm, function() {
                    for (var i = kill.length - 1; i >= 0; i--) replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
                    ensureCursorVisible(cm);
                });
            }
            function moveCharLogically(line, ch, dir) {
                var target = skipExtendingChars(line.text, ch + dir, dir);
                return target < 0 || target > line.text.length ? null : target;
            }
            function moveLogically(line, start, dir) {
                var ch = moveCharLogically(line, start.ch, dir);
                return null == ch ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
            }
            function endOfLine(visually, cm, lineObj, lineNo, dir) {
                if (visually) {
                    "rtl" == cm.doc.direction && (dir = -dir);
                    var order = getOrder(lineObj, cm.doc.direction);
                    if (order) {
                        var ch, part = dir < 0 ? lst(order) : order[0], moveInStorageOrder = dir < 0 == (1 == part.level), sticky = moveInStorageOrder ? "after" : "before";
                        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
                        // it could be that the last bidi part is not on the last visual line,
                        // since visual lines contain content order-consecutive chunks.
                        // Thus, in rtl, we are looking for the first (content-order) character
                        // in the rtl chunk that is on the last line (that is, the same line
                        // as the last (content-order) character).
                        if (part.level > 0 || "rtl" == cm.doc.direction) {
                            var prep = prepareMeasureForLine(cm, lineObj);
                            ch = dir < 0 ? lineObj.text.length - 1 : 0;
                            var targetTop = measureCharPrepared(cm, prep, ch).top;
                            ch = findFirst(function(ch) {
                                return measureCharPrepared(cm, prep, ch).top == targetTop;
                            }, dir < 0 == (1 == part.level) ? part.from : part.to - 1, ch), "before" == sticky && (ch = moveCharLogically(lineObj, ch, 1));
                        } else ch = dir < 0 ? part.to : part.from;
                        return new Pos(lineNo, ch, sticky);
                    }
                }
                return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
            }
            function moveVisually(cm, line, start, dir) {
                var bidi = getOrder(line, cm.doc.direction);
                if (!bidi) return moveLogically(line, start, dir);
                start.ch >= line.text.length ? (start.ch = line.text.length, start.sticky = "before") : start.ch <= 0 && (start.ch = 0, 
                start.sticky = "after");
                var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
                if ("ltr" == cm.doc.direction && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
                // nothing interesting happens.
                return moveLogically(line, start, dir);
                var prep, mv = function(pos, dir) {
                    return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
                }, getWrappedLineExtent = function(ch) {
                    return cm.options.lineWrapping ? (prep = prep || prepareMeasureForLine(cm, line), 
                    wrappedLineExtentChar(cm, line, prep, ch)) : {
                        begin: 0,
                        end: line.text.length
                    };
                }, wrappedLineExtent = getWrappedLineExtent("before" == start.sticky ? mv(start, -1) : start.ch);
                if ("rtl" == cm.doc.direction || 1 == part.level) {
                    var moveInStorageOrder = 1 == part.level == dir < 0, ch = mv(start, moveInStorageOrder ? 1 : -1);
                    if (null != ch && (moveInStorageOrder ? ch <= part.to && ch <= wrappedLineExtent.end : ch >= part.from && ch >= wrappedLineExtent.begin)) {
                        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
                        var sticky = moveInStorageOrder ? "before" : "after";
                        return new Pos(start.line, ch, sticky);
                    }
                }
                // Case 3: Could not move within this bidi part in this visual line, so leave
                // the current bidi part
                var searchInVisualLine = function(partPos, dir, wrappedLineExtent) {
                    for (var getRes = function(ch, moveInStorageOrder) {
                        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
                    }; partPos >= 0 && partPos < bidi.length; partPos += dir) {
                        var part = bidi[partPos], moveInStorageOrder = dir > 0 == (1 != part.level), ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
                        if (part.from <= ch && ch < part.to) return getRes(ch, moveInStorageOrder);
                        if (ch = moveInStorageOrder ? part.from : mv(part.to, -1), wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) return getRes(ch, moveInStorageOrder);
                    }
                }, res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
                if (res) return res;
                // Case 3b: Look for other bidi parts on the next visual line
                var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
                return null == nextCh || dir > 0 && nextCh == line.text.length || !(res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))) ? null : res;
            }
            function lineStart(cm, lineN) {
                var line = getLine(cm.doc, lineN), visual = visualLine(line);
                return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, visual, lineN, 1);
            }
            function lineEnd(cm, lineN) {
                var line = getLine(cm.doc, lineN), visual = visualLineEnd(line);
                return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, line, lineN, -1);
            }
            function lineStartSmart(cm, pos) {
                var start = lineStart(cm, pos.line), line = getLine(cm.doc, start.line), order = getOrder(line, cm.doc.direction);
                if (!order || 0 == order[0].level) {
                    var firstNonWS = Math.max(start.ch, line.text.search(/\S/)), inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
                    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
                }
                return start;
            }
            // Run a handler that was bound to a key.
            function doHandleBinding(cm, bound, dropShift) {
                if ("string" == typeof bound && (bound = commands[bound], !bound)) return !1;
                // Ensure previous input has been read, so that the handler sees a
                // consistent view of the document
                cm.display.input.ensurePolled();
                var prevShift = cm.display.shift, done = !1;
                try {
                    cm.isReadOnly() && (cm.state.suppressEdits = !0), dropShift && (cm.display.shift = !1), 
                    done = bound(cm) != Pass;
                } finally {
                    cm.display.shift = prevShift, cm.state.suppressEdits = !1;
                }
                return done;
            }
            function lookupKeyForEditor(cm, name, handle) {
                for (var i = 0; i < cm.state.keyMaps.length; i++) {
                    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
                    if (result) return result;
                }
                return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
            }
            function dispatchKey(cm, name, e, handle) {
                var seq = cm.state.keySeq;
                if (seq) {
                    if (isModifierKey(name)) return "handled";
                    if (/\'$/.test(name) ? cm.state.keySeq = null : stopSeq.set(50, function() {
                        cm.state.keySeq == seq && (cm.state.keySeq = null, cm.display.input.reset());
                    }), dispatchKeyInner(cm, seq + " " + name, e, handle)) return !0;
                }
                return dispatchKeyInner(cm, name, e, handle);
            }
            function dispatchKeyInner(cm, name, e, handle) {
                var result = lookupKeyForEditor(cm, name, handle);
                return "multi" == result && (cm.state.keySeq = name), "handled" == result && signalLater(cm, "keyHandled", cm, name, e), 
                "handled" != result && "multi" != result || (e_preventDefault(e), restartBlink(cm)), 
                !!result;
            }
            // Handle a key from the keydown event.
            function handleKeyBinding(cm, e) {
                var name = keyName(e, !0);
                return !!name && (e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function(b) {
                    return doHandleBinding(cm, b, !0);
                }) || dispatchKey(cm, name, e, function(b) {
                    if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);
                }) : dispatchKey(cm, name, e, function(b) {
                    return doHandleBinding(cm, b);
                }));
            }
            // Handle a key from the keypress event
            function handleCharBinding(cm, e, ch) {
                return dispatchKey(cm, "'" + ch + "'", e, function(b) {
                    return doHandleBinding(cm, b, !0);
                });
            }
            function onKeyDown(e) {
                var cm = this;
                if (!(e.target && e.target != cm.display.input.getField() || (cm.curOp.focus = activeElt(), 
                signalDOMEvent(cm, e)))) {
                    // IE does strange things with escape.
                    ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = !1);
                    var code = e.keyCode;
                    cm.display.shift = 16 == code || e.shiftKey;
                    var handled = handleKeyBinding(cm, e);
                    presto && (lastStoppedKey = handled ? code : null, // Opera has no cut event... we try to at least catch the key combo
                    !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")), 
                    gecko && !mac && !handled && 46 == code && e.shiftKey && !e.ctrlKey && document.execCommand && document.execCommand("cut"), 
                    // Turn mouse into crosshair when Alt is held on Mac.
                    18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm);
                }
            }
            function showCrossHair(cm) {
                function up(e) {
                    18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"), off(document, "keyup", up), 
                    off(document, "mouseover", up));
                }
                var lineDiv = cm.display.lineDiv;
                addClass(lineDiv, "CodeMirror-crosshair"), on(document, "keyup", up), on(document, "mouseover", up);
            }
            function onKeyUp(e) {
                16 == e.keyCode && (this.doc.sel.shift = !1), signalDOMEvent(this, e);
            }
            function onKeyPress(e) {
                var cm = this;
                if (!(e.target && e.target != cm.display.input.getField() || eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)) {
                    var keyCode = e.keyCode, charCode = e.charCode;
                    if (presto && keyCode == lastStoppedKey) return lastStoppedKey = null, void e_preventDefault(e);
                    if (!presto || e.which && !(e.which < 10) || !handleKeyBinding(cm, e)) {
                        var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
                        // Some browsers fire keypress events for backspace
                        "\b" != ch && (handleCharBinding(cm, e, ch) || cm.display.input.onKeyPress(e));
                    }
                }
            }
            function clickRepeat(pos, button) {
                var now = +new Date();
                return lastDoubleClick && lastDoubleClick.compare(now, pos, button) ? (lastClick = lastDoubleClick = null, 
                "triple") : lastClick && lastClick.compare(now, pos, button) ? (lastDoubleClick = new PastClick(now, pos, button), 
                lastClick = null, "double") : (lastClick = new PastClick(now, pos, button), lastDoubleClick = null, 
                "single");
            }
            // A mouse down can be a single click, double click, triple click,
            // start of selection drag, start of text drag, new cursor
            // (ctrl-click), rectangle drag (alt-drag), or xwin
            // middle-click-paste. Or it might be a click on something we should
            // not interfere with, such as a scrollbar or widget.
            function onMouseDown(e) {
                var cm = this, display = cm.display;
                if (!(signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())) {
                    if (display.input.ensurePolled(), display.shift = e.shiftKey, eventInWidget(display, e)) // Briefly turn off draggability, to allow widgets to do
                    // normal dragging things.
                    return void (webkit || (display.scroller.draggable = !1, setTimeout(function() {
                        return display.scroller.draggable = !0;
                    }, 100)));
                    if (!clickInGutter(cm, e)) {
                        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
                        window.focus(), // #3261: make sure, that we're not starting a second selection
                        1 == button && cm.state.selectingText && cm.state.selectingText(e), pos && handleMappedButton(cm, button, pos, repeat, e) || (1 == button ? pos ? leftButtonDown(cm, pos, repeat, e) : e_target(e) == display.scroller && e_preventDefault(e) : 2 == button ? (pos && extendSelection(cm.doc, pos), 
                        setTimeout(function() {
                            return display.input.focus();
                        }, 20)) : 3 == button && (captureRightClick ? cm.display.input.onContextMenu(e) : delayBlurEvent(cm)));
                    }
                }
            }
            function handleMappedButton(cm, button, pos, repeat, event) {
                var name = "Click";
                return "double" == repeat ? name = "Double" + name : "triple" == repeat && (name = "Triple" + name), 
                name = (1 == button ? "Left" : 2 == button ? "Middle" : "Right") + name, dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
                    if ("string" == typeof bound && (bound = commands[bound]), !bound) return !1;
                    var done = !1;
                    try {
                        cm.isReadOnly() && (cm.state.suppressEdits = !0), done = bound(cm, pos) != Pass;
                    } finally {
                        cm.state.suppressEdits = !1;
                    }
                    return done;
                });
            }
            function configureMouse(cm, repeat, event) {
                var option = cm.getOption("configureMouse"), value = option ? option(cm, repeat, event) : {};
                if (null == value.unit) {
                    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
                    value.unit = rect ? "rectangle" : "single" == repeat ? "char" : "double" == repeat ? "word" : "line";
                }
                return (null == value.extend || cm.doc.extend) && (value.extend = cm.doc.extend || event.shiftKey), 
                null == value.addNew && (value.addNew = mac ? event.metaKey : event.ctrlKey), null == value.moveOnDrag && (value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey)), 
                value;
            }
            function leftButtonDown(cm, pos, repeat, event) {
                ie ? setTimeout(bind(ensureFocus, cm), 0) : cm.curOp.focus = activeElt();
                var contained, behavior = configureMouse(cm, repeat, event), sel = cm.doc.sel;
                cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && "single" == repeat && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0) ? leftButtonStartDrag(cm, event, pos, behavior) : leftButtonSelect(cm, event, pos, behavior);
            }
            // Start a text drag. When it ends, see if any dragging actually
            // happen, and treat as a click if it didn't.
            function leftButtonStartDrag(cm, event, pos, behavior) {
                var display = cm.display, moved = !1, dragEnd = operation(cm, function(e) {
                    webkit && (display.scroller.draggable = !1), cm.state.draggingText = !1, off(display.wrapper.ownerDocument, "mouseup", dragEnd), 
                    off(display.wrapper.ownerDocument, "mousemove", mouseMove), off(display.scroller, "dragstart", dragStart), 
                    off(display.scroller, "drop", dragEnd), moved || (e_preventDefault(e), behavior.addNew || extendSelection(cm.doc, pos, null, null, behavior.extend), 
                    // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
                    webkit && !safari || ie && 9 == ie_version ? setTimeout(function() {
                        display.wrapper.ownerDocument.body.focus({
                            preventScroll: !0
                        }), display.input.focus();
                    }, 20) : display.input.focus());
                }), mouseMove = function(e2) {
                    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
                }, dragStart = function() {
                    return moved = !0;
                };
                // Let the drag handler handle this.
                webkit && (display.scroller.draggable = !0), cm.state.draggingText = dragEnd, dragEnd.copy = !behavior.moveOnDrag, 
                // IE's approach to draggable
                display.scroller.dragDrop && display.scroller.dragDrop(), on(display.wrapper.ownerDocument, "mouseup", dragEnd), 
                on(display.wrapper.ownerDocument, "mousemove", mouseMove), on(display.scroller, "dragstart", dragStart), 
                on(display.scroller, "drop", dragEnd), delayBlurEvent(cm), setTimeout(function() {
                    return display.input.focus();
                }, 20);
            }
            function rangeForUnit(cm, pos, unit) {
                if ("char" == unit) return new Range(pos, pos);
                if ("word" == unit) return cm.findWordAt(pos);
                if ("line" == unit) return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
                var result = unit(cm, pos);
                return new Range(result.from, result.to);
            }
            // Normal selection, as opposed to text dragging.
            function leftButtonSelect(cm, event, start, behavior) {
                function extendTo(pos) {
                    if (0 != cmp(lastPos, pos)) if (lastPos = pos, "rectangle" == behavior.unit) {
                        for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                            left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                        }
                        ranges.length || ranges.push(new Range(start, start)), setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                            origin: "*mouse",
                            scroll: !1
                        }), cm.scrollIntoView(pos);
                    } else {
                        var head, oldRange = ourRange, range = rangeForUnit(cm, pos, behavior.unit), anchor = oldRange.anchor;
                        cmp(range.anchor, anchor) > 0 ? (head = range.head, anchor = minPos(oldRange.from(), range.anchor)) : (head = range.anchor, 
                        anchor = maxPos(oldRange.to(), range.head));
                        var ranges$1 = startSel.ranges.slice(0);
                        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head)), setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
                    }
                }
                function extend(e) {
                    var curCount = ++counter, cur = posFromMouse(cm, e, !0, "rectangle" == behavior.unit);
                    if (cur) if (0 != cmp(cur, lastPos)) {
                        cm.curOp.focus = activeElt(), extendTo(cur);
                        var visible = visibleLines(display, doc);
                        (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function() {
                            counter == curCount && extend(e);
                        }), 150);
                    } else {
                        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                        outside && setTimeout(operation(cm, function() {
                            counter == curCount && (display.scroller.scrollTop += outside, extend(e));
                        }), 50);
                    }
                }
                function done(e) {
                    cm.state.selectingText = !1, counter = 1 / 0, // If e is null or undefined we interpret this as someone trying
                    // to explicitly cancel the selection rather than the user
                    // letting go of the mouse button.
                    e && (e_preventDefault(e), display.input.focus()), off(display.wrapper.ownerDocument, "mousemove", move), 
                    off(display.wrapper.ownerDocument, "mouseup", up), doc.history.lastSelOrigin = null;
                }
                var display = cm.display, doc = cm.doc;
                e_preventDefault(event);
                var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
                if (behavior.addNew && !behavior.extend ? (ourIndex = doc.sel.contains(start), ourRange = ourIndex > -1 ? ranges[ourIndex] : new Range(start, start)) : (ourRange = doc.sel.primary(), 
                ourIndex = doc.sel.primIndex), "rectangle" == behavior.unit) behavior.addNew || (ourRange = new Range(start, start)), 
                start = posFromMouse(cm, event, !0, !0), ourIndex = -1; else {
                    var range = rangeForUnit(cm, start, behavior.unit);
                    ourRange = behavior.extend ? extendRange(ourRange, range.anchor, range.head, behavior.extend) : range;
                }
                behavior.addNew ? ourIndex == -1 ? (ourIndex = ranges.length, setSelection(doc, normalizeSelection(cm, ranges.concat([ ourRange ]), ourIndex), {
                    scroll: !1,
                    origin: "*mouse"
                })) : ranges.length > 1 && ranges[ourIndex].empty() && "char" == behavior.unit && !behavior.extend ? (setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
                    scroll: !1,
                    origin: "*mouse"
                }), startSel = doc.sel) : replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (ourIndex = 0, 
                setSelection(doc, new Selection([ ourRange ], 0), sel_mouse), startSel = doc.sel);
                var lastPos = start, editorSize = display.wrapper.getBoundingClientRect(), counter = 0, move = operation(cm, function(e) {
                    0 !== e.buttons && e_button(e) ? extend(e) : done(e);
                }), up = operation(cm, done);
                cm.state.selectingText = up, on(display.wrapper.ownerDocument, "mousemove", move), 
                on(display.wrapper.ownerDocument, "mouseup", up);
            }
            // Used when mouse-selecting to adjust the anchor to the proper side
            // of a bidi jump depending on the visual position of the head.
            function bidiSimplify(cm, range) {
                var anchor = range.anchor, head = range.head, anchorLine = getLine(cm.doc, anchor.line);
                if (0 == cmp(anchor, head) && anchor.sticky == head.sticky) return range;
                var order = getOrder(anchorLine);
                if (!order) return range;
                var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
                if (part.from != anchor.ch && part.to != anchor.ch) return range;
                var boundary = index + (part.from == anchor.ch == (1 != part.level) ? 0 : 1);
                if (0 == boundary || boundary == order.length) return range;
                // Compute the relative visual position of the head compared to the
                // anchor (<0 is to the left, >0 to the right)
                var leftSide;
                if (head.line != anchor.line) leftSide = (head.line - anchor.line) * ("ltr" == cm.doc.direction ? 1 : -1) > 0; else {
                    var headIndex = getBidiPartAt(order, head.ch, head.sticky), dir = headIndex - index || (head.ch - anchor.ch) * (1 == part.level ? -1 : 1);
                    leftSide = headIndex == boundary - 1 || headIndex == boundary ? dir < 0 : dir > 0;
                }
                var usePart = order[boundary + (leftSide ? -1 : 0)], from = leftSide == (1 == usePart.level), ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
                return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);
            }
            // Determines whether an event happened in the gutter, and fires the
            // handlers for the corresponding event.
            function gutterEvent(cm, e, type, prevent) {
                var mX, mY;
                if (e.touches) mX = e.touches[0].clientX, mY = e.touches[0].clientY; else try {
                    mX = e.clientX, mY = e.clientY;
                } catch (e$1) {
                    return !1;
                }
                if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return !1;
                prevent && e_preventDefault(e);
                var display = cm.display, lineBox = display.lineDiv.getBoundingClientRect();
                if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
                mY -= lineBox.top - display.viewOffset;
                for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
                    var g = display.gutters.childNodes[i];
                    if (g && g.getBoundingClientRect().right >= mX) {
                        var line = lineAtHeight(cm.doc, mY), gutter = cm.display.gutterSpecs[i];
                        return signal(cm, type, cm, line, gutter.className, e), e_defaultPrevented(e);
                    }
                }
            }
            function clickInGutter(cm, e) {
                return gutterEvent(cm, e, "gutterClick", !0);
            }
            // CONTEXT MENU HANDLING
            // To make the context menu work, we need to briefly unhide the
            // textarea (making it as unobtrusive as possible) to let the
            // right-click take effect on it.
            function onContextMenu(cm, e) {
                eventInWidget(cm.display, e) || contextMenuInGutter(cm, e) || signalDOMEvent(cm, e, "contextmenu") || captureRightClick || cm.display.input.onContextMenu(e);
            }
            function contextMenuInGutter(cm, e) {
                return !!hasHandler(cm, "gutterContextMenu") && gutterEvent(cm, e, "gutterContextMenu", !1);
            }
            function themeChanged(cm) {
                cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), 
                clearCaches(cm);
            }
            function defineOptions(CodeMirror) {
                function option(name, deflt, handle, notOnInit) {
                    CodeMirror.defaults[name] = deflt, handle && (optionHandlers[name] = notOnInit ? function(cm, val, old) {
                        old != Init && handle(cm, val, old);
                    } : handle);
                }
                var optionHandlers = CodeMirror.optionHandlers;
                CodeMirror.defineOption = option, // Passed to option handlers when there is no old value.
                CodeMirror.Init = Init, // These two are, on init, called from the constructor because they
                // have to be initialized before the editor can start at all.
                option("value", "", function(cm, val) {
                    return cm.setValue(val);
                }, !0), option("mode", null, function(cm, val) {
                    cm.doc.modeOption = val, loadMode(cm);
                }, !0), option("indentUnit", 2, loadMode, !0), option("indentWithTabs", !1), option("smartIndent", !0), 
                option("tabSize", 4, function(cm) {
                    resetModeState(cm), clearCaches(cm), regChange(cm);
                }, !0), option("lineSeparator", null, function(cm, val) {
                    if (cm.doc.lineSep = val, val) {
                        var newBreaks = [], lineNo = cm.doc.first;
                        cm.doc.iter(function(line) {
                            for (var pos = 0; ;) {
                                var found = line.text.indexOf(val, pos);
                                if (found == -1) break;
                                pos = found + val.length, newBreaks.push(Pos(lineNo, found));
                            }
                            lineNo++;
                        });
                        for (var i = newBreaks.length - 1; i >= 0; i--) replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
                    }
                }), option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
                    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g"), 
                    old != Init && cm.refresh();
                }), option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
                    return cm.refresh();
                }, !0), option("electricChars", !0), option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
                    throw new Error("inputStyle can not (yet) be changed in a running editor");
                }, !0), option("spellcheck", !1, function(cm, val) {
                    return cm.getInputField().spellcheck = val;
                }, !0), option("autocorrect", !1, function(cm, val) {
                    return cm.getInputField().autocorrect = val;
                }, !0), option("autocapitalize", !1, function(cm, val) {
                    return cm.getInputField().autocapitalize = val;
                }, !0), option("rtlMoveVisually", !windows), option("wholeLineUpdateBefore", !0), 
                option("theme", "default", function(cm) {
                    themeChanged(cm), updateGutters(cm);
                }, !0), option("keyMap", "default", function(cm, val, old) {
                    var next = getKeyMap(val), prev = old != Init && getKeyMap(old);
                    prev && prev.detach && prev.detach(cm, next), next.attach && next.attach(cm, prev || null);
                }), option("extraKeys", null), option("configureMouse", null), option("lineWrapping", !1, wrappingChanged, !0), 
                option("gutters", [], function(cm, val) {
                    cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers), updateGutters(cm);
                }, !0), option("fixedGutter", !0, function(cm, val) {
                    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0", 
                    cm.refresh();
                }, !0), option("coverGutterNextToScrollbar", !1, function(cm) {
                    return updateScrollbars(cm);
                }, !0), option("scrollbarStyle", "native", function(cm) {
                    initScrollbars(cm), updateScrollbars(cm), cm.display.scrollbars.setScrollTop(cm.doc.scrollTop), 
                    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
                }, !0), option("lineNumbers", !1, function(cm, val) {
                    cm.display.gutterSpecs = getGutters(cm.options.gutters, val), updateGutters(cm);
                }, !0), option("firstLineNumber", 1, updateGutters, !0), option("lineNumberFormatter", function(integer) {
                    return integer;
                }, updateGutters, !0), option("showCursorWhenSelecting", !1, updateSelection, !0), 
                option("resetSelectionOnContextMenu", !0), option("lineWiseCopyCut", !0), option("pasteLinesPerSelection", !0), 
                option("selectionsMayTouch", !1), option("readOnly", !1, function(cm, val) {
                    "nocursor" == val && (onBlur(cm), cm.display.input.blur()), cm.display.input.readOnlyChanged(val);
                }), option("screenReaderLabel", null, function(cm, val) {
                    val = "" === val ? null : val, cm.display.input.screenReaderLabelChanged(val);
                }), option("disableInput", !1, function(cm, val) {
                    val || cm.display.input.reset();
                }, !0), option("dragDrop", !0, dragDropChanged), option("allowDropFileTypes", null), 
                option("cursorBlinkRate", 530), option("cursorScrollMargin", 0), option("cursorHeight", 1, updateSelection, !0), 
                option("singleCursorHeightPerLine", !0, updateSelection, !0), option("workTime", 100), 
                option("workDelay", 100), option("flattenSpans", !0, resetModeState, !0), option("addModeClass", !1, resetModeState, !0), 
                option("pollInterval", 100), option("undoDepth", 200, function(cm, val) {
                    return cm.doc.history.undoDepth = val;
                }), option("historyEventDelay", 1250), option("viewportMargin", 10, function(cm) {
                    return cm.refresh();
                }, !0), option("maxHighlightLength", 1e4, resetModeState, !0), option("moveInputWithCursor", !0, function(cm, val) {
                    val || cm.display.input.resetPosition();
                }), option("tabindex", null, function(cm, val) {
                    return cm.display.input.getField().tabIndex = val || "";
                }), option("autofocus", null), option("direction", "ltr", function(cm, val) {
                    return cm.doc.setDirection(val);
                }, !0), option("phrases", null);
            }
            function dragDropChanged(cm, value, old) {
                var wasOn = old && old != Init;
                if (!value != !wasOn) {
                    var funcs = cm.display.dragFunctions, toggle = value ? on : off;
                    toggle(cm.display.scroller, "dragstart", funcs.start), toggle(cm.display.scroller, "dragenter", funcs.enter), 
                    toggle(cm.display.scroller, "dragover", funcs.over), toggle(cm.display.scroller, "dragleave", funcs.leave), 
                    toggle(cm.display.scroller, "drop", funcs.drop);
                }
            }
            function wrappingChanged(cm) {
                cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"), cm.display.sizer.style.minWidth = "", 
                cm.display.sizerWidth = null) : (rmClass(cm.display.wrapper, "CodeMirror-wrap"), 
                findMaxLine(cm)), estimateLineHeights(cm), regChange(cm), clearCaches(cm), setTimeout(function() {
                    return updateScrollbars(cm);
                }, 100);
            }
            // A CodeMirror instance represents an editor. This is the object
            // that user code is usually dealing with.
            function CodeMirror(place, options) {
                var this$1 = this;
                if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);
                this.options = options = options ? copyObj(options) : {}, // Determine effective options based on given values and defaults.
                copyObj(defaults, options, !1);
                var doc = options.value;
                "string" == typeof doc ? doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction) : options.mode && (doc.modeOption = options.mode), 
                this.doc = doc;
                var input = new CodeMirror.inputStyles[options.inputStyle](this), display = this.display = new Display(place, doc, input, options);
                display.wrapper.CodeMirror = this, themeChanged(this), options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), 
                initScrollbars(this), this.state = {
                    keyMaps: [],
                    // stores maps added by addKeyMap
                    overlays: [],
                    // highlighting overlays, as added by addOverlay
                    modeGen: 0,
                    // bumped when mode/overlay changes, used to invalidate highlighting info
                    overwrite: !1,
                    delayingBlurEvent: !1,
                    focused: !1,
                    suppressEdits: !1,
                    // used to disable editing during key handlers when in readOnly mode
                    pasteIncoming: -1,
                    cutIncoming: -1,
                    // help recognize paste/cut edits in input.poll
                    selectingText: !1,
                    draggingText: !1,
                    highlight: new Delayed(),
                    // stores highlight worker timeout
                    keySeq: null,
                    // Unfinished key sequence
                    specialChars: null
                }, options.autofocus && !mobile && display.input.focus(), // Override magic textarea content restore that IE sometimes does
                // on our hidden textarea on reload
                ie && ie_version < 11 && setTimeout(function() {
                    return this$1.display.input.reset(!0);
                }, 20), registerEventHandlers(this), ensureGlobalHandlers(), startOperation(this), 
                this.curOp.forceUpdate = !0, attachDoc(this, doc), options.autofocus && !mobile || this.hasFocus() ? setTimeout(function() {
                    this$1.hasFocus() && !this$1.state.focused && onFocus(this$1);
                }, 20) : onBlur(this);
                for (var opt in optionHandlers) optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this, options[opt], Init);
                maybeUpdateLineNumberWidth(this), options.finishInit && options.finishInit(this);
                for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
                endOperation(this), // Suppress optimizelegibility in Webkit, since it breaks text
                // measuring on line wrapping boundaries.
                webkit && options.lineWrapping && "optimizelegibility" == getComputedStyle(display.lineDiv).textRendering && (display.lineDiv.style.textRendering = "auto");
            }
            // Attach the necessary event handlers when initializing the editor
            function registerEventHandlers(cm) {
                function finishTouch() {
                    d.activeTouch && (touchFinished = setTimeout(function() {
                        return d.activeTouch = null;
                    }, 1e3), prevTouch = d.activeTouch, prevTouch.end = +new Date());
                }
                function isMouseLikeTouchEvent(e) {
                    if (1 != e.touches.length) return !1;
                    var touch = e.touches[0];
                    return touch.radiusX <= 1 && touch.radiusY <= 1;
                }
                function farAway(touch, other) {
                    if (null == other.left) return !0;
                    var dx = other.left - touch.left, dy = other.top - touch.top;
                    return dx * dx + dy * dy > 400;
                }
                var d = cm.display;
                on(d.scroller, "mousedown", operation(cm, onMouseDown)), // Older IE's will not fire a second mousedown for a double click
                ie && ie_version < 11 ? on(d.scroller, "dblclick", operation(cm, function(e) {
                    if (!signalDOMEvent(cm, e)) {
                        var pos = posFromMouse(cm, e);
                        if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                            e_preventDefault(e);
                            var word = cm.findWordAt(pos);
                            extendSelection(cm.doc, word.anchor, word.head);
                        }
                    }
                })) : on(d.scroller, "dblclick", function(e) {
                    return signalDOMEvent(cm, e) || e_preventDefault(e);
                }), // Some browsers fire contextmenu *after* opening the menu, at
                // which point we can't mess with it anymore. Context menu is
                // handled in onMouseDown for these browsers.
                on(d.scroller, "contextmenu", function(e) {
                    return onContextMenu(cm, e);
                }), on(d.input.getField(), "contextmenu", function(e) {
                    d.scroller.contains(e.target) || onContextMenu(cm, e);
                });
                // Used to suppress mouse event handling when a touch happens
                var touchFinished, prevTouch = {
                    end: 0
                };
                on(d.scroller, "touchstart", function(e) {
                    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
                        d.input.ensurePolled(), clearTimeout(touchFinished);
                        var now = +new Date();
                        d.activeTouch = {
                            start: now,
                            moved: !1,
                            prev: now - prevTouch.end <= 300 ? prevTouch : null
                        }, 1 == e.touches.length && (d.activeTouch.left = e.touches[0].pageX, d.activeTouch.top = e.touches[0].pageY);
                    }
                }), on(d.scroller, "touchmove", function() {
                    d.activeTouch && (d.activeTouch.moved = !0);
                }), on(d.scroller, "touchend", function(e) {
                    var touch = d.activeTouch;
                    if (touch && !eventInWidget(d, e) && null != touch.left && !touch.moved && new Date() - touch.start < 300) {
                        var range, pos = cm.coordsChar(d.activeTouch, "page");
                        range = !touch.prev || farAway(touch, touch.prev) ? new Range(pos, pos) : !touch.prev.prev || farAway(touch, touch.prev.prev) ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))), 
                        cm.setSelection(range.anchor, range.head), cm.focus(), e_preventDefault(e);
                    }
                    finishTouch();
                }), on(d.scroller, "touchcancel", finishTouch), // Sync scrolling between fake scrollbars and real scrollable
                // area, ensure viewport is updated when scrolling.
                on(d.scroller, "scroll", function() {
                    d.scroller.clientHeight && (updateScrollTop(cm, d.scroller.scrollTop), setScrollLeft(cm, d.scroller.scrollLeft, !0), 
                    signal(cm, "scroll", cm));
                }), // Listen to wheel events in order to try and update the viewport on time.
                on(d.scroller, "mousewheel", function(e) {
                    return onScrollWheel(cm, e);
                }), on(d.scroller, "DOMMouseScroll", function(e) {
                    return onScrollWheel(cm, e);
                }), // Prevent wrapper from ever scrolling
                on(d.wrapper, "scroll", function() {
                    return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
                }), d.dragFunctions = {
                    enter: function(e) {
                        signalDOMEvent(cm, e) || e_stop(e);
                    },
                    over: function(e) {
                        signalDOMEvent(cm, e) || (onDragOver(cm, e), e_stop(e));
                    },
                    start: function(e) {
                        return onDragStart(cm, e);
                    },
                    drop: operation(cm, onDrop),
                    leave: function(e) {
                        signalDOMEvent(cm, e) || clearDragCursor(cm);
                    }
                };
                var inp = d.input.getField();
                on(inp, "keyup", function(e) {
                    return onKeyUp.call(cm, e);
                }), on(inp, "keydown", operation(cm, onKeyDown)), on(inp, "keypress", operation(cm, onKeyPress)), 
                on(inp, "focus", function(e) {
                    return onFocus(cm, e);
                }), on(inp, "blur", function(e) {
                    return onBlur(cm, e);
                });
            }
            // Indent the given line. The how parameter can be "smart",
            // "add"/null, "subtract", or "prev". When aggressive is false
            // (typically set to true for forced single-line indents), empty
            // lines are not indented, and places where the mode returns Pass
            // are left alone.
            function indentLine(cm, n, how, aggressive) {
                var state, doc = cm.doc;
                null == how && (how = "add"), "smart" == how && (// Fall back to "prev" when the mode doesn't have an indentation
                // method.
                doc.mode.indent ? state = getContextBefore(cm, n).state : how = "prev");
                var tabSize = cm.options.tabSize, line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
                line.stateAfter && (line.stateAfter = null);
                var indentation, curSpaceString = line.text.match(/^\s*/)[0];
                if (aggressive || /\S/.test(line.text)) {
                    if ("smart" == how && (indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text), 
                    indentation == Pass || indentation > 150)) {
                        if (!aggressive) return;
                        how = "prev";
                    }
                } else indentation = 0, how = "not";
                "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how), 
                indentation = Math.max(0, indentation);
                var indentString = "", pos = 0;
                if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) pos += tabSize, 
                indentString += "\t";
                if (pos < indentation && (indentString += spaceStr(indentation - pos)), indentString != curSpaceString) return replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input"), 
                line.stateAfter = null, !0;
                // Ensure that, if the cursor was in the whitespace at the start
                // of the line, it is moved to the end of that space.
                for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
                    var range = doc.sel.ranges[i$1];
                    if (range.head.line == n && range.head.ch < curSpaceString.length) {
                        var pos$1 = Pos(n, curSpaceString.length);
                        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
                        break;
                    }
                }
            }
            function setLastCopied(newLastCopied) {
                lastCopied = newLastCopied;
            }
            function applyTextInput(cm, inserted, deleted, sel, origin) {
                var doc = cm.doc;
                cm.display.shift = !1, sel || (sel = doc.sel);
                var recent = +new Date() - 200, paste = "paste" == origin || cm.state.pasteIncoming > recent, textLines = splitLinesAuto(inserted), multiPaste = null;
                // When pasting N lines into N selections, insert one line per selection
                if (paste && sel.ranges.length > 1) if (lastCopied && lastCopied.text.join("\n") == inserted) {
                    if (sel.ranges.length % lastCopied.text.length == 0) {
                        multiPaste = [];
                        for (var i = 0; i < lastCopied.text.length; i++) multiPaste.push(doc.splitLines(lastCopied.text[i]));
                    }
                } else textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection && (multiPaste = map(textLines, function(l) {
                    return [ l ];
                }));
                // Normal behavior is to insert the new text into every selection
                for (var updateInput = cm.curOp.updateInput, i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
                    var range = sel.ranges[i$1], from = range.from(), to = range.to();
                    range.empty() && (deleted && deleted > 0 ? from = Pos(from.line, from.ch - deleted) : cm.state.overwrite && !paste ? to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) : paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n") && (from = to = Pos(from.line, 0)));
                    var changeEvent = {
                        from: from,
                        to: to,
                        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                        origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
                    };
                    makeChange(cm.doc, changeEvent), signalLater(cm, "inputRead", cm, changeEvent);
                }
                inserted && !paste && triggerElectric(cm, inserted), ensureCursorVisible(cm), cm.curOp.updateInput < 2 && (cm.curOp.updateInput = updateInput), 
                cm.curOp.typing = !0, cm.state.pasteIncoming = cm.state.cutIncoming = -1;
            }
            function handlePaste(e, cm) {
                var pasted = e.clipboardData && e.clipboardData.getData("Text");
                if (pasted) return e.preventDefault(), cm.isReadOnly() || cm.options.disableInput || runInOp(cm, function() {
                    return applyTextInput(cm, pasted, 0, null, "paste");
                }), !0;
            }
            function triggerElectric(cm, inserted) {
                // When an 'electric' character is inserted, immediately trigger a reindent
                if (cm.options.electricChars && cm.options.smartIndent) for (var sel = cm.doc.sel, i = sel.ranges.length - 1; i >= 0; i--) {
                    var range = sel.ranges[i];
                    if (!(range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line)) {
                        var mode = cm.getModeAt(range.head), indented = !1;
                        if (mode.electricChars) {
                            for (var j = 0; j < mode.electricChars.length; j++) if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                                indented = indentLine(cm, range.head.line, "smart");
                                break;
                            }
                        } else mode.electricInput && mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)) && (indented = indentLine(cm, range.head.line, "smart"));
                        indented && signalLater(cm, "electricInput", cm, range.head.line);
                    }
                }
            }
            function copyableRanges(cm) {
                for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
                    var line = cm.doc.sel.ranges[i].head.line, lineRange = {
                        anchor: Pos(line, 0),
                        head: Pos(line + 1, 0)
                    };
                    ranges.push(lineRange), text.push(cm.getRange(lineRange.anchor, lineRange.head));
                }
                return {
                    text: text,
                    ranges: ranges
                };
            }
            function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
                field.setAttribute("autocorrect", autocorrect ? "" : "off"), field.setAttribute("autocapitalize", autocapitalize ? "" : "off"), 
                field.setAttribute("spellcheck", !!spellcheck);
            }
            function hiddenTextarea() {
                var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), div = elt("div", [ te ], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
                // The textarea is kept positioned near the cursor to prevent the
                // fact that it'll be scrolled into view on input from scrolling
                // our fake cursor out of view. On webkit, when wrap=off, paste is
                // very slow. So make the area wide instead.
                // If border: 0; -- iOS fails to open keyboard (issue #1287)
                return webkit ? te.style.width = "1000px" : te.setAttribute("wrap", "off"), ios && (te.style.border = "1px solid black"), 
                disableBrowserMagic(te), div;
            }
            // The publicly visible API. Note that methodOp(f) means
            // 'wrap f in an operation, performed on its `this` parameter'.
            // This is not the complete set of editor methods. Most of the
            // methods defined on the Doc type are also injected into
            // CodeMirror.prototype, for backwards compatibility and
            // convenience.
            function addEditorMethods(CodeMirror) {
                var optionHandlers = CodeMirror.optionHandlers, helpers = CodeMirror.helpers = {};
                CodeMirror.prototype = {
                    constructor: CodeMirror,
                    focus: function() {
                        window.focus(), this.display.input.focus();
                    },
                    setOption: function(option, value) {
                        var options = this.options, old = options[option];
                        options[option] == value && "mode" != option || (options[option] = value, optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old), 
                        signal(this, "optionChange", this, option));
                    },
                    getOption: function(option) {
                        return this.options[option];
                    },
                    getDoc: function() {
                        return this.doc;
                    },
                    addKeyMap: function(map, bottom) {
                        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
                    },
                    removeKeyMap: function(map) {
                        for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i) if (maps[i] == map || maps[i].name == map) return maps.splice(i, 1), 
                        !0;
                    },
                    addOverlay: methodOp(function(spec, options) {
                        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                        if (mode.startState) throw new Error("Overlays may not be stateful.");
                        insertSorted(this.state.overlays, {
                            mode: mode,
                            modeSpec: spec,
                            opaque: options && options.opaque,
                            priority: options && options.priority || 0
                        }, function(overlay) {
                            return overlay.priority;
                        }), this.state.modeGen++, regChange(this);
                    }),
                    removeOverlay: methodOp(function(spec) {
                        for (var overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                            var cur = overlays[i].modeSpec;
                            if (cur == spec || "string" == typeof spec && cur.name == spec) return overlays.splice(i, 1), 
                            this.state.modeGen++, void regChange(this);
                        }
                    }),
                    indentLine: methodOp(function(n, dir, aggressive) {
                        "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"), 
                        isLine(this.doc, n) && indentLine(this, n, dir, aggressive);
                    }),
                    indentSelection: methodOp(function(how) {
                        for (var ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                            var range = ranges[i];
                            if (range.empty()) range.head.line > end && (indentLine(this, range.head.line, how, !0), 
                            end = range.head.line, i == this.doc.sel.primIndex && ensureCursorVisible(this)); else {
                                var from = range.from(), to = range.to(), start = Math.max(end, from.line);
                                end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                                for (var j = start; j < end; ++j) indentLine(this, j, how);
                                var newRanges = this.doc.sel.ranges;
                                0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                            }
                        }
                    }),
                    // Fetch the parser token for a given character. Useful for hacks
                    // that want to inspect the mode state (say, for completion).
                    getTokenAt: function(pos, precise) {
                        return takeToken(this, pos, precise);
                    },
                    getLineTokens: function(line, precise) {
                        return takeToken(this, Pos(line), precise, !0);
                    },
                    getTokenTypeAt: function(pos) {
                        pos = clipPos(this.doc, pos);
                        var type, styles = getLineStyles(this, getLine(this.doc, pos.line)), before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                        if (0 == ch) type = styles[2]; else for (;;) {
                            var mid = before + after >> 1;
                            if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid; else {
                                if (!(styles[2 * mid + 1] < ch)) {
                                    type = styles[2 * mid + 2];
                                    break;
                                }
                                before = mid + 1;
                            }
                        }
                        var cut = type ? type.indexOf("overlay ") : -1;
                        return cut < 0 ? type : 0 == cut ? null : type.slice(0, cut - 1);
                    },
                    getModeAt: function(pos) {
                        var mode = this.doc.mode;
                        return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode;
                    },
                    getHelper: function(pos, type) {
                        return this.getHelpers(pos, type)[0];
                    },
                    getHelpers: function(pos, type) {
                        var found = [];
                        if (!helpers.hasOwnProperty(type)) return found;
                        var help = helpers[type], mode = this.getModeAt(pos);
                        if ("string" == typeof mode[type]) help[mode[type]] && found.push(help[mode[type]]); else if (mode[type]) for (var i = 0; i < mode[type].length; i++) {
                            var val = help[mode[type][i]];
                            val && found.push(val);
                        } else mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
                        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                            var cur = help._global[i$1];
                            cur.pred(mode, this) && indexOf(found, cur.val) == -1 && found.push(cur.val);
                        }
                        return found;
                    },
                    getStateAfter: function(line, precise) {
                        var doc = this.doc;
                        return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line), getContextBefore(this, line + 1, precise).state;
                    },
                    cursorCoords: function(start, mode) {
                        var pos, range = this.doc.sel.primary();
                        return pos = null == start ? range.head : "object" == typeof start ? clipPos(this.doc, start) : start ? range.from() : range.to(), 
                        cursorCoords(this, pos, mode || "page");
                    },
                    charCoords: function(pos, mode) {
                        return charCoords(this, clipPos(this.doc, pos), mode || "page");
                    },
                    coordsChar: function(coords, mode) {
                        return coords = fromCoordSystem(this, coords, mode || "page"), coordsChar(this, coords.left, coords.top);
                    },
                    lineAtHeight: function(height, mode) {
                        return height = fromCoordSystem(this, {
                            top: height,
                            left: 0
                        }, mode || "page").top, lineAtHeight(this.doc, height + this.display.viewOffset);
                    },
                    heightAtLine: function(line, mode, includeWidgets) {
                        var lineObj, end = !1;
                        if ("number" == typeof line) {
                            var last = this.doc.first + this.doc.size - 1;
                            line < this.doc.first ? line = this.doc.first : line > last && (line = last, end = !0), 
                            lineObj = getLine(this.doc, line);
                        } else lineObj = line;
                        return intoCoordSystem(this, lineObj, {
                            top: 0,
                            left: 0
                        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
                    },
                    defaultTextHeight: function() {
                        return textHeight(this.display);
                    },
                    defaultCharWidth: function() {
                        return charWidth(this.display);
                    },
                    getViewport: function() {
                        return {
                            from: this.display.viewFrom,
                            to: this.display.viewTo
                        };
                    },
                    addWidget: function(pos, node, scroll, vert, horiz) {
                        var display = this.display;
                        pos = cursorCoords(this, clipPos(this.doc, pos));
                        var top = pos.bottom, left = pos.left;
                        if (node.style.position = "absolute", node.setAttribute("cm-ignore-events", "true"), 
                        this.display.input.setUneditable(node), display.sizer.appendChild(node), "over" == vert) top = pos.top; else if ("above" == vert || "near" == vert) {
                            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                            // Default to positioning above (if specified and possible); otherwise default to positioning below
                            ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom), 
                            left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth);
                        }
                        node.style.top = top + "px", node.style.left = node.style.right = "", "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth, 
                        node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2), 
                        node.style.left = left + "px"), scroll && scrollIntoView(this, {
                            left: left,
                            top: top,
                            right: left + node.offsetWidth,
                            bottom: top + node.offsetHeight
                        });
                    },
                    triggerOnKeyDown: methodOp(onKeyDown),
                    triggerOnKeyPress: methodOp(onKeyPress),
                    triggerOnKeyUp: onKeyUp,
                    triggerOnMouseDown: methodOp(onMouseDown),
                    execCommand: function(cmd) {
                        if (commands.hasOwnProperty(cmd)) return commands[cmd].call(null, this);
                    },
                    triggerElectric: methodOp(function(text) {
                        triggerElectric(this, text);
                    }),
                    findPosH: function(from, amount, unit, visually) {
                        var dir = 1;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = clipPos(this.doc, from), i = 0; i < amount && (cur = findPosH(this.doc, cur, dir, unit, visually), 
                        !cur.hitSide); ++i) ;
                        return cur;
                    },
                    moveH: methodOp(function(dir, unit) {
                        var this$1 = this;
                        this.extendSelectionsBy(function(range) {
                            return this$1.display.shift || this$1.doc.extend || range.empty() ? findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) : dir < 0 ? range.from() : range.to();
                        }, sel_move);
                    }),
                    deleteH: methodOp(function(dir, unit) {
                        var sel = this.doc.sel, doc = this.doc;
                        sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function(range) {
                            var other = findPosH(doc, range.head, dir, unit, !1);
                            return dir < 0 ? {
                                from: other,
                                to: range.head
                            } : {
                                from: range.head,
                                to: other
                            };
                        });
                    }),
                    findPosV: function(from, amount, unit, goalColumn) {
                        var dir = 1, x = goalColumn;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = clipPos(this.doc, from), i = 0; i < amount; ++i) {
                            var coords = cursorCoords(this, cur, "div");
                            if (null == x ? x = coords.left : coords.left = x, cur = findPosV(this, coords, dir, unit), 
                            cur.hitSide) break;
                        }
                        return cur;
                    },
                    moveV: methodOp(function(dir, unit) {
                        var this$1 = this, doc = this.doc, goals = [], collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                        if (doc.extendSelectionsBy(function(range) {
                            if (collapse) return dir < 0 ? range.from() : range.to();
                            var headPos = cursorCoords(this$1, range.head, "div");
                            null != range.goalColumn && (headPos.left = range.goalColumn), goals.push(headPos.left);
                            var pos = findPosV(this$1, headPos, dir, unit);
                            return "page" == unit && range == doc.sel.primary() && addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top), 
                            pos;
                        }, sel_move), goals.length) for (var i = 0; i < doc.sel.ranges.length; i++) doc.sel.ranges[i].goalColumn = goals[i];
                    }),
                    // Find the word at the given position (as returned by coordsChar).
                    findWordAt: function(pos) {
                        var doc = this.doc, line = getLine(doc, pos.line).text, start = pos.ch, end = pos.ch;
                        if (line) {
                            var helper = this.getHelper(pos, "wordChars");
                            "before" != pos.sticky && end != line.length || !start ? ++end : --start;
                            for (var startChar = line.charAt(start), check = isWordChar(startChar, helper) ? function(ch) {
                                return isWordChar(ch, helper);
                            } : /\s/.test(startChar) ? function(ch) {
                                return /\s/.test(ch);
                            } : function(ch) {
                                return !/\s/.test(ch) && !isWordChar(ch);
                            }; start > 0 && check(line.charAt(start - 1)); ) --start;
                            for (;end < line.length && check(line.charAt(end)); ) ++end;
                        }
                        return new Range(Pos(pos.line, start), Pos(pos.line, end));
                    },
                    toggleOverwrite: function(value) {
                        null != value && value == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite") : rmClass(this.display.cursorDiv, "CodeMirror-overwrite"), 
                        signal(this, "overwriteToggle", this, this.state.overwrite));
                    },
                    hasFocus: function() {
                        return this.display.input.getField() == activeElt();
                    },
                    isReadOnly: function() {
                        return !(!this.options.readOnly && !this.doc.cantEdit);
                    },
                    scrollTo: methodOp(function(x, y) {
                        scrollToCoords(this, x, y);
                    }),
                    getScrollInfo: function() {
                        var scroller = this.display.scroller;
                        return {
                            left: scroller.scrollLeft,
                            top: scroller.scrollTop,
                            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                            clientHeight: displayHeight(this),
                            clientWidth: displayWidth(this)
                        };
                    },
                    scrollIntoView: methodOp(function(range, margin) {
                        null == range ? (range = {
                            from: this.doc.sel.primary().head,
                            to: null
                        }, null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range ? range = {
                            from: Pos(range, 0),
                            to: null
                        } : null == range.from && (range = {
                            from: range,
                            to: null
                        }), range.to || (range.to = range.from), range.margin = margin || 0, null != range.from.line ? scrollToRange(this, range) : scrollToCoordsRange(this, range.from, range.to, range.margin);
                    }),
                    setSize: methodOp(function(width, height) {
                        var this$1 = this, interpret = function(val) {
                            return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val;
                        };
                        null != width && (this.display.wrapper.style.width = interpret(width)), null != height && (this.display.wrapper.style.height = interpret(height)), 
                        this.options.lineWrapping && clearLineMeasurementCache(this);
                        var lineNo = this.display.viewFrom;
                        this.doc.iter(lineNo, this.display.viewTo, function(line) {
                            if (line.widgets) for (var i = 0; i < line.widgets.length; i++) if (line.widgets[i].noHScroll) {
                                regLineChange(this$1, lineNo, "widget");
                                break;
                            }
                            ++lineNo;
                        }), this.curOp.forceUpdate = !0, signal(this, "refresh", this);
                    }),
                    operation: function(f) {
                        return runInOp(this, f);
                    },
                    startOperation: function() {
                        return startOperation(this);
                    },
                    endOperation: function() {
                        return endOperation(this);
                    },
                    refresh: methodOp(function() {
                        var oldHeight = this.display.cachedTextHeight;
                        regChange(this), this.curOp.forceUpdate = !0, clearCaches(this), scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop), 
                        updateGutterSpace(this.display), (null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping) && estimateLineHeights(this), 
                        signal(this, "refresh", this);
                    }),
                    swapDoc: methodOp(function(doc) {
                        var old = this.doc;
                        // Cancel the current text selection if any (#5821)
                        return old.cm = null, this.state.selectingText && this.state.selectingText(), attachDoc(this, doc), 
                        clearCaches(this), this.display.input.reset(), scrollToCoords(this, doc.scrollLeft, doc.scrollTop), 
                        this.curOp.forceScroll = !0, signalLater(this, "swapDoc", this, old), old;
                    }),
                    phrase: function(phraseText) {
                        var phrases = this.options.phrases;
                        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
                    },
                    getInputField: function() {
                        return this.display.input.getField();
                    },
                    getWrapperElement: function() {
                        return this.display.wrapper;
                    },
                    getScrollerElement: function() {
                        return this.display.scroller;
                    },
                    getGutterElement: function() {
                        return this.display.gutters;
                    }
                }, eventMixin(CodeMirror), CodeMirror.registerHelper = function(type, name, value) {
                    helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
                        _global: []
                    }), helpers[type][name] = value;
                }, CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
                    CodeMirror.registerHelper(type, name, value), helpers[type]._global.push({
                        pred: predicate,
                        val: value
                    });
                };
            }
            // Used for horizontal relative motion. Dir is -1 or 1 (left or
            // right), unit can be "codepoint", "char", "column" (like char, but
            // doesn't cross line boundaries), "word" (across next word), or
            // "group" (to the start of next group of word or
            // non-word-non-whitespace chars). The visually param controls
            // whether, in right-to-left text, direction 1 means to move towards
            // the next index in the string, or towards the character to the right
            // of the current position. The resulting position will have a
            // hitSide=true property if it reached the end of the document.
            function findPosH(doc, pos, dir, unit, visually) {
                function findNextLine() {
                    var l = pos.line + lineDir;
                    return !(l < doc.first || l >= doc.first + doc.size) && (pos = new Pos(l, pos.ch, pos.sticky), 
                    lineObj = getLine(doc, l));
                }
                function moveOnce(boundToLine) {
                    var next;
                    if ("codepoint" == unit) {
                        var ch = lineObj.text.charCodeAt(pos.ch + (unit > 0 ? 0 : -1));
                        next = isNaN(ch) ? null : new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (ch >= 55296 && ch < 56320 ? 2 : 1))), -dir);
                    } else next = visually ? moveVisually(doc.cm, lineObj, pos, dir) : moveLogically(lineObj, pos, dir);
                    if (null == next) {
                        if (boundToLine || !findNextLine()) return !1;
                        pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
                    } else pos = next;
                    return !0;
                }
                var oldPos = pos, origDir = dir, lineObj = getLine(doc, pos.line), lineDir = visually && "rtl" == doc.direction ? -dir : dir;
                if ("char" == unit || "codepoint" == unit) moveOnce(); else if ("column" == unit) moveOnce(!0); else if ("word" == unit || "group" == unit) for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(dir < 0) || moveOnce(!first); first = !1) {
                    var cur = lineObj.text.charAt(pos.ch) || "\n", type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
                    if (!group || first || type || (type = "s"), sawType && sawType != type) {
                        dir < 0 && (dir = 1, moveOnce(), pos.sticky = "after");
                        break;
                    }
                    if (type && (sawType = type), dir > 0 && !moveOnce(!first)) break;
                }
                var result = skipAtomic(doc, pos, oldPos, origDir, !0);
                return equalCursorPos(oldPos, result) && (result.hitSide = !0), result;
            }
            // For relative vertical movement. Dir may be -1 or 1. Unit can be
            // "page" or "line". The resulting position will have a hitSide=true
            // property if it reached the end of the document.
            function findPosV(cm, pos, dir, unit) {
                var y, doc = cm.doc, x = pos.left;
                if ("page" == unit) {
                    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
                    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
                } else "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
                for (var target; target = coordsChar(cm, x, y), target.outside; ) {
                    if (dir < 0 ? y <= 0 : y >= doc.height) {
                        target.hitSide = !0;
                        break;
                    }
                    y += 5 * dir;
                }
                return target;
            }
            function posToDOM(cm, pos) {
                var view = findViewForLine(cm, pos.line);
                if (!view || view.hidden) return null;
                var line = getLine(cm.doc, pos.line), info = mapFromLineView(view, line, pos.line), order = getOrder(line, cm.doc.direction), side = "left";
                if (order) {
                    var partPos = getBidiPartAt(order, pos.ch);
                    side = partPos % 2 ? "right" : "left";
                }
                var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
                return result.offset = "right" == result.collapse ? result.end : result.start, result;
            }
            function isInGutter(node) {
                for (var scan = node; scan; scan = scan.parentNode) if (/CodeMirror-gutter-wrapper/.test(scan.className)) return !0;
                return !1;
            }
            function badPos(pos, bad) {
                return bad && (pos.bad = !0), pos;
            }
            function domTextBetween(cm, from, to, fromLine, toLine) {
                function recognizeMarker(id) {
                    return function(marker) {
                        return marker.id == id;
                    };
                }
                function close() {
                    closing && (text += lineSep, extraLinebreak && (text += lineSep), closing = extraLinebreak = !1);
                }
                function addText(str) {
                    str && (close(), text += str);
                }
                function walk(node) {
                    if (1 == node.nodeType) {
                        var cmText = node.getAttribute("cm-text");
                        if (cmText) return void addText(cmText);
                        var range, markerID = node.getAttribute("cm-marker");
                        if (markerID) {
                            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                            return void (found.length && (range = found[0].find(0)) && addText(getBetween(cm.doc, range.from, range.to).join(lineSep)));
                        }
                        if ("false" == node.getAttribute("contenteditable")) return;
                        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
                        if (!/^br$/i.test(node.nodeName) && 0 == node.textContent.length) return;
                        isBlock && close();
                        for (var i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
                        /^(pre|p)$/i.test(node.nodeName) && (extraLinebreak = !0), isBlock && (closing = !0);
                    } else 3 == node.nodeType && addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
                }
                for (var text = "", closing = !1, lineSep = cm.doc.lineSeparator(), extraLinebreak = !1; walk(from), 
                from != to; ) from = from.nextSibling, extraLinebreak = !1;
                return text;
            }
            function domToPos(cm, node, offset) {
                var lineNode;
                if (node == cm.display.lineDiv) {
                    if (lineNode = cm.display.lineDiv.childNodes[offset], !lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), !0);
                    node = null, offset = 0;
                } else for (lineNode = node; ;lineNode = lineNode.parentNode) {
                    if (!lineNode || lineNode == cm.display.lineDiv) return null;
                    if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
                }
                for (var i = 0; i < cm.display.view.length; i++) {
                    var lineView = cm.display.view[i];
                    if (lineView.node == lineNode) return locateNodeInLineView(lineView, node, offset);
                }
            }
            function locateNodeInLineView(lineView, node, offset) {
                function find(textNode, topNode, offset) {
                    for (var i = -1; i < (maps ? maps.length : 0); i++) for (var map = i < 0 ? measure.map : maps[i], j = 0; j < map.length; j += 3) {
                        var curNode = map[j + 2];
                        if (curNode == textNode || curNode == topNode) {
                            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]), ch = map[j] + offset;
                            return (offset < 0 || curNode != textNode) && (ch = map[j + (offset ? 1 : 0)]), 
                            Pos(line, ch);
                        }
                    }
                }
                var wrapper = lineView.text.firstChild, bad = !1;
                if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), !0);
                if (node == wrapper && (bad = !0, node = wrapper.childNodes[offset], offset = 0, 
                !node)) {
                    var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                    return badPos(Pos(lineNo(line), line.text.length), bad);
                }
                var textNode = 3 == node.nodeType ? node : null, topNode = node;
                for (textNode || 1 != node.childNodes.length || 3 != node.firstChild.nodeType || (textNode = node.firstChild, 
                offset && (offset = textNode.nodeValue.length)); topNode.parentNode != wrapper; ) topNode = topNode.parentNode;
                var measure = lineView.measure, maps = measure.maps, found = find(textNode, topNode, offset);
                if (found) return badPos(found, bad);
                // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
                for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
                    if (found = find(after, after.firstChild, 0)) return badPos(Pos(found.line, found.ch - dist), bad);
                    dist += after.textContent.length;
                }
                for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
                    if (found = find(before, before.firstChild, -1)) return badPos(Pos(found.line, found.ch + dist$1), bad);
                    dist$1 += before.textContent.length;
                }
            }
            function fromTextArea(textarea, options) {
                function save() {
                    textarea.value = cm.getValue();
                }
                // Set autofocus to true if this textarea is focused, or if it has
                // autofocus and no other element is focused.
                if (options = options ? copyObj(options) : {}, options.value = textarea.value, !options.tabindex && textarea.tabIndex && (options.tabindex = textarea.tabIndex), 
                !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder), 
                null == options.autofocus) {
                    var hasFocus = activeElt();
                    options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body;
                }
                var realSubmit;
                if (textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
                    var form = textarea.form;
                    realSubmit = form.submit;
                    try {
                        var wrappedSubmit = form.submit = function() {
                            save(), form.submit = realSubmit, form.submit(), form.submit = wrappedSubmit;
                        };
                    } catch (e) {}
                }
                options.finishInit = function(cm) {
                    cm.save = save, cm.getTextArea = function() {
                        return textarea;
                    }, cm.toTextArea = function() {
                        cm.toTextArea = isNaN, // Prevent this from being ran twice
                        save(), textarea.parentNode.removeChild(cm.getWrapperElement()), textarea.style.display = "", 
                        textarea.form && (off(textarea.form, "submit", save), options.leaveSubmitMethodAlone || "function" != typeof textarea.form.submit || (textarea.form.submit = realSubmit));
                    };
                }, textarea.style.display = "none";
                var cm = CodeMirror(function(node) {
                    return textarea.parentNode.insertBefore(node, textarea.nextSibling);
                }, options);
                return cm;
            }
            function addLegacyProps(CodeMirror) {
                CodeMirror.off = off, CodeMirror.on = on, CodeMirror.wheelEventPixels = wheelEventPixels, 
                CodeMirror.Doc = Doc, CodeMirror.splitLines = splitLinesAuto, CodeMirror.countColumn = countColumn, 
                CodeMirror.findColumn = findColumn, CodeMirror.isWordChar = isWordCharBasic, CodeMirror.Pass = Pass, 
                CodeMirror.signal = signal, CodeMirror.Line = Line, CodeMirror.changeEnd = changeEnd, 
                CodeMirror.scrollbarModel = scrollbarModel, CodeMirror.Pos = Pos, CodeMirror.cmpPos = cmp, 
                CodeMirror.modes = modes, CodeMirror.mimeModes = mimeModes, CodeMirror.resolveMode = resolveMode, 
                CodeMirror.getMode = getMode, CodeMirror.modeExtensions = modeExtensions, CodeMirror.extendMode = extendMode, 
                CodeMirror.copyState = copyState, CodeMirror.startState = startState, CodeMirror.innerMode = innerMode, 
                CodeMirror.commands = commands, CodeMirror.keyMap = keyMap, CodeMirror.keyName = keyName, 
                CodeMirror.isModifierKey = isModifierKey, CodeMirror.lookupKey = lookupKey, CodeMirror.normalizeKeyMap = normalizeKeyMap, 
                CodeMirror.StringStream = StringStream, CodeMirror.SharedTextMarker = SharedTextMarker, 
                CodeMirror.TextMarker = TextMarker, CodeMirror.LineWidget = LineWidget, CodeMirror.e_preventDefault = e_preventDefault, 
                CodeMirror.e_stopPropagation = e_stopPropagation, CodeMirror.e_stop = e_stop, CodeMirror.addClass = addClass, 
                CodeMirror.contains = contains, CodeMirror.rmClass = rmClass, CodeMirror.keyNames = keyNames;
            }
            // Kludges for bugs and behavior differences that can't be feature
            // detected are enabled based on userAgent etc sniffing.
            var userAgent = navigator.userAgent, platform = navigator.platform, gecko = /gecko\/\d/i.test(userAgent), ie_upto10 = /MSIE \d/.test(userAgent), ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent), edge = /Edge\/(\d+)/.exec(userAgent), ie = ie_upto10 || ie_11up || edge, ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]), webkit = !edge && /WebKit\//.test(userAgent), qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent), chrome = !edge && /Chrome\//.test(userAgent), presto = /Opera\//.test(userAgent), safari = /Apple Computer/.test(navigator.vendor), mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent), phantom = /PhantomJS/.test(userAgent), ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent), android = /Android/.test(userAgent), mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent), mac = ios || /Mac/.test(platform), chromeOS = /\bCrOS\b/.test(userAgent), windows = /win/i.test(platform), presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
            presto_version && (presto_version = Number(presto_version[1])), presto_version && presto_version >= 15 && (presto = !1, 
            webkit = !0);
            // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
            var range, flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || presto_version < 12.11)), captureRightClick = gecko || ie && ie_version >= 9, rmClass = function(node, cls) {
                var current = node.className, match = classTest(cls).exec(current);
                if (match) {
                    var after = current.slice(match.index + match[0].length);
                    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
                }
            };
            range = document.createRange ? function(node, start, end, endNode) {
                var r = document.createRange();
                return r.setEnd(endNode || node, end), r.setStart(node, start), r;
            } : function(node, start, end) {
                var r = document.body.createTextRange();
                try {
                    r.moveToElementText(node.parentNode);
                } catch (e) {
                    return r;
                }
                return r.collapse(!0), r.moveEnd("character", end), r.moveStart("character", start), 
                r;
            };
            var selectInput = function(node) {
                node.select();
            };
            ios ? selectInput = function(node) {
                node.selectionStart = 0, node.selectionEnd = node.value.length;
            } : ie && (selectInput = function(node) {
                try {
                    node.select();
                } catch (_e) {}
            });
            var Delayed = function() {
                this.id = null, this.f = null, this.time = 0, this.handler = bind(this.onTimeout, this);
            };
            Delayed.prototype.onTimeout = function(self) {
                self.id = 0, self.time <= +new Date() ? self.f() : setTimeout(self.handler, self.time - +new Date());
            }, Delayed.prototype.set = function(ms, f) {
                this.f = f;
                var time = +new Date() + ms;
                (!this.id || time < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, ms), 
                this.time = time);
            };
            // Number of pixels added to scroller and sizer to hide scrollbar
            var zwspSupported, badBidiRects, scrollerGap = 50, Pass = {
                toString: function() {
                    return "CodeMirror.Pass";
                }
            }, sel_dontScroll = {
                scroll: !1
            }, sel_mouse = {
                origin: "*mouse"
            }, sel_move = {
                origin: "+move"
            }, spaceStrs = [ "" ], nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/, bidiOther = null, bidiOrdering = function() {
                function charType(code) {
                    return code <= 247 ? lowTypes.charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1785 ? arabicTypes.charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L";
                }
                function BidiSpan(level, from, to) {
                    this.level = level, this.from = from, this.to = to;
                }
                // Character types for codepoints 0 to 0xff
                var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111", bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
                return function(str, direction) {
                    var outerType = "ltr" == direction ? "L" : "R";
                    if (0 == str.length || "ltr" == direction && !bidiRE.test(str)) return !1;
                    for (var len = str.length, types = [], i = 0; i < len; ++i) types.push(charType(str.charCodeAt(i)));
                    // W1. Examine each non-spacing mark (NSM) in the level run, and
                    // change the type of the NSM to the type of the previous
                    // character. If the NSM is at the start of the level run, it will
                    // get the type of sor.
                    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
                        var type = types[i$1];
                        "m" == type ? types[i$1] = prev : prev = type;
                    }
                    // W2. Search backwards from each instance of a European number
                    // until the first strong type (R, L, AL, or sor) is found. If an
                    // AL is found, change the type of the European number to Arabic
                    // number.
                    // W3. Change all ALs to R.
                    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
                        var type$1 = types[i$2];
                        "1" == type$1 && "r" == cur ? types[i$2] = "n" : isStrong.test(type$1) && (cur = type$1, 
                        "r" == type$1 && (types[i$2] = "R"));
                    }
                    // W4. A single European separator between two European numbers
                    // changes to a European number. A single common separator between
                    // two numbers of the same type changes to that type.
                    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
                        var type$2 = types[i$3];
                        "+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1] ? types[i$3] = "1" : "," != type$2 || prev$1 != types[i$3 + 1] || "1" != prev$1 && "n" != prev$1 || (types[i$3] = prev$1), 
                        prev$1 = type$2;
                    }
                    // W5. A sequence of European terminators adjacent to European
                    // numbers changes to all European numbers.
                    // W6. Otherwise, separators and terminators change to Other
                    // Neutral.
                    for (var i$4 = 0; i$4 < len; ++i$4) {
                        var type$3 = types[i$4];
                        if ("," == type$3) types[i$4] = "N"; else if ("%" == type$3) {
                            var end = void 0;
                            for (end = i$4 + 1; end < len && "%" == types[end]; ++end) ;
                            for (var replace = i$4 && "!" == types[i$4 - 1] || end < len && "1" == types[end] ? "1" : "N", j = i$4; j < end; ++j) types[j] = replace;
                            i$4 = end - 1;
                        }
                    }
                    // W7. Search backwards from each instance of a European number
                    // until the first strong type (R, L, or sor) is found. If an L is
                    // found, then change the type of the European number to L.
                    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
                        var type$4 = types[i$5];
                        "L" == cur$1 && "1" == type$4 ? types[i$5] = "L" : isStrong.test(type$4) && (cur$1 = type$4);
                    }
                    // N1. A sequence of neutrals takes the direction of the
                    // surrounding strong text if the text on both sides has the same
                    // direction. European and Arabic numbers act as if they were R in
                    // terms of their influence on neutrals. Start-of-level-run (sor)
                    // and end-of-level-run (eor) are used at level run boundaries.
                    // N2. Any remaining neutrals take the embedding direction.
                    for (var i$6 = 0; i$6 < len; ++i$6) if (isNeutral.test(types[i$6])) {
                        var end$1 = void 0;
                        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) ;
                        for (var before = "L" == (i$6 ? types[i$6 - 1] : outerType), after = "L" == (end$1 < len ? types[end$1] : outerType), replace$1 = before == after ? before ? "L" : "R" : outerType, j$1 = i$6; j$1 < end$1; ++j$1) types[j$1] = replace$1;
                        i$6 = end$1 - 1;
                    }
                    for (var m, order = [], i$7 = 0; i$7 < len; ) if (countsAsLeft.test(types[i$7])) {
                        var start = i$7;
                        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) ;
                        order.push(new BidiSpan(0, start, i$7));
                    } else {
                        var pos = i$7, at = order.length, isRTL = "rtl" == direction ? 1 : 0;
                        for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7) ;
                        for (var j$2 = pos; j$2 < i$7; ) if (countsAsNum.test(types[j$2])) {
                            pos < j$2 && (order.splice(at, 0, new BidiSpan(1, pos, j$2)), at += isRTL);
                            var nstart = j$2;
                            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) ;
                            order.splice(at, 0, new BidiSpan(2, nstart, j$2)), at += isRTL, pos = j$2;
                        } else ++j$2;
                        pos < i$7 && order.splice(at, 0, new BidiSpan(1, pos, i$7));
                    }
                    return "ltr" == direction && (1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length, 
                    order.unshift(new BidiSpan(0, 0, m[0].length))), 1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length, 
                    order.push(new BidiSpan(0, len - m[0].length, len)))), "rtl" == direction ? order.reverse() : order;
                };
            }(), noHandlers = [], on = function(emitter, type, f) {
                if (emitter.addEventListener) emitter.addEventListener(type, f, !1); else if (emitter.attachEvent) emitter.attachEvent("on" + type, f); else {
                    var map = emitter._handlers || (emitter._handlers = {});
                    map[type] = (map[type] || noHandlers).concat(f);
                }
            }, dragAndDrop = function() {
                // There is *some* kind of drag-and-drop support in IE6-8, but I
                // couldn't get it to work yet.
                if (ie && ie_version < 9) return !1;
                var div = elt("div");
                return "draggable" in div || "dragDrop" in div;
            }(), splitLinesAuto = 3 != "\n\nb".split(/\n/).length ? function(string) {
                for (var pos = 0, result = [], l = string.length; pos <= l; ) {
                    var nl = string.indexOf("\n", pos);
                    nl == -1 && (nl = string.length);
                    var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl), rt = line.indexOf("\r");
                    rt != -1 ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line), 
                    pos = nl + 1);
                }
                return result;
            } : function(string) {
                return string.split(/\r\n?|\n/);
            }, hasSelection = window.getSelection ? function(te) {
                try {
                    return te.selectionStart != te.selectionEnd;
                } catch (e) {
                    return !1;
                }
            } : function(te) {
                var range;
                try {
                    range = te.ownerDocument.selection.createRange();
                } catch (e) {}
                return !(!range || range.parentElement() != te) && 0 != range.compareEndPoints("StartToEnd", range);
            }, hasCopyEvent = function() {
                var e = elt("div");
                return "oncopy" in e || (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy);
            }(), badZoomedRects = null, modes = {}, mimeModes = {}, modeExtensions = {}, StringStream = function(string, tabSize, lineOracle) {
                this.pos = this.start = 0, this.string = string, this.tabSize = tabSize || 8, this.lastColumnPos = this.lastColumnValue = 0, 
                this.lineStart = 0, this.lineOracle = lineOracle;
            };
            StringStream.prototype.eol = function() {
                return this.pos >= this.string.length;
            }, StringStream.prototype.sol = function() {
                return this.pos == this.lineStart;
            }, StringStream.prototype.peek = function() {
                return this.string.charAt(this.pos) || void 0;
            }, StringStream.prototype.next = function() {
                if (this.pos < this.string.length) return this.string.charAt(this.pos++);
            }, StringStream.prototype.eat = function(match) {
                var ok, ch = this.string.charAt(this.pos);
                if (ok = "string" == typeof match ? ch == match : ch && (match.test ? match.test(ch) : match(ch))) return ++this.pos, 
                ch;
            }, StringStream.prototype.eatWhile = function(match) {
                for (var start = this.pos; this.eat(match); ) ;
                return this.pos > start;
            }, StringStream.prototype.eatSpace = function() {
                for (var start = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); ) ++this.pos;
                return this.pos > start;
            }, StringStream.prototype.skipToEnd = function() {
                this.pos = this.string.length;
            }, StringStream.prototype.skipTo = function(ch) {
                var found = this.string.indexOf(ch, this.pos);
                if (found > -1) return this.pos = found, !0;
            }, StringStream.prototype.backUp = function(n) {
                this.pos -= n;
            }, StringStream.prototype.column = function() {
                return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), 
                this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
            }, StringStream.prototype.indentation = function() {
                return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
            }, StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
                if ("string" != typeof pattern) {
                    var match = this.string.slice(this.pos).match(pattern);
                    return match && match.index > 0 ? null : (match && consume !== !1 && (this.pos += match[0].length), 
                    match);
                }
                var cased = function(str) {
                    return caseInsensitive ? str.toLowerCase() : str;
                }, substr = this.string.substr(this.pos, pattern.length);
                if (cased(substr) == cased(pattern)) return consume !== !1 && (this.pos += pattern.length), 
                !0;
            }, StringStream.prototype.current = function() {
                return this.string.slice(this.start, this.pos);
            }, StringStream.prototype.hideFirstChars = function(n, inner) {
                this.lineStart += n;
                try {
                    return inner();
                } finally {
                    this.lineStart -= n;
                }
            }, StringStream.prototype.lookAhead = function(n) {
                var oracle = this.lineOracle;
                return oracle && oracle.lookAhead(n);
            }, StringStream.prototype.baseToken = function() {
                var oracle = this.lineOracle;
                return oracle && oracle.baseToken(this.pos);
            };
            var SavedContext = function(state, lookAhead) {
                this.state = state, this.lookAhead = lookAhead;
            }, Context = function(doc, state, line, lookAhead) {
                this.state = state, this.doc = doc, this.line = line, this.maxLookAhead = lookAhead || 0, 
                this.baseTokens = null, this.baseTokenPos = 1;
            };
            Context.prototype.lookAhead = function(n) {
                var line = this.doc.getLine(this.line + n);
                return null != line && n > this.maxLookAhead && (this.maxLookAhead = n), line;
            }, Context.prototype.baseToken = function(n) {
                if (!this.baseTokens) return null;
                for (;this.baseTokens[this.baseTokenPos] <= n; ) this.baseTokenPos += 2;
                var type = this.baseTokens[this.baseTokenPos + 1];
                return {
                    type: type && type.replace(/( |^)overlay .*/, ""),
                    size: this.baseTokens[this.baseTokenPos] - n
                };
            }, Context.prototype.nextLine = function() {
                this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;
            }, Context.fromSaved = function(doc, saved, line) {
                return saved instanceof SavedContext ? new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) : new Context(doc, copyState(doc.mode, saved), line);
            }, Context.prototype.save = function(copy) {
                var state = copy !== !1 ? copyState(this.doc.mode, this.state) : this.state;
                return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
            };
            var Token = function(stream, type, state) {
                this.start = stream.start, this.end = stream.pos, this.string = stream.current(), 
                this.type = type || null, this.state = state;
            }, sawReadOnlySpans = !1, sawCollapsedSpans = !1, Line = function(text, markedSpans, estimateHeight) {
                this.text = text, attachMarkedSpans(this, markedSpans), this.height = estimateHeight ? estimateHeight(this) : 1;
            };
            Line.prototype.lineNo = function() {
                return lineNo(this);
            }, eventMixin(Line);
            // Convert a style as returned by a mode (either null, or a string
            // containing one or more styles) to a CSS style. This is cached,
            // and also looks for line-wide styles.
            var measureText, styleToClassCache = {}, styleToClassCacheWithMode = {}, operationGroup = null, orphanDelayedCallbacks = null, nullRect = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, NativeScrollbars = function(place, scroll, cm) {
                this.cm = cm;
                var vert = this.vert = elt("div", [ elt("div", null, null, "min-width: 1px") ], "CodeMirror-vscrollbar"), horiz = this.horiz = elt("div", [ elt("div", null, null, "height: 100%; min-height: 1px") ], "CodeMirror-hscrollbar");
                vert.tabIndex = horiz.tabIndex = -1, place(vert), place(horiz), on(vert, "scroll", function() {
                    vert.clientHeight && scroll(vert.scrollTop, "vertical");
                }), on(horiz, "scroll", function() {
                    horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal");
                }), this.checkedZeroWidth = !1, // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
                ie && ie_version < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
            };
            NativeScrollbars.prototype.update = function(measure) {
                var needsH = measure.scrollWidth > measure.clientWidth + 1, needsV = measure.scrollHeight > measure.clientHeight + 1, sWidth = measure.nativeBarWidth;
                if (needsV) {
                    this.vert.style.display = "block", this.vert.style.bottom = needsH ? sWidth + "px" : "0";
                    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                    // A bug in IE8 can cause this value to be negative, so guard it.
                    this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
                } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
                if (needsH) {
                    this.horiz.style.display = "block", this.horiz.style.right = needsV ? sWidth + "px" : "0", 
                    this.horiz.style.left = measure.barLeft + "px";
                    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                    this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
                } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
                return !this.checkedZeroWidth && measure.clientHeight > 0 && (0 == sWidth && this.zeroWidthHack(), 
                this.checkedZeroWidth = !0), {
                    right: needsV ? sWidth : 0,
                    bottom: needsH ? sWidth : 0
                };
            }, NativeScrollbars.prototype.setScrollLeft = function(pos) {
                this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
            }, NativeScrollbars.prototype.setScrollTop = function(pos) {
                this.vert.scrollTop != pos && (this.vert.scrollTop = pos), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
            }, NativeScrollbars.prototype.zeroWidthHack = function() {
                var w = mac && !mac_geMountainLion ? "12px" : "18px";
                this.horiz.style.height = this.vert.style.width = w, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", 
                this.disableHoriz = new Delayed(), this.disableVert = new Delayed();
            }, NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
                function maybeDisable() {
                    // To find out whether the scrollbar is still visible, we
                    // check whether the element under the pixel in the bottom
                    // right corner of the scrollbar box is the scrollbar box
                    // itself (when the bar is still visible) or its filler child
                    // (when the bar is hidden). If it is still visible, we keep
                    // it enabled, if it's hidden, we disable pointer events.
                    var box = bar.getBoundingClientRect(), elt = "vert" == type ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
                    elt != bar ? bar.style.pointerEvents = "none" : delay.set(1e3, maybeDisable);
                }
                bar.style.pointerEvents = "auto", delay.set(1e3, maybeDisable);
            }, NativeScrollbars.prototype.clear = function() {
                var parent = this.horiz.parentNode;
                parent.removeChild(this.horiz), parent.removeChild(this.vert);
            };
            var NullScrollbars = function() {};
            NullScrollbars.prototype.update = function() {
                return {
                    bottom: 0,
                    right: 0
                };
            }, NullScrollbars.prototype.setScrollLeft = function() {}, NullScrollbars.prototype.setScrollTop = function() {}, 
            NullScrollbars.prototype.clear = function() {};
            var scrollbarModel = {
                native: NativeScrollbars,
                null: NullScrollbars
            }, nextOpId = 0, DisplayUpdate = function(cm, viewport, force) {
                var display = cm.display;
                this.viewport = viewport, // Store some values that we'll need later (but don't want to force a relayout for)
                this.visible = visibleLines(display, cm.doc, viewport), this.editorIsHidden = !display.wrapper.offsetWidth, 
                this.wrapperHeight = display.wrapper.clientHeight, this.wrapperWidth = display.wrapper.clientWidth, 
                this.oldDisplayWidth = displayWidth(cm), this.force = force, this.dims = getDimensions(cm), 
                this.events = [];
            };
            DisplayUpdate.prototype.signal = function(emitter, type) {
                hasHandler(emitter, type) && this.events.push(arguments);
            }, DisplayUpdate.prototype.finish = function() {
                for (var i = 0; i < this.events.length; i++) signal.apply(null, this.events[i]);
            };
            // Since the delta values reported on mouse wheel events are
            // unstandardized between browsers and even browser versions, and
            // generally horribly unpredictable, this code starts by measuring
            // the scroll effect that the first few mouse wheel events have,
            // and, from that, detects the way it can convert deltas to pixel
            // offsets afterwards.
            //
            // The reason we want to know the amount a wheel event will scroll
            // is that it gives us a chance to update the display before the
            // actual scrolling happens, reducing flickering.
            var wheelSamples = 0, wheelPixelsPerUnit = null;
            // Fill in a browser-detected starting value on browsers where we
            // know one. These don't have to be accurate -- the result of them
            // being wrong would just be a slight flicker on the first wheel
            // scroll (if it is large enough).
            ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
            // Selection objects are immutable. A new one is created every time
            // the selection changes. A selection is one or more non-overlapping
            // (and non-touching) ranges, sorted, and an integer that indicates
            // which one is the primary selection (the one that's scrolled into
            // view, that getCursor returns, etc).
            var Selection = function(ranges, primIndex) {
                this.ranges = ranges, this.primIndex = primIndex;
            };
            Selection.prototype.primary = function() {
                return this.ranges[this.primIndex];
            }, Selection.prototype.equals = function(other) {
                if (other == this) return !0;
                if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return !1;
                for (var i = 0; i < this.ranges.length; i++) {
                    var here = this.ranges[i], there = other.ranges[i];
                    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) return !1;
                }
                return !0;
            }, Selection.prototype.deepCopy = function() {
                for (var out = [], i = 0; i < this.ranges.length; i++) out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
                return new Selection(out, this.primIndex);
            }, Selection.prototype.somethingSelected = function() {
                for (var i = 0; i < this.ranges.length; i++) if (!this.ranges[i].empty()) return !0;
                return !1;
            }, Selection.prototype.contains = function(pos, end) {
                end || (end = pos);
                for (var i = 0; i < this.ranges.length; i++) {
                    var range = this.ranges[i];
                    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) return i;
                }
                return -1;
            };
            var Range = function(anchor, head) {
                this.anchor = anchor, this.head = head;
            };
            Range.prototype.from = function() {
                return minPos(this.anchor, this.head);
            }, Range.prototype.to = function() {
                return maxPos(this.anchor, this.head);
            }, Range.prototype.empty = function() {
                return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
            }, LeafChunk.prototype = {
                chunkSize: function() {
                    return this.lines.length;
                },
                // Remove the n lines at offset 'at'.
                removeInner: function(at, n) {
                    for (var i = at, e = at + n; i < e; ++i) {
                        var line = this.lines[i];
                        this.height -= line.height, cleanUpLine(line), signalLater(line, "delete");
                    }
                    this.lines.splice(at, n);
                },
                // Helper used to collapse a small branch into a single leaf.
                collapse: function(lines) {
                    lines.push.apply(lines, this.lines);
                },
                // Insert the given array of lines at offset 'at', count them as
                // having the given height.
                insertInner: function(at, lines, height) {
                    this.height += height, this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                    for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
                },
                // Used to iterate over a part of the tree.
                iterN: function(at, n, op) {
                    for (var e = at + n; at < e; ++at) if (op(this.lines[at])) return !0;
                }
            }, BranchChunk.prototype = {
                chunkSize: function() {
                    return this.size;
                },
                removeInner: function(at, n) {
                    this.size -= n;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i], sz = child.chunkSize();
                        if (at < sz) {
                            var rm = Math.min(n, sz - at), oldHeight = child.height;
                            if (child.removeInner(at, rm), this.height -= oldHeight - child.height, sz == rm && (this.children.splice(i--, 1), 
                            child.parent = null), 0 == (n -= rm)) break;
                            at = 0;
                        } else at -= sz;
                    }
                    // If the result is smaller than 25 lines, ensure that it is a
                    // single leaf node.
                    if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                        var lines = [];
                        this.collapse(lines), this.children = [ new LeafChunk(lines) ], this.children[0].parent = this;
                    }
                },
                collapse: function(lines) {
                    for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
                },
                insertInner: function(at, lines, height) {
                    this.size += lines.length, this.height += height;
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i], sz = child.chunkSize();
                        if (at <= sz) {
                            if (child.insertInner(at, lines, height), child.lines && child.lines.length > 50) {
                                for (var remaining = child.lines.length % 25 + 25, pos = remaining; pos < child.lines.length; ) {
                                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                                    child.height -= leaf.height, this.children.splice(++i, 0, leaf), leaf.parent = this;
                                }
                                child.lines = child.lines.slice(0, remaining), this.maybeSpill();
                            }
                            break;
                        }
                        at -= sz;
                    }
                },
                // When a node has grown, check whether it should be split.
                maybeSpill: function() {
                    if (!(this.children.length <= 10)) {
                        var me = this;
                        do {
                            var spilled = me.children.splice(me.children.length - 5, 5), sibling = new BranchChunk(spilled);
                            if (me.parent) {
                                me.size -= sibling.size, me.height -= sibling.height;
                                var myIndex = indexOf(me.parent.children, me);
                                me.parent.children.splice(myIndex + 1, 0, sibling);
                            } else {
                                // Become the parent node
                                var copy = new BranchChunk(me.children);
                                copy.parent = me, me.children = [ copy, sibling ], me = copy;
                            }
                            sibling.parent = me.parent;
                        } while (me.children.length > 10);
                        me.parent.maybeSpill();
                    }
                },
                iterN: function(at, n, op) {
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i], sz = child.chunkSize();
                        if (at < sz) {
                            var used = Math.min(n, sz - at);
                            if (child.iterN(at, used, op)) return !0;
                            if (0 == (n -= used)) break;
                            at = 0;
                        } else at -= sz;
                    }
                }
            };
            // Line widgets are block elements displayed above or below a line.
            var LineWidget = function(doc, node, options) {
                if (options) for (var opt in options) options.hasOwnProperty(opt) && (this[opt] = options[opt]);
                this.doc = doc, this.node = node;
            };
            LineWidget.prototype.clear = function() {
                var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
                if (null != no && ws) {
                    for (var i = 0; i < ws.length; ++i) ws[i] == this && ws.splice(i--, 1);
                    ws.length || (line.widgets = null);
                    var height = widgetHeight(this);
                    updateLineHeight(line, Math.max(0, line.height - height)), cm && (runInOp(cm, function() {
                        adjustScrollWhenAboveVisible(cm, line, -height), regLineChange(cm, no, "widget");
                    }), signalLater(cm, "lineWidgetCleared", cm, this, no));
                }
            }, LineWidget.prototype.changed = function() {
                var this$1 = this, oldH = this.height, cm = this.doc.cm, line = this.line;
                this.height = null;
                var diff = widgetHeight(this) - oldH;
                diff && (lineIsHidden(this.doc, line) || updateLineHeight(line, line.height + diff), 
                cm && runInOp(cm, function() {
                    cm.curOp.forceUpdate = !0, adjustScrollWhenAboveVisible(cm, line, diff), signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
                }));
            }, eventMixin(LineWidget);
            // TEXTMARKERS
            // Created with markText and setBookmark methods. A TextMarker is a
            // handle that can be used to clear or find a marked position in the
            // document. Line objects hold arrays (markedSpans) containing
            // {from, to, marker} object pointing to such marker objects, and
            // indicating that such a marker is present on that line. Multiple
            // lines may point to the same marker when it spans across lines.
            // The spans will have null for their from/to properties when the
            // marker continues beyond the start/end of the line. Markers have
            // links back to the lines they currently touch.
            // Collapsed markers have unique ids, in order to be able to order
            // them, which is needed for uniquely determining an outer marker
            // when they overlap (they may nest, but not partially overlap).
            var nextMarkerId = 0, TextMarker = function(doc, type) {
                this.lines = [], this.type = type, this.doc = doc, this.id = ++nextMarkerId;
            };
            // Clear the marker.
            TextMarker.prototype.clear = function() {
                if (!this.explicitlyCleared) {
                    var cm = this.doc.cm, withOp = cm && !cm.curOp;
                    if (withOp && startOperation(cm), hasHandler(this, "clear")) {
                        var found = this.find();
                        found && signalLater(this, "clear", found.from, found.to);
                    }
                    for (var min = null, max = null, i = 0; i < this.lines.length; ++i) {
                        var line = this.lines[i], span = getMarkedSpanFor(line.markedSpans, this);
                        cm && !this.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)), 
                        null != span.from && (min = lineNo(line))), line.markedSpans = removeMarkedSpan(line.markedSpans, span), 
                        null == span.from && this.collapsed && !lineIsHidden(this.doc, line) && cm && updateLineHeight(line, textHeight(cm.display));
                    }
                    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
                        var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
                        len > cm.display.maxLineLength && (cm.display.maxLine = visual, cm.display.maxLineLength = len, 
                        cm.display.maxLineChanged = !0);
                    }
                    null != min && cm && this.collapsed && regChange(cm, min, max + 1), this.lines.length = 0, 
                    this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, 
                    cm && reCheckSelection(cm.doc)), cm && signalLater(cm, "markerCleared", cm, this, min, max), 
                    withOp && endOperation(cm), this.parent && this.parent.clear();
                }
            }, // Find the position of the marker in the document. Returns a {from,
            // to} object by default. Side can be passed to get a specific side
            // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
            // Pos objects returned contain a line object, rather than a line
            // number (used to prevent looking up the same line twice).
            TextMarker.prototype.find = function(side, lineObj) {
                null == side && "bookmark" == this.type && (side = 1);
                for (var from, to, i = 0; i < this.lines.length; ++i) {
                    var line = this.lines[i], span = getMarkedSpanFor(line.markedSpans, this);
                    if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from), 
                    side == -1)) return from;
                    if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to), 1 == side)) return to;
                }
                return from && {
                    from: from,
                    to: to
                };
            }, // Signals that the marker's widget changed, and surrounding layout
            // should be recomputed.
            TextMarker.prototype.changed = function() {
                var this$1 = this, pos = this.find(-1, !0), widget = this, cm = this.doc.cm;
                pos && cm && runInOp(cm, function() {
                    var line = pos.line, lineN = lineNo(pos.line), view = findViewForLine(cm, lineN);
                    if (view && (clearLineMeasurementCacheFor(view), cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0), 
                    cm.curOp.updateMaxLine = !0, !lineIsHidden(widget.doc, line) && null != widget.height) {
                        var oldHeight = widget.height;
                        widget.height = null;
                        var dHeight = widgetHeight(widget) - oldHeight;
                        dHeight && updateLineHeight(line, line.height + dHeight);
                    }
                    signalLater(cm, "markerChanged", cm, this$1);
                });
            }, TextMarker.prototype.attachLine = function(line) {
                if (!this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    op.maybeHiddenMarkers && indexOf(op.maybeHiddenMarkers, this) != -1 || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
                }
                this.lines.push(line);
            }, TextMarker.prototype.detachLine = function(line) {
                if (this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
                }
            }, eventMixin(TextMarker);
            // SHARED TEXTMARKERS
            // A shared marker spans multiple linked documents. It is
            // implemented as a meta-marker-object controlling multiple normal
            // markers.
            var SharedTextMarker = function(markers, primary) {
                this.markers = markers, this.primary = primary;
                for (var i = 0; i < markers.length; ++i) markers[i].parent = this;
            };
            SharedTextMarker.prototype.clear = function() {
                if (!this.explicitlyCleared) {
                    this.explicitlyCleared = !0;
                    for (var i = 0; i < this.markers.length; ++i) this.markers[i].clear();
                    signalLater(this, "clear");
                }
            }, SharedTextMarker.prototype.find = function(side, lineObj) {
                return this.primary.find(side, lineObj);
            }, eventMixin(SharedTextMarker);
            var nextDocId = 0, Doc = function(text, mode, firstLine, lineSep, direction) {
                if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep, direction);
                null == firstLine && (firstLine = 0), BranchChunk.call(this, [ new LeafChunk([ new Line("", null) ]) ]), 
                this.first = firstLine, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, 
                this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = simpleSelection(start), this.history = new History(null), this.id = ++nextDocId, 
                this.modeOption = mode, this.lineSep = lineSep, this.direction = "rtl" == direction ? "rtl" : "ltr", 
                this.extend = !1, "string" == typeof text && (text = this.splitLines(text)), updateDoc(this, {
                    from: start,
                    to: start,
                    text: text
                }), setSelection(this, simpleSelection(start), sel_dontScroll);
            };
            Doc.prototype = createObj(BranchChunk.prototype, {
                constructor: Doc,
                // Iterate over the document. Supports two forms -- with only one
                // argument, it calls that for each line in the document. With
                // three, it iterates over the range given by the first two (with
                // the second being non-inclusive).
                iter: function(from, to, op) {
                    op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from);
                },
                // Non-public interface for adding and removing lines.
                insert: function(at, lines) {
                    for (var height = 0, i = 0; i < lines.length; ++i) height += lines[i].height;
                    this.insertInner(at - this.first, lines, height);
                },
                remove: function(at, n) {
                    this.removeInner(at - this.first, n);
                },
                // From here, the methods are part of the public interface. Most
                // are also available from CodeMirror (editor) instances.
                getValue: function(lineSep) {
                    var lines = getLines(this, this.first, this.first + this.size);
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                setValue: docMethodOp(function(code) {
                    var top = Pos(this.first, 0), last = this.first + this.size - 1;
                    makeChange(this, {
                        from: top,
                        to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code),
                        origin: "setValue",
                        full: !0
                    }, !0), this.cm && scrollToCoords(this.cm, 0, 0), setSelection(this, simpleSelection(top), sel_dontScroll);
                }),
                replaceRange: function(code, from, to, origin) {
                    from = clipPos(this, from), to = to ? clipPos(this, to) : from, replaceRange(this, code, from, to, origin);
                },
                getRange: function(from, to, lineSep) {
                    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                getLine: function(line) {
                    var l = this.getLineHandle(line);
                    return l && l.text;
                },
                getLineHandle: function(line) {
                    if (isLine(this, line)) return getLine(this, line);
                },
                getLineNumber: function(line) {
                    return lineNo(line);
                },
                getLineHandleVisualStart: function(line) {
                    return "number" == typeof line && (line = getLine(this, line)), visualLine(line);
                },
                lineCount: function() {
                    return this.size;
                },
                firstLine: function() {
                    return this.first;
                },
                lastLine: function() {
                    return this.first + this.size - 1;
                },
                clipPos: function(pos) {
                    return clipPos(this, pos);
                },
                getCursor: function(start) {
                    var pos, range = this.sel.primary();
                    return pos = null == start || "head" == start ? range.head : "anchor" == start ? range.anchor : "end" == start || "to" == start || start === !1 ? range.to() : range.from();
                },
                listSelections: function() {
                    return this.sel.ranges;
                },
                somethingSelected: function() {
                    return this.sel.somethingSelected();
                },
                setCursor: docMethodOp(function(line, ch, options) {
                    setSimpleSelection(this, clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options);
                }),
                setSelection: docMethodOp(function(anchor, head, options) {
                    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
                }),
                extendSelection: docMethodOp(function(head, other, options) {
                    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
                }),
                extendSelections: docMethodOp(function(heads, options) {
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                extendSelectionsBy: docMethodOp(function(f, options) {
                    var heads = map(this.sel.ranges, f);
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                setSelections: docMethodOp(function(ranges, primary, options) {
                    if (ranges.length) {
                        for (var out = [], i = 0; i < ranges.length; i++) out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
                        null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex)), 
                        setSelection(this, normalizeSelection(this.cm, out, primary), options);
                    }
                }),
                addSelection: docMethodOp(function(anchor, head, options) {
                    var ranges = this.sel.ranges.slice(0);
                    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor))), setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
                }),
                getSelection: function(lineSep) {
                    for (var lines, ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                        lines = lines ? lines.concat(sel) : sel;
                    }
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                getSelections: function(lineSep) {
                    for (var parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                        lineSep !== !1 && (sel = sel.join(lineSep || this.lineSeparator())), parts[i] = sel;
                    }
                    return parts;
                },
                replaceSelection: function(code, collapse, origin) {
                    for (var dup = [], i = 0; i < this.sel.ranges.length; i++) dup[i] = code;
                    this.replaceSelections(dup, collapse, origin || "+input");
                },
                replaceSelections: docMethodOp(function(code, collapse, origin) {
                    for (var changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                        var range = sel.ranges[i];
                        changes[i] = {
                            from: range.from(),
                            to: range.to(),
                            text: this.splitLines(code[i]),
                            origin: origin
                        };
                    }
                    for (var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse), i$1 = changes.length - 1; i$1 >= 0; i$1--) makeChange(this, changes[i$1]);
                    newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm);
                }),
                undo: docMethodOp(function() {
                    makeChangeFromHistory(this, "undo");
                }),
                redo: docMethodOp(function() {
                    makeChangeFromHistory(this, "redo");
                }),
                undoSelection: docMethodOp(function() {
                    makeChangeFromHistory(this, "undo", !0);
                }),
                redoSelection: docMethodOp(function() {
                    makeChangeFromHistory(this, "redo", !0);
                }),
                setExtending: function(val) {
                    this.extend = val;
                },
                getExtending: function() {
                    return this.extend;
                },
                historySize: function() {
                    for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++) hist.done[i].ranges || ++done;
                    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) hist.undone[i$1].ranges || ++undone;
                    return {
                        undo: done,
                        redo: undone
                    };
                },
                clearHistory: function() {
                    var this$1 = this;
                    this.history = new History(this.history.maxGeneration), linkedDocs(this, function(doc) {
                        return doc.history = this$1.history;
                    }, !0);
                },
                markClean: function() {
                    this.cleanGeneration = this.changeGeneration(!0);
                },
                changeGeneration: function(forceSplit) {
                    return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), 
                    this.history.generation;
                },
                isClean: function(gen) {
                    return this.history.generation == (gen || this.cleanGeneration);
                },
                getHistory: function() {
                    return {
                        done: copyHistoryArray(this.history.done),
                        undone: copyHistoryArray(this.history.undone)
                    };
                },
                setHistory: function(histData) {
                    var hist = this.history = new History(this.history.maxGeneration);
                    hist.done = copyHistoryArray(histData.done.slice(0), null, !0), hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0);
                },
                setGutterMarker: docMethodOp(function(line, gutterID, value) {
                    return changeLine(this, line, "gutter", function(line) {
                        var markers = line.gutterMarkers || (line.gutterMarkers = {});
                        return markers[gutterID] = value, !value && isEmpty(markers) && (line.gutterMarkers = null), 
                        !0;
                    });
                }),
                clearGutter: docMethodOp(function(gutterID) {
                    var this$1 = this;
                    this.iter(function(line) {
                        line.gutterMarkers && line.gutterMarkers[gutterID] && changeLine(this$1, line, "gutter", function() {
                            return line.gutterMarkers[gutterID] = null, isEmpty(line.gutterMarkers) && (line.gutterMarkers = null), 
                            !0;
                        });
                    });
                }),
                lineInfo: function(line) {
                    var n;
                    if ("number" == typeof line) {
                        if (!isLine(this, line)) return null;
                        if (n = line, line = getLine(this, line), !line) return null;
                    } else if (n = lineNo(line), null == n) return null;
                    return {
                        line: n,
                        handle: line,
                        text: line.text,
                        gutterMarkers: line.gutterMarkers,
                        textClass: line.textClass,
                        bgClass: line.bgClass,
                        wrapClass: line.wrapClass,
                        widgets: line.widgets
                    };
                },
                addLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                        var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                        if (line[prop]) {
                            if (classTest(cls).test(line[prop])) return !1;
                            line[prop] += " " + cls;
                        } else line[prop] = cls;
                        return !0;
                    });
                }),
                removeLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                        var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass", cur = line[prop];
                        if (!cur) return !1;
                        if (null == cls) line[prop] = null; else {
                            var found = cur.match(classTest(cls));
                            if (!found) return !1;
                            var end = found.index + found[0].length;
                            line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null;
                        }
                        return !0;
                    });
                }),
                addLineWidget: docMethodOp(function(handle, node, options) {
                    return addLineWidget(this, handle, node, options);
                }),
                removeLineWidget: function(widget) {
                    widget.clear();
                },
                markText: function(from, to, options) {
                    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
                },
                setBookmark: function(pos, options) {
                    var realOpts = {
                        replacedWith: options && (null == options.nodeType ? options.widget : options),
                        insertLeft: options && options.insertLeft,
                        clearWhenEmpty: !1,
                        shared: options && options.shared,
                        handleMouseEvents: options && options.handleMouseEvents
                    };
                    return pos = clipPos(this, pos), markText(this, pos, pos, realOpts, "bookmark");
                },
                findMarksAt: function(pos) {
                    pos = clipPos(this, pos);
                    var markers = [], spans = getLine(this, pos.line).markedSpans;
                    if (spans) for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker);
                    }
                    return markers;
                },
                findMarks: function(from, to, filter) {
                    from = clipPos(this, from), to = clipPos(this, to);
                    var found = [], lineNo = from.line;
                    return this.iter(from.line, to.line + 1, function(line) {
                        var spans = line.markedSpans;
                        if (spans) for (var i = 0; i < spans.length; i++) {
                            var span = spans[i];
                            null != span.to && lineNo == from.line && from.ch >= span.to || null == span.from && lineNo != from.line || null != span.from && lineNo == to.line && span.from >= to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker);
                        }
                        ++lineNo;
                    }), found;
                },
                getAllMarks: function() {
                    var markers = [];
                    return this.iter(function(line) {
                        var sps = line.markedSpans;
                        if (sps) for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker);
                    }), markers;
                },
                posFromIndex: function(off) {
                    var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
                    return this.iter(function(line) {
                        var sz = line.text.length + sepSize;
                        return sz > off ? (ch = off, !0) : (off -= sz, void ++lineNo);
                    }), clipPos(this, Pos(lineNo, ch));
                },
                indexFromPos: function(coords) {
                    coords = clipPos(this, coords);
                    var index = coords.ch;
                    if (coords.line < this.first || coords.ch < 0) return 0;
                    var sepSize = this.lineSeparator().length;
                    return this.iter(this.first, coords.line, function(line) {
                        // iter aborts when callback returns a truthy value
                        index += line.text.length + sepSize;
                    }), index;
                },
                copy: function(copyHistory) {
                    var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
                    return doc.scrollTop = this.scrollTop, doc.scrollLeft = this.scrollLeft, doc.sel = this.sel, 
                    doc.extend = !1, copyHistory && (doc.history.undoDepth = this.history.undoDepth, 
                    doc.setHistory(this.getHistory())), doc;
                },
                linkedDoc: function(options) {
                    options || (options = {});
                    var from = this.first, to = this.first + this.size;
                    null != options.from && options.from > from && (from = options.from), null != options.to && options.to < to && (to = options.to);
                    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
                    return options.sharedHist && (copy.history = this.history), (this.linked || (this.linked = [])).push({
                        doc: copy,
                        sharedHist: options.sharedHist
                    }), copy.linked = [ {
                        doc: this,
                        isParent: !0,
                        sharedHist: options.sharedHist
                    } ], copySharedMarkers(copy, findSharedMarkers(this)), copy;
                },
                unlinkDoc: function(other) {
                    if (other instanceof CodeMirror && (other = other.doc), this.linked) for (var i = 0; i < this.linked.length; ++i) {
                        var link = this.linked[i];
                        if (link.doc == other) {
                            this.linked.splice(i, 1), other.unlinkDoc(this), detachSharedMarkers(findSharedMarkers(this));
                            break;
                        }
                    }
                    // If the histories were shared, split them again
                    if (other.history == this.history) {
                        var splitIds = [ other.id ];
                        linkedDocs(other, function(doc) {
                            return splitIds.push(doc.id);
                        }, !0), other.history = new History(null), other.history.done = copyHistoryArray(this.history.done, splitIds), 
                        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
                    }
                },
                iterLinkedDocs: function(f) {
                    linkedDocs(this, f);
                },
                getMode: function() {
                    return this.mode;
                },
                getEditor: function() {
                    return this.cm;
                },
                splitLines: function(str) {
                    return this.lineSep ? str.split(this.lineSep) : splitLinesAuto(str);
                },
                lineSeparator: function() {
                    return this.lineSep || "\n";
                },
                setDirection: docMethodOp(function(dir) {
                    "rtl" != dir && (dir = "ltr"), dir != this.direction && (this.direction = dir, this.iter(function(line) {
                        return line.order = null;
                    }), this.cm && directionChanged(this.cm));
                })
            }), // Public alias.
            Doc.prototype.eachLine = Doc.prototype.iter;
            // Number keys
            for (var lastDrop = 0, globalsRegistered = !1, keyNames = {
                3: "Pause",
                8: "Backspace",
                9: "Tab",
                13: "Enter",
                16: "Shift",
                17: "Ctrl",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Esc",
                32: "Space",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "Left",
                38: "Up",
                39: "Right",
                40: "Down",
                44: "PrintScrn",
                45: "Insert",
                46: "Delete",
                59: ";",
                61: "=",
                91: "Mod",
                92: "Mod",
                93: "Mod",
                106: "*",
                107: "=",
                109: "-",
                110: ".",
                111: "/",
                145: "ScrollLock",
                173: "-",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                224: "Mod",
                63232: "Up",
                63233: "Down",
                63234: "Left",
                63235: "Right",
                63272: "Delete",
                63273: "Home",
                63275: "End",
                63276: "PageUp",
                63277: "PageDown",
                63302: "Insert"
            }, i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
            // Alphabetic keys
            for (var i$1 = 65; i$1 <= 90; i$1++) keyNames[i$1] = String.fromCharCode(i$1);
            // Function keys
            for (var i$2 = 1; i$2 <= 12; i$2++) keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
            var keyMap = {};
            keyMap.basic = {
                Left: "goCharLeft",
                Right: "goCharRight",
                Up: "goLineUp",
                Down: "goLineDown",
                End: "goLineEnd",
                Home: "goLineStartSmart",
                PageUp: "goPageUp",
                PageDown: "goPageDown",
                Delete: "delCharAfter",
                Backspace: "delCharBefore",
                "Shift-Backspace": "delCharBefore",
                Tab: "defaultTab",
                "Shift-Tab": "indentAuto",
                Enter: "newlineAndIndent",
                Insert: "toggleOverwrite",
                Esc: "singleSelection"
            }, // Note that the save and find-related commands aren't defined by
            // default. User code or addons can define them. Unknown commands
            // are simply ignored.
            keyMap.pcDefault = {
                "Ctrl-A": "selectAll",
                "Ctrl-D": "deleteLine",
                "Ctrl-Z": "undo",
                "Shift-Ctrl-Z": "redo",
                "Ctrl-Y": "redo",
                "Ctrl-Home": "goDocStart",
                "Ctrl-End": "goDocEnd",
                "Ctrl-Up": "goLineUp",
                "Ctrl-Down": "goLineDown",
                "Ctrl-Left": "goGroupLeft",
                "Ctrl-Right": "goGroupRight",
                "Alt-Left": "goLineStart",
                "Alt-Right": "goLineEnd",
                "Ctrl-Backspace": "delGroupBefore",
                "Ctrl-Delete": "delGroupAfter",
                "Ctrl-S": "save",
                "Ctrl-F": "find",
                "Ctrl-G": "findNext",
                "Shift-Ctrl-G": "findPrev",
                "Shift-Ctrl-F": "replace",
                "Shift-Ctrl-R": "replaceAll",
                "Ctrl-[": "indentLess",
                "Ctrl-]": "indentMore",
                "Ctrl-U": "undoSelection",
                "Shift-Ctrl-U": "redoSelection",
                "Alt-U": "redoSelection",
                fallthrough: "basic"
            }, // Very basic readline/emacs-style bindings, which are standard on Mac.
            keyMap.emacsy = {
                "Ctrl-F": "goCharRight",
                "Ctrl-B": "goCharLeft",
                "Ctrl-P": "goLineUp",
                "Ctrl-N": "goLineDown",
                "Alt-F": "goWordRight",
                "Alt-B": "goWordLeft",
                "Ctrl-A": "goLineStart",
                "Ctrl-E": "goLineEnd",
                "Ctrl-V": "goPageDown",
                "Shift-Ctrl-V": "goPageUp",
                "Ctrl-D": "delCharAfter",
                "Ctrl-H": "delCharBefore",
                "Alt-D": "delWordAfter",
                "Alt-Backspace": "delWordBefore",
                "Ctrl-K": "killLine",
                "Ctrl-T": "transposeChars",
                "Ctrl-O": "openLine"
            }, keyMap.macDefault = {
                "Cmd-A": "selectAll",
                "Cmd-D": "deleteLine",
                "Cmd-Z": "undo",
                "Shift-Cmd-Z": "redo",
                "Cmd-Y": "redo",
                "Cmd-Home": "goDocStart",
                "Cmd-Up": "goDocStart",
                "Cmd-End": "goDocEnd",
                "Cmd-Down": "goDocEnd",
                "Alt-Left": "goGroupLeft",
                "Alt-Right": "goGroupRight",
                "Cmd-Left": "goLineLeft",
                "Cmd-Right": "goLineRight",
                "Alt-Backspace": "delGroupBefore",
                "Ctrl-Alt-Backspace": "delGroupAfter",
                "Alt-Delete": "delGroupAfter",
                "Cmd-S": "save",
                "Cmd-F": "find",
                "Cmd-G": "findNext",
                "Shift-Cmd-G": "findPrev",
                "Cmd-Alt-F": "replace",
                "Shift-Cmd-Alt-F": "replaceAll",
                "Cmd-[": "indentLess",
                "Cmd-]": "indentMore",
                "Cmd-Backspace": "delWrappedLineLeft",
                "Cmd-Delete": "delWrappedLineRight",
                "Cmd-U": "undoSelection",
                "Shift-Cmd-U": "redoSelection",
                "Ctrl-Up": "goDocStart",
                "Ctrl-Down": "goDocEnd",
                fallthrough: [ "basic", "emacsy" ]
            }, keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault;
            // Commands are parameter-less actions that can be performed on an
            // editor, mostly used for keybindings.
            var commands = {
                selectAll: selectAll,
                singleSelection: function(cm) {
                    return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
                },
                killLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        if (range.empty()) {
                            var len = getLine(cm.doc, range.head.line).text.length;
                            return range.head.ch == len && range.head.line < cm.lastLine() ? {
                                from: range.head,
                                to: Pos(range.head.line + 1, 0)
                            } : {
                                from: range.head,
                                to: Pos(range.head.line, len)
                            };
                        }
                        return {
                            from: range.from(),
                            to: range.to()
                        };
                    });
                },
                deleteLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                        };
                    });
                },
                delLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: range.from()
                        };
                    });
                },
                delWrappedLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5, leftPos = cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                        return {
                            from: leftPos,
                            to: range.from()
                        };
                    });
                },
                delWrappedLineRight: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5, rightPos = cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        }, "div");
                        return {
                            from: range.from(),
                            to: rightPos
                        };
                    });
                },
                undo: function(cm) {
                    return cm.undo();
                },
                redo: function(cm) {
                    return cm.redo();
                },
                undoSelection: function(cm) {
                    return cm.undoSelection();
                },
                redoSelection: function(cm) {
                    return cm.redoSelection();
                },
                goDocStart: function(cm) {
                    return cm.extendSelection(Pos(cm.firstLine(), 0));
                },
                goDocEnd: function(cm) {
                    return cm.extendSelection(Pos(cm.lastLine()));
                },
                goLineStart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStart(cm, range.head.line);
                    }, {
                        origin: "+move",
                        bias: 1
                    });
                },
                goLineStartSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStartSmart(cm, range.head);
                    }, {
                        origin: "+move",
                        bias: 1
                    });
                },
                goLineEnd: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineEnd(cm, range.head.line);
                    }, {
                        origin: "+move",
                        bias: -1
                    });
                },
                goLineRight: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        }, "div");
                    }, sel_move);
                },
                goLineLeft: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                    }, sel_move);
                },
                goLineLeftSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5, pos = cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                        return pos.ch < cm.getLine(pos.line).search(/\S/) ? lineStartSmart(cm, range.head) : pos;
                    }, sel_move);
                },
                goLineUp: function(cm) {
                    return cm.moveV(-1, "line");
                },
                goLineDown: function(cm) {
                    return cm.moveV(1, "line");
                },
                goPageUp: function(cm) {
                    return cm.moveV(-1, "page");
                },
                goPageDown: function(cm) {
                    return cm.moveV(1, "page");
                },
                goCharLeft: function(cm) {
                    return cm.moveH(-1, "char");
                },
                goCharRight: function(cm) {
                    return cm.moveH(1, "char");
                },
                goColumnLeft: function(cm) {
                    return cm.moveH(-1, "column");
                },
                goColumnRight: function(cm) {
                    return cm.moveH(1, "column");
                },
                goWordLeft: function(cm) {
                    return cm.moveH(-1, "word");
                },
                goGroupRight: function(cm) {
                    return cm.moveH(1, "group");
                },
                goGroupLeft: function(cm) {
                    return cm.moveH(-1, "group");
                },
                goWordRight: function(cm) {
                    return cm.moveH(1, "word");
                },
                delCharBefore: function(cm) {
                    return cm.deleteH(-1, "codepoint");
                },
                delCharAfter: function(cm) {
                    return cm.deleteH(1, "char");
                },
                delWordBefore: function(cm) {
                    return cm.deleteH(-1, "word");
                },
                delWordAfter: function(cm) {
                    return cm.deleteH(1, "word");
                },
                delGroupBefore: function(cm) {
                    return cm.deleteH(-1, "group");
                },
                delGroupAfter: function(cm) {
                    return cm.deleteH(1, "group");
                },
                indentAuto: function(cm) {
                    return cm.indentSelection("smart");
                },
                indentMore: function(cm) {
                    return cm.indentSelection("add");
                },
                indentLess: function(cm) {
                    return cm.indentSelection("subtract");
                },
                insertTab: function(cm) {
                    return cm.replaceSelection("\t");
                },
                insertSoftTab: function(cm) {
                    for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                        var pos = ranges[i].from(), col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                        spaces.push(spaceStr(tabSize - col % tabSize));
                    }
                    cm.replaceSelections(spaces);
                },
                defaultTab: function(cm) {
                    cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab");
                },
                // Swap the two chars left and right of each selection's head.
                // Move cursor behind the two swapped characters afterwards.
                //
                // Doesn't consider line feeds a character.
                // Doesn't scan more than one line above to find a character.
                // Doesn't do anything on an empty line.
                // Doesn't do anything with non-empty selections.
                transposeChars: function(cm) {
                    return runInOp(cm, function() {
                        for (var ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++) if (ranges[i].empty()) {
                            var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                            if (line) if (cur.ch == line.length && (cur = new Pos(cur.line, cur.ch - 1)), cur.ch > 0) cur = new Pos(cur.line, cur.ch + 1), 
                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose"); else if (cur.line > cm.doc.first) {
                                var prev = getLine(cm.doc, cur.line - 1).text;
                                prev && (cur = new Pos(cur.line, 1), cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose"));
                            }
                            newSel.push(new Range(cur, cur));
                        }
                        cm.setSelections(newSel);
                    });
                },
                newlineAndIndent: function(cm) {
                    return runInOp(cm, function() {
                        for (var sels = cm.listSelections(), i = sels.length - 1; i >= 0; i--) cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
                        sels = cm.listSelections();
                        for (var i$1 = 0; i$1 < sels.length; i$1++) cm.indentLine(sels[i$1].from().line, null, !0);
                        ensureCursorVisible(cm);
                    });
                },
                openLine: function(cm) {
                    return cm.replaceSelection("\n", "start");
                },
                toggleOverwrite: function(cm) {
                    return cm.toggleOverwrite();
                }
            }, stopSeq = new Delayed(), lastStoppedKey = null, DOUBLECLICK_DELAY = 400, PastClick = function(time, pos, button) {
                this.time = time, this.pos = pos, this.button = button;
            };
            PastClick.prototype.compare = function(time, pos, button) {
                return this.time + DOUBLECLICK_DELAY > time && 0 == cmp(pos, this.pos) && button == this.button;
            };
            var lastClick, lastDoubleClick, Init = {
                toString: function() {
                    return "CodeMirror.Init";
                }
            }, defaults = {}, optionHandlers = {};
            // The default configuration options.
            CodeMirror.defaults = defaults, // Functions to run when options are changed.
            CodeMirror.optionHandlers = optionHandlers;
            var initHooks = [];
            CodeMirror.defineInitHook = function(f) {
                return initHooks.push(f);
            };
            // This will be set to a {lineWise: bool, text: [string]} object, so
            // that, when pasting, we know what kind of selections the copied
            // text was made out of.
            var lastCopied = null, ContentEditableInput = function(cm) {
                this.cm = cm, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, 
                this.polling = new Delayed(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;
            };
            ContentEditableInput.prototype.init = function(display) {
                function belongsToInput(e) {
                    for (var t = e.target; t; t = t.parentNode) {
                        if (t == div) return !0;
                        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) break;
                    }
                    return !1;
                }
                function onCopyCut(e) {
                    if (belongsToInput(e) && !signalDOMEvent(cm, e)) {
                        if (cm.somethingSelected()) setLastCopied({
                            lineWise: !1,
                            text: cm.getSelections()
                        }), "cut" == e.type && cm.replaceSelection("", null, "cut"); else {
                            if (!cm.options.lineWiseCopyCut) return;
                            var ranges = copyableRanges(cm);
                            setLastCopied({
                                lineWise: !0,
                                text: ranges.text
                            }), "cut" == e.type && cm.operation(function() {
                                cm.setSelections(ranges.ranges, 0, sel_dontScroll), cm.replaceSelection("", null, "cut");
                            });
                        }
                        if (e.clipboardData) {
                            e.clipboardData.clearData();
                            var content = lastCopied.text.join("\n");
                            if (// iOS exposes the clipboard API, but seems to discard content inserted into it
                            e.clipboardData.setData("Text", content), e.clipboardData.getData("Text") == content) return void e.preventDefault();
                        }
                        // Old-fashioned briefly-focus-a-textarea hack
                        var kludge = hiddenTextarea(), te = kludge.firstChild;
                        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild), te.value = lastCopied.text.join("\n");
                        var hadFocus = document.activeElement;
                        selectInput(te), setTimeout(function() {
                            cm.display.lineSpace.removeChild(kludge), hadFocus.focus(), hadFocus == div && input.showPrimarySelection();
                        }, 50);
                    }
                }
                var this$1 = this, input = this, cm = input.cm, div = input.div = display.lineDiv;
                disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize), 
                on(div, "paste", function(e) {
                    !belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm) || // IE doesn't fire input events, so we schedule a read for the pasted content in this way
                    ie_version <= 11 && setTimeout(operation(cm, function() {
                        return this$1.updateFromDOM();
                    }), 20);
                }), on(div, "compositionstart", function(e) {
                    this$1.composing = {
                        data: e.data,
                        done: !1
                    };
                }), on(div, "compositionupdate", function(e) {
                    this$1.composing || (this$1.composing = {
                        data: e.data,
                        done: !1
                    });
                }), on(div, "compositionend", function(e) {
                    this$1.composing && (e.data != this$1.composing.data && this$1.readFromDOMSoon(), 
                    this$1.composing.done = !0);
                }), on(div, "touchstart", function() {
                    return input.forceCompositionEnd();
                }), on(div, "input", function() {
                    this$1.composing || this$1.readFromDOMSoon();
                }), on(div, "copy", onCopyCut), on(div, "cut", onCopyCut);
            }, ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
                // Label for screenreaders, accessibility
                label ? this.div.setAttribute("aria-label", label) : this.div.removeAttribute("aria-label");
            }, ContentEditableInput.prototype.prepareSelection = function() {
                var result = prepareSelection(this.cm, !1);
                return result.focus = document.activeElement == this.div, result;
            }, ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
                info && this.cm.display.view.length && ((info.focus || takeFocus) && this.showPrimarySelection(), 
                this.showMultipleSelections(info));
            }, ContentEditableInput.prototype.getSelection = function() {
                return this.cm.display.wrapper.ownerDocument.getSelection();
            }, ContentEditableInput.prototype.showPrimarySelection = function() {
                var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary(), from = prim.from(), to = prim.to();
                if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) return void sel.removeAllRanges();
                var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
                if (!curAnchor || curAnchor.bad || !curFocus || curFocus.bad || 0 != cmp(minPos(curAnchor, curFocus), from) || 0 != cmp(maxPos(curAnchor, curFocus), to)) {
                    var view = cm.display.view, start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
                        node: view[0].measure.map[2],
                        offset: 0
                    }, end = to.line < cm.display.viewTo && posToDOM(cm, to);
                    if (!end) {
                        var measure = view[view.length - 1].measure, map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                        end = {
                            node: map[map.length - 1],
                            offset: map[map.length - 2] - map[map.length - 3]
                        };
                    }
                    if (!start || !end) return void sel.removeAllRanges();
                    var rng, old = sel.rangeCount && sel.getRangeAt(0);
                    try {
                        rng = range(start.node, start.offset, end.offset, end.node);
                    } catch (e) {}
                    // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
                    rng && (!gecko && cm.state.focused ? (sel.collapse(start.node, start.offset), rng.collapsed || (sel.removeAllRanges(), 
                    sel.addRange(rng))) : (sel.removeAllRanges(), sel.addRange(rng)), old && null == sel.anchorNode ? sel.addRange(old) : gecko && this.startGracePeriod()), 
                    this.rememberSelection();
                }
            }, ContentEditableInput.prototype.startGracePeriod = function() {
                var this$1 = this;
                clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
                    this$1.gracePeriod = !1, this$1.selectionChanged() && this$1.cm.operation(function() {
                        return this$1.cm.curOp.selectionChanged = !0;
                    });
                }, 20);
            }, ContentEditableInput.prototype.showMultipleSelections = function(info) {
                removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors), removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
            }, ContentEditableInput.prototype.rememberSelection = function() {
                var sel = this.getSelection();
                this.lastAnchorNode = sel.anchorNode, this.lastAnchorOffset = sel.anchorOffset, 
                this.lastFocusNode = sel.focusNode, this.lastFocusOffset = sel.focusOffset;
            }, ContentEditableInput.prototype.selectionInEditor = function() {
                var sel = this.getSelection();
                if (!sel.rangeCount) return !1;
                var node = sel.getRangeAt(0).commonAncestorContainer;
                return contains(this.div, node);
            }, ContentEditableInput.prototype.focus = function() {
                "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() && document.activeElement == this.div || this.showSelection(this.prepareSelection(), !0), 
                this.div.focus());
            }, ContentEditableInput.prototype.blur = function() {
                this.div.blur();
            }, ContentEditableInput.prototype.getField = function() {
                return this.div;
            }, ContentEditableInput.prototype.supportsTouch = function() {
                return !0;
            }, ContentEditableInput.prototype.receivedFocus = function() {
                function poll() {
                    input.cm.state.focused && (input.pollSelection(), input.polling.set(input.cm.options.pollInterval, poll));
                }
                var input = this;
                this.selectionInEditor() ? this.pollSelection() : runInOp(this.cm, function() {
                    return input.cm.curOp.selectionChanged = !0;
                }), this.polling.set(this.cm.options.pollInterval, poll);
            }, ContentEditableInput.prototype.selectionChanged = function() {
                var sel = this.getSelection();
                return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
            }, ContentEditableInput.prototype.pollSelection = function() {
                if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
                    var sel = this.getSelection(), cm = this.cm;
                    // On Android Chrome (version 56, at least), backspacing into an
                    // uneditable block element will put the cursor in that element,
                    // and then, because it's not editable, hide the virtual keyboard.
                    // Because Android doesn't allow us to actually detect backspace
                    // presses in a sane way, this code checks for when that happens
                    // and simulates a backspace press in this case.
                    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) return this.cm.triggerOnKeyDown({
                        type: "keydown",
                        keyCode: 8,
                        preventDefault: Math.abs
                    }), this.blur(), void this.focus();
                    if (!this.composing) {
                        this.rememberSelection();
                        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), head = domToPos(cm, sel.focusNode, sel.focusOffset);
                        anchor && head && runInOp(cm, function() {
                            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll), (anchor.bad || head.bad) && (cm.curOp.selectionChanged = !0);
                        });
                    }
                }
            }, ContentEditableInput.prototype.pollContent = function() {
                null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
                var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary(), from = sel.from(), to = sel.to();
                if (0 == from.ch && from.line > cm.firstLine() && (from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length)), 
                to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine() && (to = Pos(to.line + 1, 0)), 
                from.line < display.viewFrom || to.line > display.viewTo - 1) return !1;
                var fromIndex, fromLine, fromNode;
                from.line == display.viewFrom || 0 == (fromIndex = findViewIndex(cm, from.line)) ? (fromLine = lineNo(display.view[0].line), 
                fromNode = display.view[0].node) : (fromLine = lineNo(display.view[fromIndex].line), 
                fromNode = display.view[fromIndex - 1].node.nextSibling);
                var toLine, toNode, toIndex = findViewIndex(cm, to.line);
                if (toIndex == display.view.length - 1 ? (toLine = display.viewTo - 1, toNode = display.lineDiv.lastChild) : (toLine = lineNo(display.view[toIndex + 1].line) - 1, 
                toNode = display.view[toIndex + 1].node.previousSibling), !fromNode) return !1;
                for (var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine)), oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length)); newText.length > 1 && oldText.length > 1; ) if (lst(newText) == lst(oldText)) newText.pop(), 
                oldText.pop(), toLine--; else {
                    if (newText[0] != oldText[0]) break;
                    newText.shift(), oldText.shift(), fromLine++;
                }
                for (var cutFront = 0, cutEnd = 0, newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length); cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront); ) ++cutFront;
                for (var newBot = lst(newText), oldBot = lst(oldText), maxCutEnd = Math.min(newBot.length - (1 == newText.length ? cutFront : 0), oldBot.length - (1 == oldText.length ? cutFront : 0)); cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) ++cutEnd;
                // Try to move start of change to start of selection if ambiguous
                if (1 == newText.length && 1 == oldText.length && fromLine == from.line) for (;cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) cutFront--, 
                cutEnd++;
                newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, ""), 
                newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
                var chFrom = Pos(fromLine, cutFront), chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
                return newText.length > 1 || newText[0] || cmp(chFrom, chTo) ? (replaceRange(cm.doc, newText, chFrom, chTo, "+input"), 
                !0) : void 0;
            }, ContentEditableInput.prototype.ensurePolled = function() {
                this.forceCompositionEnd();
            }, ContentEditableInput.prototype.reset = function() {
                this.forceCompositionEnd();
            }, ContentEditableInput.prototype.forceCompositionEnd = function() {
                this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), 
                this.div.blur(), this.div.focus());
            }, ContentEditableInput.prototype.readFromDOMSoon = function() {
                var this$1 = this;
                null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
                    if (this$1.readDOMTimeout = null, this$1.composing) {
                        if (!this$1.composing.done) return;
                        this$1.composing = null;
                    }
                    this$1.updateFromDOM();
                }, 80));
            }, ContentEditableInput.prototype.updateFromDOM = function() {
                var this$1 = this;
                !this.cm.isReadOnly() && this.pollContent() || runInOp(this.cm, function() {
                    return regChange(this$1.cm);
                });
            }, ContentEditableInput.prototype.setUneditable = function(node) {
                node.contentEditable = "false";
            }, ContentEditableInput.prototype.onKeyPress = function(e) {
                0 == e.charCode || this.composing || (e.preventDefault(), this.cm.isReadOnly() || operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0));
            }, ContentEditableInput.prototype.readOnlyChanged = function(val) {
                this.div.contentEditable = String("nocursor" != val);
            }, ContentEditableInput.prototype.onContextMenu = function() {}, ContentEditableInput.prototype.resetPosition = function() {}, 
            ContentEditableInput.prototype.needsContentAttribute = !0;
            // TEXTAREA INPUT STYLE
            var TextareaInput = function(cm) {
                this.cm = cm, // See input.poll and input.reset
                this.prevInput = "", // Flag that indicates whether we expect input to appear real soon
                // now (after some event like 'keypress' or 'input') and are
                // polling intensively.
                this.pollingFast = !1, // Self-resetting timeout for the poller
                this.polling = new Delayed(), // Used to work around IE issue with selection being forgotten when focus moves away from textarea
                this.hasSelection = !1, this.composing = null;
            };
            TextareaInput.prototype.init = function(display) {
                function prepareCopyCut(e) {
                    if (!signalDOMEvent(cm, e)) {
                        if (cm.somethingSelected()) setLastCopied({
                            lineWise: !1,
                            text: cm.getSelections()
                        }); else {
                            if (!cm.options.lineWiseCopyCut) return;
                            var ranges = copyableRanges(cm);
                            setLastCopied({
                                lineWise: !0,
                                text: ranges.text
                            }), "cut" == e.type ? cm.setSelections(ranges.ranges, null, sel_dontScroll) : (input.prevInput = "", 
                            te.value = ranges.text.join("\n"), selectInput(te));
                        }
                        "cut" == e.type && (cm.state.cutIncoming = +new Date());
                    }
                }
                var this$1 = this, input = this, cm = this.cm;
                this.createField(display);
                var te = this.textarea;
                display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild), // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
                ios && (te.style.width = "0px"), on(te, "input", function() {
                    ie && ie_version >= 9 && this$1.hasSelection && (this$1.hasSelection = null), input.poll();
                }), on(te, "paste", function(e) {
                    signalDOMEvent(cm, e) || handlePaste(e, cm) || (cm.state.pasteIncoming = +new Date(), 
                    input.fastPoll());
                }), on(te, "cut", prepareCopyCut), on(te, "copy", prepareCopyCut), on(display.scroller, "paste", function(e) {
                    if (!eventInWidget(display, e) && !signalDOMEvent(cm, e)) {
                        if (!te.dispatchEvent) return cm.state.pasteIncoming = +new Date(), void input.focus();
                        // Pass the `paste` event to the textarea so it's handled by its event listener.
                        var event = new Event("paste");
                        event.clipboardData = e.clipboardData, te.dispatchEvent(event);
                    }
                }), // Prevent normal selection in the editor (we handle our own)
                on(display.lineSpace, "selectstart", function(e) {
                    eventInWidget(display, e) || e_preventDefault(e);
                }), on(te, "compositionstart", function() {
                    var start = cm.getCursor("from");
                    input.composing && input.composing.range.clear(), input.composing = {
                        start: start,
                        range: cm.markText(start, cm.getCursor("to"), {
                            className: "CodeMirror-composing"
                        })
                    };
                }), on(te, "compositionend", function() {
                    input.composing && (input.poll(), input.composing.range.clear(), input.composing = null);
                });
            }, TextareaInput.prototype.createField = function(_display) {
                // Wraps and hides input textarea
                this.wrapper = hiddenTextarea(), // The semihidden textarea that is focused when the editor is
                // focused, and receives input.
                this.textarea = this.wrapper.firstChild;
            }, TextareaInput.prototype.screenReaderLabelChanged = function(label) {
                // Label for screenreaders, accessibility
                label ? this.textarea.setAttribute("aria-label", label) : this.textarea.removeAttribute("aria-label");
            }, TextareaInput.prototype.prepareSelection = function() {
                // Redraw the selection and/or cursor
                var cm = this.cm, display = cm.display, doc = cm.doc, result = prepareSelection(cm);
                // Move the hidden textarea near the cursor to prevent scrolling artifacts
                if (cm.options.moveInputWithCursor) {
                    var headPos = cursorCoords(cm, doc.sel.primary().head, "div"), wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
                    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)), 
                    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
                }
                return result;
            }, TextareaInput.prototype.showSelection = function(drawn) {
                var cm = this.cm, display = cm.display;
                removeChildrenAndAdd(display.cursorDiv, drawn.cursors), removeChildrenAndAdd(display.selectionDiv, drawn.selection), 
                null != drawn.teTop && (this.wrapper.style.top = drawn.teTop + "px", this.wrapper.style.left = drawn.teLeft + "px");
            }, // Reset the input to correspond to the selection (or to be empty,
            // when not typing and nothing is selected)
            TextareaInput.prototype.reset = function(typing) {
                if (!this.contextMenuPending && !this.composing) {
                    var cm = this.cm;
                    if (cm.somethingSelected()) {
                        this.prevInput = "";
                        var content = cm.getSelection();
                        this.textarea.value = content, cm.state.focused && selectInput(this.textarea), ie && ie_version >= 9 && (this.hasSelection = content);
                    } else typing || (this.prevInput = this.textarea.value = "", ie && ie_version >= 9 && (this.hasSelection = null));
                }
            }, TextareaInput.prototype.getField = function() {
                return this.textarea;
            }, TextareaInput.prototype.supportsTouch = function() {
                return !1;
            }, TextareaInput.prototype.focus = function() {
                if ("nocursor" != this.cm.options.readOnly && (!mobile || activeElt() != this.textarea)) try {
                    this.textarea.focus();
                } catch (e) {}
            }, TextareaInput.prototype.blur = function() {
                this.textarea.blur();
            }, TextareaInput.prototype.resetPosition = function() {
                this.wrapper.style.top = this.wrapper.style.left = 0;
            }, TextareaInput.prototype.receivedFocus = function() {
                this.slowPoll();
            }, // Poll for input changes, using the normal rate of polling. This
            // runs as long as the editor is focused.
            TextareaInput.prototype.slowPoll = function() {
                var this$1 = this;
                this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
                    this$1.poll(), this$1.cm.state.focused && this$1.slowPoll();
                });
            }, // When an event has just come in that is likely to add or change
            // something in the input textarea, we poll faster, to ensure that
            // the change appears on the screen quickly.
            TextareaInput.prototype.fastPoll = function() {
                function p() {
                    var changed = input.poll();
                    changed || missed ? (input.pollingFast = !1, input.slowPoll()) : (missed = !0, input.polling.set(60, p));
                }
                var missed = !1, input = this;
                input.pollingFast = !0, input.polling.set(20, p);
            }, // Read input from the textarea, and update the document to match.
            // When something is selected, it is present in the textarea, and
            // selected (unless it is huge, in which case a placeholder is
            // used). When nothing is selected, the cursor sits after previously
            // seen text (can be empty), which is stored in prevInput (we must
            // not reset the textarea when typing, because that breaks IME).
            TextareaInput.prototype.poll = function() {
                var this$1 = this, cm = this.cm, input = this.textarea, prevInput = this.prevInput;
                // Since this is called a *lot*, try to bail out as cheaply as
                // possible when it is clear that nothing happened. hasSelection
                // will be the case when there is a lot of text in the textarea,
                // in which case reading its value would be expensive.
                if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) return !1;
                var text = input.value;
                // If nothing changed, bail.
                if (text == prevInput && !cm.somethingSelected()) return !1;
                // Work around nonsensical selection resetting in IE9/10, and
                // inexplicable appearance of private area unicode characters on
                // some key combos in Mac (#2689).
                if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) return cm.display.input.reset(), 
                !1;
                if (cm.doc.sel == cm.display.selForContextMenu) {
                    var first = text.charCodeAt(0);
                    if (8203 != first || prevInput || (prevInput = "​"), 8666 == first) return this.reset(), 
                    this.cm.execCommand("undo");
                }
                for (// Find the part of the input that is actually new
                var same = 0, l = Math.min(prevInput.length, text.length); same < l && prevInput.charCodeAt(same) == text.charCodeAt(same); ) ++same;
                return runInOp(cm, function() {
                    applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null), 
                    // Don't leave long text in the textarea, since it makes further polling slow
                    text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = this$1.prevInput = "" : this$1.prevInput = text, 
                    this$1.composing && (this$1.composing.range.clear(), this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
                        className: "CodeMirror-composing"
                    }));
                }), !0;
            }, TextareaInput.prototype.ensurePolled = function() {
                this.pollingFast && this.poll() && (this.pollingFast = !1);
            }, TextareaInput.prototype.onKeyPress = function() {
                ie && ie_version >= 9 && (this.hasSelection = null), this.fastPoll();
            }, TextareaInput.prototype.onContextMenu = function(e) {
                // Select-all will be greyed out if there's nothing to select, so
                // this adds a zero-width space so that we can later check whether
                // it got selected.
                function prepareSelectAllHack() {
                    if (null != te.selectionStart) {
                        var selected = cm.somethingSelected(), extval = "​" + (selected ? te.value : "");
                        te.value = "⇚", // Used to catch context-menu undo
                        te.value = extval, input.prevInput = selected ? "" : "​", te.selectionStart = 1, 
                        te.selectionEnd = extval.length, // Re-set this, in case some other handler touched the
                        // selection in the meantime.
                        display.selForContextMenu = cm.doc.sel;
                    }
                }
                function rehide() {
                    if (input.contextMenuPending == rehide && (input.contextMenuPending = !1, input.wrapper.style.cssText = oldWrapperCSS, 
                    te.style.cssText = oldCSS, ie && ie_version < 9 && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos), 
                    null != te.selectionStart)) {
                        (!ie || ie && ie_version < 9) && prepareSelectAllHack();
                        var i = 0, poll = function() {
                            display.selForContextMenu == cm.doc.sel && 0 == te.selectionStart && te.selectionEnd > 0 && "​" == input.prevInput ? operation(cm, selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : (display.selForContextMenu = null, 
                            display.input.reset());
                        };
                        display.detectingSelectAll = setTimeout(poll, 200);
                    }
                }
                var input = this, cm = input.cm, display = cm.display, te = input.textarea;
                input.contextMenuPending && input.contextMenuPending();
                var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
                if (pos && !presto) {
                    // Opera is difficult.
                    // Reset the current text selection only if the click is done outside of the selection
                    // and 'resetSelectionOnContextMenu' option is true.
                    var reset = cm.options.resetSelectionOnContextMenu;
                    reset && cm.doc.sel.contains(pos) == -1 && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
                    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText, wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
                    input.wrapper.style.cssText = "position: static", te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
                    var oldScrollY;
                    if (webkit && (oldScrollY = window.scrollY), // Work around Chrome issue (#2712)
                    display.input.focus(), webkit && window.scrollTo(null, oldScrollY), display.input.reset(), 
                    // Adds "Select all" to context menu in FF
                    cm.somethingSelected() || (te.value = input.prevInput = " "), input.contextMenuPending = rehide, 
                    display.selForContextMenu = cm.doc.sel, clearTimeout(display.detectingSelectAll), 
                    ie && ie_version >= 9 && prepareSelectAllHack(), captureRightClick) {
                        e_stop(e);
                        var mouseup = function() {
                            off(window, "mouseup", mouseup), setTimeout(rehide, 20);
                        };
                        on(window, "mouseup", mouseup);
                    } else setTimeout(rehide, 50);
                }
            }, TextareaInput.prototype.readOnlyChanged = function(val) {
                val || this.reset(), this.textarea.disabled = "nocursor" == val, this.textarea.readOnly = !!val;
            }, TextareaInput.prototype.setUneditable = function() {}, TextareaInput.prototype.needsContentAttribute = !1, 
            // EDITOR CONSTRUCTOR
            defineOptions(CodeMirror), addEditorMethods(CodeMirror);
            // Set up methods on CodeMirror's prototype to redirect to the editor's document.
            var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
            for (var prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror.prototype[prop] = function(method) {
                return function() {
                    return method.apply(this.doc, arguments);
                };
            }(Doc.prototype[prop]));
            // Extra arguments are stored as the mode's dependencies, which is
            // used by (legacy) mechanisms like loadmode.js to automatically
            // load a mode. (Preferred mechanism is the require/define calls.)
            // Minimal default mode.
            // EXTENSIONS
            return eventMixin(Doc), CodeMirror.inputStyles = {
                textarea: TextareaInput,
                contenteditable: ContentEditableInput
            }, CodeMirror.defineMode = function(name) {
                CodeMirror.defaults.mode || "null" == name || (CodeMirror.defaults.mode = name), 
                defineMode.apply(this, arguments);
            }, CodeMirror.defineMIME = defineMIME, CodeMirror.defineMode("null", function() {
                return {
                    token: function(stream) {
                        return stream.skipToEnd();
                    }
                };
            }), CodeMirror.defineMIME("text/plain", "null"), CodeMirror.defineExtension = function(name, func) {
                CodeMirror.prototype[name] = func;
            }, CodeMirror.defineDocExtension = function(name, func) {
                Doc.prototype[name] = func;
            }, CodeMirror.fromTextArea = fromTextArea, addLegacyProps(CodeMirror), CodeMirror.version = "5.58.1", 
            CodeMirror;
        });
    }, /* 132 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopDefault(ex) {
                return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
            }
            // 
            function isFunction(test) {
                return "function" == typeof test;
            }
            // 
            function getComponentName(target) {
                return "production" !== process.env.NODE_ENV && ("string" == typeof target && target) || target.displayName || target.name || "Component";
            }
            // 
            function isStatelessFunction(test) {
                return "function" == typeof test && !(test.prototype && test.prototype.isReactComponent);
            }
            // 
            function isStyledComponent(target) {
                return target && "string" == typeof target.styledComponentId;
            }
            /**
	 * super basic version of sprintf
	 */
            function format() {
                for (var a = arguments.length <= 0 ? void 0 : arguments[0], b = [], c = 1, len = arguments.length; c < len; c += 1) b.push(arguments.length <= c ? void 0 : arguments[c]);
                return b.forEach(function(d) {
                    a = a.replace(/%[a-z]/, d);
                }), a;
            }
            function stringifyRules(rules, selector, prefix) {
                var componentId = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "&", flatCSS = rules.join("").replace(COMMENT_REGEX, ""), cssStr = selector && prefix ? prefix + " " + selector + " { " + flatCSS + " }" : flatCSS;
                // stylis has no concept of state to be passed to plugins
                // but since JS is single=threaded, we can rely on that to ensure
                // these properties stay in sync with the current stylis run
                return _componentId = componentId, _selector = selector, _selectorRegexp = new RegExp("\\" + _selector + "\\b", "g"), 
                stylis(prefix || !selector ? "" : selector, cssStr);
            }
            /**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
            function hyphenateStyleName(string) {
                return string.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
            }
            // 
            // Taken from https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/dangerousStyleValue.js
            function addUnitIfNeeded(name, value) {
                // https://github.com/amilajack/eslint-plugin-flowtype-errors/issues/133
                // $FlowFixMe
                // https://github.com/amilajack/eslint-plugin-flowtype-errors/issues/133
                // $FlowFixMe
                return null == value || "boolean" == typeof value || "" === value ? "" : "number" != typeof value || 0 === value || name in unitless ? String(value).trim() : value + "px";
            }
            function flatten(chunk, executionContext, styleSheet) {
                if (Array.isArray(chunk)) {
                    for (var result, ruleSet = [], i = 0, len = chunk.length; i < len; i += 1) result = flatten(chunk[i], executionContext, styleSheet), 
                    null !== result && (Array.isArray(result) ? ruleSet.push.apply(ruleSet, result) : ruleSet.push(result));
                    return ruleSet;
                }
                if (isFalsish(chunk)) return null;
                /* Handle other components */
                if (isStyledComponent(chunk)) return "." + chunk.styledComponentId;
                /* Either execute or defer the function */
                if (isFunction(chunk)) {
                    if (isStatelessFunction(chunk) && executionContext) {
                        var _result = chunk(executionContext);
                        // eslint-disable-next-line no-console
                        return "production" !== process.env.NODE_ENV && reactIs.isElement(_result) && console.warn(getComponentName(chunk) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), 
                        flatten(_result, executionContext, styleSheet);
                    }
                    return chunk;
                }
                return chunk instanceof Keyframes ? styleSheet ? (chunk.inject(styleSheet), chunk.getName()) : chunk : isPlainObject(chunk) ? objToCssArray(chunk) : chunk.toString();
            }
            // 
            function css(styles) {
                for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                return flatten(isFunction(styles) || isPlainObject(styles) ? interleave(EMPTY_ARRAY, [ styles ].concat(interpolations)) : interleave(styles, interpolations));
            }
            // 
            function constructWithOptions(componentConstructor, tag) {
                var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EMPTY_OBJECT;
                if (!reactIs.isValidElementType(tag)) throw new StyledComponentsError(1, String(tag));
                /* This is callable directly as a template function */
                // $FlowFixMe: Not typed to avoid destructuring arguments
                var templateFunction = function() {
                    return componentConstructor(tag, options, css.apply(void 0, arguments));
                };
                /* If config methods are called, wrap up a new template function and merge options */
                /* Modify/inject new props at runtime */
                return templateFunction.withConfig = function(config) {
                    return constructWithOptions(componentConstructor, tag, _extends({}, options, config));
                }, templateFunction.attrs = function(attrs) {
                    return constructWithOptions(componentConstructor, tag, _extends({}, options, {
                        attrs: Array.prototype.concat(options.attrs, attrs).filter(Boolean)
                    }));
                }, templateFunction;
            }
            // 
            // Source: https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
            function murmurhash(c) {
                for (var b, e = 0 | c.length, a = 0 | e, d = 0; e >= 4; ) b = 255 & c.charCodeAt(d) | (255 & c.charCodeAt(++d)) << 8 | (255 & c.charCodeAt(++d)) << 16 | (255 & c.charCodeAt(++d)) << 24, 
                b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16), b ^= b >>> 24, 
                b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16), a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ b, 
                e -= 4, ++d;
                switch (e) {
                  case 3:
                    a ^= (255 & c.charCodeAt(d + 2)) << 16;

                  case 2:
                    a ^= (255 & c.charCodeAt(d + 1)) << 8;

                  case 1:
                    a ^= 255 & c.charCodeAt(d), a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16);
                }
                return a ^= a >>> 13, a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16), 
                (a ^ a >>> 15) >>> 0;
            }
            /* input a number, usually a hash and convert it to base-52 */
            function generateAlphabeticName(code) {
                var name = "", x = void 0;
                /* get a char and divide by alphabet-length */
                for (x = code; x > charsLength; x = Math.floor(x / charsLength)) name = getAlphabeticChar(x % charsLength) + name;
                return getAlphabeticChar(x % charsLength) + name;
            }
            // 
            function hasFunctionObjectKey(obj) {
                // eslint-disable-next-line guard-for-in, no-restricted-syntax
                for (var key in obj) if (isFunction(obj[key])) return !0;
                return !1;
            }
            function isStaticRules(rules, attrs) {
                for (var i = 0; i < rules.length; i += 1) {
                    var rule = rules[i];
                    // recursive case
                    if (Array.isArray(rule) && !isStaticRules(rule, attrs)) return !1;
                    if (isFunction(rule) && !isStyledComponent(rule)) // functions are allowed to be static if they're just being
                    // used to get the classname of a nested styled component
                    return !1;
                }
                return !attrs.some(function(x) {
                    return isFunction(x) || hasFunctionObjectKey(x);
                });
            }
            /**
	 * TODO: Explore using CSS.escape when it becomes more available
	 * in evergreen browsers.
	 */
            function escape(str) {
                return str.replace(escapeRegex, "-").replace(dashesAtEnds, "");
            }
            // 
            function isTag(target) {
                return "string" == typeof target && ("production" === process.env.NODE_ENV || target.charAt(0) === target.charAt(0).toLowerCase());
            }
            // 
            function generateDisplayName(target) {
                // $FlowFixMe
                return isTag(target) ? "styled." + target : "Styled(" + getComponentName(target) + ")";
            }
            function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
                if ("string" != typeof sourceComponent) {
                    // don't hoist over string (html) components
                    var inheritedComponent = getPrototypeOf(sourceComponent);
                    inheritedComponent && inheritedComponent !== objectPrototype && hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                    // eslint-disable-next-line no-plusplus
                    for (var keys = arrayPrototype.concat(getOwnPropertyNames(sourceComponent), // $FlowFixMe
                    getOwnPropertySymbols(sourceComponent)), targetStatics = TYPE_STATICS[targetComponent.$$typeof] || REACT_STATICS, sourceStatics = TYPE_STATICS[sourceComponent.$$typeof] || REACT_STATICS, i = keys.length, descriptor = void 0, key = void 0; i--; ) if (key = keys[i], 
                    // $FlowFixMe
                    !(KNOWN_STATICS[key] || blacklist && blacklist[key] || sourceStatics && sourceStatics[key] || targetStatics && targetStatics[key]) && (descriptor = getOwnPropertyDescriptor(sourceComponent, key))) try {
                        // Avoid failures from read-only properties
                        defineProperty$1(targetComponent, key, descriptor);
                    } catch (e) {}
                    return targetComponent;
                }
                return targetComponent;
            }
            // 
            function isDerivedReactComponent(fn) {
                return !!(fn && fn.prototype && fn.prototype.isReactComponent);
            }
            /* We depend on components having unique IDs */
            function generateId(_ComponentStyle, _displayName, parentComponentId) {
                var displayName = "string" != typeof _displayName ? "sc" : escape(_displayName), nr = (identifiers[displayName] || 0) + 1;
                identifiers[displayName] = nr;
                var componentId = displayName + "-" + _ComponentStyle.generateName(displayName + nr);
                return parentComponentId ? parentComponentId + "-" + componentId : componentId;
            }
            function createStyledComponent(target, options, rules) {
                var isTargetStyledComp = isStyledComponent(target), isClass = !isTag(target), _options$displayName = options.displayName, displayName = void 0 === _options$displayName ? generateDisplayName(target) : _options$displayName, _options$componentId = options.componentId, componentId = void 0 === _options$componentId ? generateId(ComponentStyle, options.displayName, options.parentComponentId) : _options$componentId, _options$ParentCompon = options.ParentComponent, ParentComponent = void 0 === _options$ParentCompon ? StyledComponent : _options$ParentCompon, _options$attrs = options.attrs, attrs = void 0 === _options$attrs ? EMPTY_ARRAY : _options$attrs, styledComponentId = options.displayName && options.componentId ? escape(options.displayName) + "-" + options.componentId : options.componentId || componentId, finalAttrs = // $FlowFixMe
                isTargetStyledComp && target.attrs ? Array.prototype.concat(target.attrs, attrs).filter(Boolean) : attrs, componentStyle = new ComponentStyle(isTargetStyledComp ? // fold the underlying StyledComponent rules up (implicit extend)
                // $FlowFixMe
                target.componentStyle.rules.concat(rules) : rules, finalAttrs, styledComponentId), WrappedStyledComponent = void 0, forwardRef = function(props, ref) {
                    return React__default.createElement(ParentComponent, _extends({}, props, {
                        forwardedComponent: WrappedStyledComponent,
                        forwardedRef: ref
                    }));
                };
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                // fold the underlying StyledComponent target up since we folded the styles
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                // $FlowFixMe
                return forwardRef.displayName = displayName, WrappedStyledComponent = React__default.forwardRef(forwardRef), 
                WrappedStyledComponent.displayName = displayName, WrappedStyledComponent.attrs = finalAttrs, 
                WrappedStyledComponent.componentStyle = componentStyle, WrappedStyledComponent.foldedComponentIds = isTargetStyledComp ? Array.prototype.concat(target.foldedComponentIds, target.styledComponentId) : EMPTY_ARRAY, 
                WrappedStyledComponent.styledComponentId = styledComponentId, WrappedStyledComponent.target = isTargetStyledComp ? target.target : target, 
                WrappedStyledComponent.withComponent = function(tag) {
                    var previousComponentId = options.componentId, optionsToCopy = objectWithoutProperties(options, [ "componentId" ]), newComponentId = previousComponentId && previousComponentId + "-" + (isTag(tag) ? tag : escape(getComponentName(tag))), newOptions = _extends({}, optionsToCopy, {
                        attrs: finalAttrs,
                        componentId: newComponentId,
                        ParentComponent: ParentComponent
                    });
                    return createStyledComponent(tag, newOptions, rules);
                }, Object.defineProperty(WrappedStyledComponent, "defaultProps", {
                    get: function() {
                        return this._foldedDefaultProps;
                    },
                    set: function(obj) {
                        // $FlowFixMe
                        this._foldedDefaultProps = isTargetStyledComp ? merge(target.defaultProps, obj) : obj;
                    }
                }), "production" !== process.env.NODE_ENV && (WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName)), 
                WrappedStyledComponent.toString = function() {
                    return "." + WrappedStyledComponent.styledComponentId;
                }, isClass && hoistNonReactStatics(WrappedStyledComponent, target, {
                    // all SC-specific things should not be hoisted
                    attrs: !0,
                    componentStyle: !0,
                    displayName: !0,
                    foldedComponentIds: !0,
                    styledComponentId: !0,
                    target: !0,
                    withComponent: !0
                }), WrappedStyledComponent;
            }
            function createGlobalStyle(strings) {
                for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                var rules = css.apply(void 0, [ strings ].concat(interpolations)), id = "sc-global-" + murmurhash(JSON.stringify(rules)), style = new GlobalStyle(rules, id), GlobalStyleComponent = function(_React$Component) {
                    function GlobalStyleComponent(props) {
                        classCallCheck(this, GlobalStyleComponent);
                        var _this = possibleConstructorReturn(this, _React$Component.call(this, props)), _this$constructor = _this.constructor, globalStyle = _this$constructor.globalStyle, styledComponentId = _this$constructor.styledComponentId;
                        /**
	       * This fixes HMR compatibility. Don't ask me why, but this combination of
	       * caching the closure variables via statics and then persisting the statics in
	       * state works across HMR where no other combination did. ¯\_(ツ)_/¯
	       */
                        return IS_BROWSER && (window.scCGSHMRCache[styledComponentId] = (window.scCGSHMRCache[styledComponentId] || 0) + 1), 
                        _this.state = {
                            globalStyle: globalStyle,
                            styledComponentId: styledComponentId
                        }, _this;
                    }
                    return inherits(GlobalStyleComponent, _React$Component), GlobalStyleComponent.prototype.componentWillUnmount = function() {
                        window.scCGSHMRCache[this.state.styledComponentId] && (window.scCGSHMRCache[this.state.styledComponentId] -= 1), 
                        /**
	       * Depending on the order "render" is called this can cause the styles to be lost
	       * until the next render pass of the remaining instance, which may
	       * not be immediate.
	       */
                        0 === window.scCGSHMRCache[this.state.styledComponentId] && this.state.globalStyle.removeStyles(this.styleSheet);
                    }, GlobalStyleComponent.prototype.render = function() {
                        var _this2 = this;
                        // eslint-disable-next-line no-console
                        return "production" !== process.env.NODE_ENV && React__default.Children.count(this.props.children) && console.warn("The global style component " + this.state.styledComponentId + " was given child JSX. createGlobalStyle does not render children."), 
                        React__default.createElement(StyleSheetConsumer, null, function(styleSheet) {
                            _this2.styleSheet = styleSheet || StyleSheet.master;
                            var globalStyle = _this2.state.globalStyle;
                            return globalStyle.isStatic ? (globalStyle.renderStyles(STATIC_EXECUTION_CONTEXT, _this2.styleSheet), 
                            null) : React__default.createElement(ThemeConsumer, null, function(theme) {
                                // $FlowFixMe
                                var defaultProps = _this2.constructor.defaultProps, context = _extends({}, _this2.props);
                                return "undefined" != typeof theme && (context.theme = determineTheme(_this2.props, theme, defaultProps)), 
                                globalStyle.renderStyles(context, _this2.styleSheet), null;
                            });
                        });
                    }, GlobalStyleComponent;
                }(React__default.Component);
                return GlobalStyleComponent.globalStyle = style, GlobalStyleComponent.styledComponentId = id, 
                GlobalStyleComponent;
            }
            function keyframes(strings) {
                /* Warning if you've used keyframes on React Native */
                "production" !== process.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && // eslint-disable-next-line no-console
                console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
                for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                var rules = css.apply(void 0, [ strings ].concat(interpolations)), name = generateAlphabeticName(murmurhash(replaceWhitespace(JSON.stringify(rules))));
                return new Keyframes(name, stringifyRules(rules, name, "@keyframes"));
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var Stylis = _interopDefault(__webpack_require__(133)), _insertRulePlugin = _interopDefault(__webpack_require__(134)), React = __webpack_require__(108), React__default = _interopDefault(React), unitless = _interopDefault(__webpack_require__(135)), reactIs = __webpack_require__(111), memoize = _interopDefault(__webpack_require__(136)), PropTypes = _interopDefault(__webpack_require__(109)), validAttr = _interopDefault(__webpack_require__(137)), merge = _interopDefault(__webpack_require__(139)), interleave = function(strings, interpolations) {
                for (var result = [ strings[0] ], i = 0, len = interpolations.length; i < len; i += 1) result.push(interpolations[i], strings[i + 1]);
                return result;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, classCallCheck = function(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }, createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, inherits = function(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }, objectWithoutProperties = function(obj, keys) {
                var target = {};
                for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
                return target;
            }, possibleConstructorReturn = function(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }, isPlainObject = function(x) {
                return "object" === ("undefined" == typeof x ? "undefined" : _typeof(x)) && x.constructor === Object;
            }, EMPTY_ARRAY = Object.freeze([]), EMPTY_OBJECT = Object.freeze({}), SC_ATTR = "undefined" != typeof process && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", SC_VERSION_ATTR = "data-styled-version", SC_STREAM_ATTR = "data-styled-streamed", IS_BROWSER = "undefined" != typeof window && "HTMLElement" in window, DISABLE_SPEEDY = "boolean" == typeof SC_DISABLE_SPEEDY && SC_DISABLE_SPEEDY || "undefined" != typeof process && (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY) || "production" !== process.env.NODE_ENV, STATIC_EXECUTION_CONTEXT = {}, ERRORS = "production" !== process.env.NODE_ENV ? {
                "1": "Cannot create styled-component for component: %s.\n\n",
                "2": "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n",
                "3": "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n",
                "4": "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n",
                "5": "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n",
                "6": "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n",
                "7": 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n',
                "8": 'ThemeProvider: Please make your "theme" prop an object.\n\n',
                "9": "Missing document `<head>`\n\n",
                "10": "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n",
                "11": "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n",
                "12": "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n",
                "13": "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n"
            } : {}, StyledComponentsError = function(_Error) {
                function StyledComponentsError(code) {
                    classCallCheck(this, StyledComponentsError);
                    for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                    if ("production" === process.env.NODE_ENV) var _this = possibleConstructorReturn(this, _Error.call(this, "An error occurred. See https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/errors.md#" + code + " for more information." + (interpolations.length > 0 ? " Additional arguments: " + interpolations.join(", ") : ""))); else var _this = possibleConstructorReturn(this, _Error.call(this, format.apply(void 0, [ ERRORS[code] ].concat(interpolations)).trim()));
                    return possibleConstructorReturn(_this);
                }
                return inherits(StyledComponentsError, _Error), StyledComponentsError;
            }(Error), SC_COMPONENT_ID = /^[^\S\n]*?\/\* sc-component-id:\s*(\S+)\s+\*\//gm, extractComps = function(maybeCSS) {
                var css = "" + (maybeCSS || ""), existingComponents = [];
                return css.replace(SC_COMPONENT_ID, function(match, componentId, matchIndex) {
                    return existingComponents.push({
                        componentId: componentId,
                        matchIndex: matchIndex
                    }), match;
                }), existingComponents.map(function(_ref, i) {
                    var componentId = _ref.componentId, matchIndex = _ref.matchIndex, nextComp = existingComponents[i + 1], cssFromDOM = nextComp ? css.slice(matchIndex, nextComp.matchIndex) : css.slice(matchIndex);
                    return {
                        componentId: componentId,
                        cssFromDOM: cssFromDOM
                    };
                });
            }, COMMENT_REGEX = /^\s*\/\/.*$/gm, stylisSplitter = new Stylis({
                global: !1,
                cascade: !0,
                keyframe: !1,
                prefix: !1,
                compress: !1,
                semicolon: !0
            }), stylis = new Stylis({
                global: !1,
                cascade: !0,
                keyframe: !1,
                prefix: !0,
                compress: !1,
                semicolon: !1
            }), parsingRules = [], returnRulesPlugin = function(context) {
                if (context === -2) {
                    var parsedRules = parsingRules;
                    return parsingRules = [], parsedRules;
                }
            }, parseRulesPlugin = _insertRulePlugin(function(rule) {
                parsingRules.push(rule);
            }), _componentId = void 0, _selector = void 0, _selectorRegexp = void 0, selfReferenceReplacer = function(match, offset, string) {
                // the first self-ref is always untouched
                // there should be at least two self-refs to do a replacement (.b > .b)
                // no consecutive self refs (.b.b); that is a precedence boost and treated differently
                return offset > 0 && string.slice(0, offset).indexOf(_selector) !== -1 && string.slice(offset - _selector.length, offset) !== _selector ? "." + _componentId : match;
            }, selfReferenceReplacementPlugin = function(context, _, selectors) {
                2 === context && selectors.length && selectors[0].lastIndexOf(_selector) > 0 && (// eslint-disable-next-line no-param-reassign
                selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer));
            };
            stylis.use([ selfReferenceReplacementPlugin, parseRulesPlugin, returnRulesPlugin ]), 
            stylisSplitter.use([ parseRulesPlugin, returnRulesPlugin ]);
            var splitByRules = function(css) {
                return stylisSplitter("", css);
            }, getNonce = function() {
                return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
            }, addNameForId = function(names, id, name) {
                if (name) {
                    // eslint-disable-next-line no-param-reassign
                    var namesForId = names[id] || (names[id] = Object.create(null));
                    namesForId[name] = !0;
                }
            }, resetIdNames = function(names, id) {
                // eslint-disable-next-line no-param-reassign
                names[id] = Object.create(null);
            }, hasNameForId = function(names) {
                return function(id, name) {
                    return void 0 !== names[id] && names[id][name];
                };
            }, stringifyNames = function(names) {
                var str = "";
                // eslint-disable-next-line guard-for-in
                for (var id in names) str += Object.keys(names[id]).join(" ") + " ";
                return str.trim();
            }, cloneNames = function(names) {
                var clone = Object.create(null);
                // eslint-disable-next-line guard-for-in
                for (var id in names) clone[id] = _extends({}, names[id]);
                return clone;
            }, sheetForTag = function(tag) {
                // $FlowFixMe
                if (tag.sheet) return tag.sheet;
                for (var size = tag.ownerDocument.styleSheets.length, i = 0; i < size; i += 1) {
                    var sheet = tag.ownerDocument.styleSheets[i];
                    // $FlowFixMe
                    if (sheet.ownerNode === tag) return sheet;
                }
                /* we should always be able to find a tag */
                throw new StyledComponentsError(10);
            }, safeInsertRule = function(sheet, cssRule, index) {
                /* abort early if cssRule string is falsy */
                if (!cssRule) return !1;
                var maxIndex = sheet.cssRules.length;
                try {
                    /* use insertRule and cap passed index with maxIndex (no of cssRules) */
                    sheet.insertRule(cssRule, index <= maxIndex ? index : maxIndex);
                } catch (err) {
                    /* any error indicates an invalid rule */
                    return !1;
                }
                return !0;
            }, deleteRules = function(sheet, removalIndex, size) {
                for (var lowerBound = removalIndex - size, i = removalIndex; i > lowerBound; i -= 1) sheet.deleteRule(i);
            }, makeTextMarker = function(id) {
                return "\n/* sc-component-id: " + id + " */\n";
            }, addUpUntilIndex = function(sizes, index) {
                for (var totalUpToIndex = 0, i = 0; i <= index; i += 1) totalUpToIndex += sizes[i];
                return totalUpToIndex;
            }, makeStyleTag = function(target, tagEl, insertBefore) {
                var targetDocument = document;
                target ? targetDocument = target.ownerDocument : tagEl && (targetDocument = tagEl.ownerDocument);
                var el = targetDocument.createElement("style");
                el.setAttribute(SC_ATTR, ""), el.setAttribute(SC_VERSION_ATTR, "4.4.1");
                var nonce = getNonce();
                if (nonce && el.setAttribute("nonce", nonce), /* Work around insertRule quirk in EdgeHTML */
                el.appendChild(targetDocument.createTextNode("")), target && !tagEl) /* Append to target when no previous element was passed */
                target.appendChild(el); else {
                    if (!tagEl || !target || !tagEl.parentNode) throw new StyledComponentsError(6);
                    /* Insert new style tag after the previous one */
                    tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling);
                }
                return el;
            }, wrapAsHtmlTag = function(css, names) {
                return function(additionalAttrs) {
                    var nonce = getNonce(), attrs = [ nonce && 'nonce="' + nonce + '"', SC_ATTR + '="' + stringifyNames(names) + '"', SC_VERSION_ATTR + '="4.4.1"', additionalAttrs ], htmlAttr = attrs.filter(Boolean).join(" ");
                    return "<style " + htmlAttr + ">" + css() + "</style>";
                };
            }, wrapAsElement = function(css, names) {
                return function() {
                    var _props, props = (_props = {}, _props[SC_ATTR] = stringifyNames(names), _props[SC_VERSION_ATTR] = "4.4.1", 
                    _props), nonce = getNonce();
                    // eslint-disable-next-line react/no-danger
                    // $FlowFixMe
                    return nonce && (props.nonce = nonce), React__default.createElement("style", _extends({}, props, {
                        dangerouslySetInnerHTML: {
                            __html: css()
                        }
                    }));
                };
            }, getIdsFromMarkersFactory = function(markers) {
                return function() {
                    return Object.keys(markers);
                };
            }, makeSpeedyTag = function(el, getImportRuleTag) {
                var names = Object.create(null), markers = Object.create(null), sizes = [], extractImport = void 0 !== getImportRuleTag, usedImportRuleTag = !1, insertMarker = function(id) {
                    var prev = markers[id];
                    return void 0 !== prev ? prev : (markers[id] = sizes.length, sizes.push(0), resetIdNames(names, id), 
                    markers[id]);
                }, insertRules = function(id, cssRules, name) {
                    for (var marker = insertMarker(id), sheet = sheetForTag(el), insertIndex = addUpUntilIndex(sizes, marker), injectedRules = 0, importRules = [], cssRulesSize = cssRules.length, i = 0; i < cssRulesSize; i += 1) {
                        var cssRule = cssRules[i], mayHaveImport = extractImport;
                        /* @import rules are reordered to appear first */
                        mayHaveImport && cssRule.indexOf("@import") !== -1 ? importRules.push(cssRule) : safeInsertRule(sheet, cssRule, insertIndex + injectedRules) && (mayHaveImport = !1, 
                        injectedRules += 1);
                    }
                    extractImport && importRules.length > 0 && (usedImportRuleTag = !0, // $FlowFixMe
                    getImportRuleTag().insertRules(id + "-import", importRules)), sizes[marker] += injectedRules, 
                    /* add up no of injected rules */
                    addNameForId(names, id, name);
                }, removeRules = function(id) {
                    var marker = markers[id];
                    if (void 0 !== marker && el.isConnected !== !1) // $FlowFixMe
                    {
                        var size = sizes[marker], sheet = sheetForTag(el), removalIndex = addUpUntilIndex(sizes, marker) - 1;
                        deleteRules(sheet, removalIndex, size), sizes[marker] = 0, resetIdNames(names, id), 
                        extractImport && usedImportRuleTag && // $FlowFixMe
                        getImportRuleTag().removeRules(id + "-import");
                    }
                }, css = function() {
                    var _sheetForTag = sheetForTag(el), cssRules = _sheetForTag.cssRules, str = "";
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) {
                        str += makeTextMarker(id);
                        for (var marker = markers[id], end = addUpUntilIndex(sizes, marker), size = sizes[marker], i = end - size; i < end; i += 1) {
                            var rule = cssRules[i];
                            void 0 !== rule && (str += rule.cssText);
                        }
                    }
                    return str;
                };
                return {
                    clone: function() {
                        throw new StyledComponentsError(5);
                    },
                    css: css,
                    getIds: getIdsFromMarkersFactory(markers),
                    hasNameForId: hasNameForId(names),
                    insertMarker: insertMarker,
                    insertRules: insertRules,
                    removeRules: removeRules,
                    sealed: !1,
                    styleTag: el,
                    toElement: wrapAsElement(css, names),
                    toHTML: wrapAsHtmlTag(css, names)
                };
            }, makeTextNode = function(targetDocument, id) {
                return targetDocument.createTextNode(makeTextMarker(id));
            }, makeBrowserTag = function(el, getImportRuleTag) {
                var names = Object.create(null), markers = Object.create(null), extractImport = void 0 !== getImportRuleTag, usedImportRuleTag = !1, insertMarker = function(id) {
                    var prev = markers[id];
                    return void 0 !== prev ? prev : (markers[id] = makeTextNode(el.ownerDocument, id), 
                    el.appendChild(markers[id]), names[id] = Object.create(null), markers[id]);
                }, insertRules = function(id, cssRules, name) {
                    for (var marker = insertMarker(id), importRules = [], cssRulesSize = cssRules.length, i = 0; i < cssRulesSize; i += 1) {
                        var rule = cssRules[i], mayHaveImport = extractImport;
                        if (mayHaveImport && rule.indexOf("@import") !== -1) importRules.push(rule); else {
                            mayHaveImport = !1;
                            var separator = i === cssRulesSize - 1 ? "" : " ";
                            marker.appendData("" + rule + separator);
                        }
                    }
                    addNameForId(names, id, name), extractImport && importRules.length > 0 && (usedImportRuleTag = !0, 
                    // $FlowFixMe
                    getImportRuleTag().insertRules(id + "-import", importRules));
                }, removeRules = function(id) {
                    var marker = markers[id];
                    if (void 0 !== marker) {
                        /* create new empty text node and replace the current one */
                        var newMarker = makeTextNode(el.ownerDocument, id);
                        el.replaceChild(newMarker, marker), markers[id] = newMarker, resetIdNames(names, id), 
                        extractImport && usedImportRuleTag && // $FlowFixMe
                        getImportRuleTag().removeRules(id + "-import");
                    }
                }, css = function() {
                    var str = "";
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) str += markers[id].data;
                    return str;
                };
                return {
                    clone: function() {
                        throw new StyledComponentsError(5);
                    },
                    css: css,
                    getIds: getIdsFromMarkersFactory(markers),
                    hasNameForId: hasNameForId(names),
                    insertMarker: insertMarker,
                    insertRules: insertRules,
                    removeRules: removeRules,
                    sealed: !1,
                    styleTag: el,
                    toElement: wrapAsElement(css, names),
                    toHTML: wrapAsHtmlTag(css, names)
                };
            }, makeServerTag = function makeServerTag(namesArg, markersArg) {
                var names = void 0 === namesArg ? Object.create(null) : namesArg, markers = void 0 === markersArg ? Object.create(null) : markersArg, insertMarker = function(id) {
                    var prev = markers[id];
                    return void 0 !== prev ? prev : markers[id] = [ "" ];
                }, insertRules = function(id, cssRules, name) {
                    var marker = insertMarker(id);
                    marker[0] += cssRules.join(" "), addNameForId(names, id, name);
                }, removeRules = function(id) {
                    var marker = markers[id];
                    void 0 !== marker && (marker[0] = "", resetIdNames(names, id));
                }, css = function() {
                    var str = "";
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) {
                        var cssForId = markers[id][0];
                        cssForId && (str += makeTextMarker(id) + cssForId);
                    }
                    return str;
                }, clone = function() {
                    var namesClone = cloneNames(names), markersClone = Object.create(null);
                    // eslint-disable-next-line guard-for-in
                    for (var id in markers) markersClone[id] = [ markers[id][0] ];
                    return makeServerTag(namesClone, markersClone);
                }, tag = {
                    clone: clone,
                    css: css,
                    getIds: getIdsFromMarkersFactory(markers),
                    hasNameForId: hasNameForId(names),
                    insertMarker: insertMarker,
                    insertRules: insertRules,
                    removeRules: removeRules,
                    sealed: !1,
                    styleTag: null,
                    toElement: wrapAsElement(css, names),
                    toHTML: wrapAsHtmlTag(css, names)
                };
                return tag;
            }, makeTag = function(target, tagEl, forceServer, insertBefore, getImportRuleTag) {
                if (IS_BROWSER && !forceServer) {
                    var el = makeStyleTag(target, tagEl, insertBefore);
                    return DISABLE_SPEEDY ? makeBrowserTag(el, getImportRuleTag) : makeSpeedyTag(el, getImportRuleTag);
                }
                return makeServerTag();
            }, rehydrate = function(tag, els, extracted) {
                /* add all extracted components to the new tag */
                for (var i = 0, len = extracted.length; i < len; i += 1) {
                    var _extracted$i = extracted[i], componentId = _extracted$i.componentId, cssFromDOM = _extracted$i.cssFromDOM, cssRules = splitByRules(cssFromDOM);
                    tag.insertRules(componentId, cssRules);
                }
                /* remove old HTMLStyleElements, since they have been rehydrated */
                for (var _i = 0, _len = els.length; _i < _len; _i += 1) {
                    var el = els[_i];
                    el.parentNode && el.parentNode.removeChild(el);
                }
            }, SPLIT_REGEX = /\s+/, MAX_SIZE = void 0;
            /* in speedy mode we can keep a lot more rules in a sheet before a slowdown can be expected */
            MAX_SIZE = IS_BROWSER ? DISABLE_SPEEDY ? 40 : 1e3 : -1;
            var _TYPE_STATICS, sheetRunningId = 0, master = void 0, StyleSheet = function() {
                /* a map from ids to tags */
                /* deferred rules for a given id */
                /* this is used for not reinjecting rules via hasNameForId() */
                /* when rules for an id are removed using remove() we have to ignore rehydratedNames for it */
                /* a list of tags belonging to this StyleSheet */
                /* a tag for import rules */
                /* current capacity until a new tag must be created */
                /* children (aka clones) of this StyleSheet inheriting all and future injections */
                function StyleSheet() {
                    var _this = this, target = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : IS_BROWSER ? document.head : null, forceServer = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    classCallCheck(this, StyleSheet), this.getImportRuleTag = function() {
                        var importRuleTag = _this.importRuleTag;
                        if (void 0 !== importRuleTag) return importRuleTag;
                        var firstTag = _this.tags[0], insertBefore = !0;
                        return _this.importRuleTag = makeTag(_this.target, firstTag ? firstTag.styleTag : null, _this.forceServer, insertBefore);
                    }, sheetRunningId += 1, this.id = sheetRunningId, this.forceServer = forceServer, 
                    this.target = forceServer ? null : target, this.tagMap = {}, this.deferred = {}, 
                    this.rehydratedNames = {}, this.ignoreRehydratedNames = {}, this.tags = [], this.capacity = 1, 
                    this.clones = [];
                }
                /* rehydrate all SSR'd style tags */
                /* retrieve a "master" instance of StyleSheet which is typically used when no other is available
	   * The master StyleSheet is targeted by createGlobalStyle, keyframes, and components outside of any
	    * StyleSheetManager's context */
                /* reset the internal "master" instance */
                /* adds "children" to the StyleSheet that inherit all of the parents' rules
	   * while their own rules do not affect the parent */
                /* force StyleSheet to create a new tag on the next injection */
                /* get a tag for a given componentId, assign the componentId to one, or shard */
                /* mainly for createGlobalStyle to check for its id */
                /* caching layer checking id+name to already have a corresponding tag and injected rules */
                /* registers a componentId and registers it on its tag */
                /* injects rules for a given id with a name that will need to be cached */
                /* removes all rules for a given id, which doesn't remove its marker but resets it */
                return StyleSheet.prototype.rehydrate = function() {
                    if (!IS_BROWSER || this.forceServer) return this;
                    var els = [], extracted = [], isStreamed = !1, nodes = document.querySelectorAll("style[" + SC_ATTR + "][" + SC_VERSION_ATTR + '="4.4.1"]'), nodesSize = nodes.length;
                    /* abort rehydration if no previous style tags were found */
                    if (!nodesSize) return this;
                    for (var i = 0; i < nodesSize; i += 1) {
                        var el = nodes[i];
                        /* check if style tag is a streamed tag */
                        isStreamed || (isStreamed = !!el.getAttribute(SC_STREAM_ATTR));
                        for (var name, elNames = (el.getAttribute(SC_ATTR) || "").trim().split(SPLIT_REGEX), elNamesSize = elNames.length, j = 0; j < elNamesSize; j += 1) name = elNames[j], 
                        /* add rehydrated name to sheet to avoid re-adding styles */
                        this.rehydratedNames[name] = !0;
                        /* extract all components and their CSS */
                        extracted.push.apply(extracted, extractComps(el.textContent)), /* store original HTMLStyleElement */
                        els.push(el);
                    }
                    /* abort rehydration if nothing was extracted */
                    var extractedSize = extracted.length;
                    if (!extractedSize) return this;
                    /* create a tag to be used for rehydration */
                    var tag = this.makeTag(null);
                    rehydrate(tag, els, extracted), /* reset capacity and adjust MAX_SIZE by the initial size of the rehydration */
                    this.capacity = Math.max(1, MAX_SIZE - extractedSize), this.tags.push(tag);
                    /* retrieve all component ids */
                    for (var _j = 0; _j < extractedSize; _j += 1) this.tagMap[extracted[_j].componentId] = tag;
                    return this;
                }, StyleSheet.reset = function() {
                    var forceServer = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    master = new StyleSheet(void 0, forceServer).rehydrate();
                }, StyleSheet.prototype.clone = function() {
                    var sheet = new StyleSheet(this.target, this.forceServer);
                    /* add to clone array */
                    /* clone all tags */
                    /* clone other maps */
                    return this.clones.push(sheet), sheet.tags = this.tags.map(function(tag) {
                        /* reconstruct tagMap */
                        for (var ids = tag.getIds(), newTag = tag.clone(), i = 0; i < ids.length; i += 1) sheet.tagMap[ids[i]] = newTag;
                        return newTag;
                    }), sheet.rehydratedNames = _extends({}, this.rehydratedNames), sheet.deferred = _extends({}, this.deferred), 
                    sheet;
                }, StyleSheet.prototype.sealAllTags = function() {
                    this.capacity = 1, this.tags.forEach(function(tag) {
                        // eslint-disable-next-line no-param-reassign
                        tag.sealed = !0;
                    });
                }, StyleSheet.prototype.makeTag = function(tag) {
                    var lastEl = tag ? tag.styleTag : null, insertBefore = !1;
                    return makeTag(this.target, lastEl, this.forceServer, insertBefore, this.getImportRuleTag);
                }, StyleSheet.prototype.getTagForId = function(id) {
                    /* simply return a tag, when the componentId was already assigned one */
                    var prev = this.tagMap[id];
                    if (void 0 !== prev && !prev.sealed) return prev;
                    var tag = this.tags[this.tags.length - 1];
                    /* shard (create a new tag) if the tag is exhausted (See MAX_SIZE) */
                    return this.capacity -= 1, 0 === this.capacity && (this.capacity = MAX_SIZE, tag = this.makeTag(tag), 
                    this.tags.push(tag)), this.tagMap[id] = tag;
                }, StyleSheet.prototype.hasId = function(id) {
                    return void 0 !== this.tagMap[id];
                }, StyleSheet.prototype.hasNameForId = function(id, name) {
                    /* exception for rehydrated names which are checked separately */
                    if (void 0 === this.ignoreRehydratedNames[id] && this.rehydratedNames[name]) return !0;
                    var tag = this.tagMap[id];
                    return void 0 !== tag && tag.hasNameForId(id, name);
                }, StyleSheet.prototype.deferredInject = function(id, cssRules) {
                    /* don't inject when the id is already registered */
                    if (void 0 === this.tagMap[id]) {
                        for (var clones = this.clones, i = 0; i < clones.length; i += 1) clones[i].deferredInject(id, cssRules);
                        this.getTagForId(id).insertMarker(id), this.deferred[id] = cssRules;
                    }
                }, StyleSheet.prototype.inject = function(id, cssRules, name) {
                    for (var clones = this.clones, i = 0; i < clones.length; i += 1) clones[i].inject(id, cssRules, name);
                    var tag = this.getTagForId(id);
                    /* add deferred rules for component */
                    if (void 0 !== this.deferred[id]) {
                        // Combine passed cssRules with previously deferred CSS rules
                        // NOTE: We cannot mutate the deferred array itself as all clones
                        // do the same (see clones[i].inject)
                        var rules = this.deferred[id].concat(cssRules);
                        tag.insertRules(id, rules, name), this.deferred[id] = void 0;
                    } else tag.insertRules(id, cssRules, name);
                }, StyleSheet.prototype.remove = function(id) {
                    var tag = this.tagMap[id];
                    if (void 0 !== tag) {
                        for (var clones = this.clones, i = 0; i < clones.length; i += 1) clones[i].remove(id);
                        /* remove all rules from the tag */
                        tag.removeRules(id), /* ignore possible rehydrated names */
                        this.ignoreRehydratedNames[id] = !0, /* delete possible deferred rules */
                        this.deferred[id] = void 0;
                    }
                }, StyleSheet.prototype.toHTML = function() {
                    return this.tags.map(function(tag) {
                        return tag.toHTML();
                    }).join("");
                }, StyleSheet.prototype.toReactElements = function() {
                    var id = this.id;
                    return this.tags.map(function(tag, i) {
                        var key = "sc-" + id + "-" + i;
                        return React.cloneElement(tag.toElement(), {
                            key: key
                        });
                    });
                }, createClass(StyleSheet, null, [ {
                    key: "master",
                    get: function() {
                        return master || (master = new StyleSheet().rehydrate());
                    }
                }, {
                    key: "instance",
                    get: function() {
                        return StyleSheet.master;
                    }
                } ]), StyleSheet;
            }(), Keyframes = function() {
                function Keyframes(name, rules) {
                    var _this = this;
                    classCallCheck(this, Keyframes), this.inject = function(styleSheet) {
                        styleSheet.hasNameForId(_this.id, _this.name) || styleSheet.inject(_this.id, _this.rules, _this.name);
                    }, this.toString = function() {
                        throw new StyledComponentsError(12, String(_this.name));
                    }, this.name = name, this.rules = rules, this.id = "sc-keyframes-" + name;
                }
                return Keyframes.prototype.getName = function() {
                    return this.name;
                }, Keyframes;
            }(), uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isFalsish = function(chunk) {
                return void 0 === chunk || null === chunk || chunk === !1 || "" === chunk;
            }, objToCssArray = function objToCssArray(obj, prevKey) {
                var rules = [], keys = Object.keys(obj);
                return keys.forEach(function(key) {
                    if (!isFalsish(obj[key])) {
                        if (isPlainObject(obj[key])) return rules.push.apply(rules, objToCssArray(obj[key], key)), 
                        rules;
                        if (isFunction(obj[key])) return rules.push(hyphenateStyleName(key) + ":", obj[key], ";"), 
                        rules;
                        rules.push(hyphenateStyleName(key) + ": " + addUnitIfNeeded(key, obj[key]) + ";");
                    }
                    return rules;
                }), prevKey ? [ prevKey + " {" ].concat(rules, [ "}" ]) : rules;
            }, charsLength = 52, getAlphabeticChar = function(code) {
                return String.fromCharCode(code + (code > 25 ? 39 : 97));
            }, hasher = function(str) {
                return generateAlphabeticName(murmurhash(str));
            }, ComponentStyle = function() {
                function ComponentStyle(rules, attrs, componentId) {
                    classCallCheck(this, ComponentStyle), this.rules = rules, this.isStatic = "production" === process.env.NODE_ENV && isStaticRules(rules, attrs), 
                    this.componentId = componentId, StyleSheet.master.hasId(componentId) || StyleSheet.master.deferredInject(componentId, []);
                }
                /*
	   * Flattens a rule set into valid CSS
	   * Hashes it, wraps the whole chunk in a .hash1234 {}
	   * Returns the hash to be injected on render()
	   * */
                return ComponentStyle.prototype.generateAndInjectStyles = function(executionContext, styleSheet) {
                    var isStatic = this.isStatic, componentId = this.componentId, lastClassName = this.lastClassName;
                    if (IS_BROWSER && isStatic && "string" == typeof lastClassName && styleSheet.hasNameForId(componentId, lastClassName)) return lastClassName;
                    var flatCSS = flatten(this.rules, executionContext, styleSheet), name = hasher(this.componentId + flatCSS.join(""));
                    return styleSheet.hasNameForId(componentId, name) || styleSheet.inject(this.componentId, stringifyRules(flatCSS, "." + name, void 0, componentId), name), 
                    this.lastClassName = name, name;
                }, ComponentStyle.generateName = function(str) {
                    return hasher(str);
                }, ComponentStyle;
            }(), LIMIT = 200, createWarnTooManyClasses = function(displayName) {
                var generatedClasses = {}, warningSeen = !1;
                return function(className) {
                    warningSeen || (generatedClasses[className] = !0, Object.keys(generatedClasses).length >= LIMIT && (// Unable to find latestRule in test environment.
                    /* eslint-disable no-console, prefer-template */
                    console.warn("Over " + LIMIT + " classes were generated for component " + displayName + ". \nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), 
                    warningSeen = !0, generatedClasses = {}));
                };
            }, determineTheme = function(props, fallbackTheme) {
                var defaultProps = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EMPTY_OBJECT, isDefaultTheme = !!defaultProps && props.theme === defaultProps.theme, theme = props.theme && !isDefaultTheme ? props.theme : fallbackTheme || defaultProps.theme;
                /* eslint-enable */
                return theme;
            }, escapeRegex = /[[\].#*$><+~=|^:(),"'`-]+/g, dashesAtEnds = /(^-|-$)/g, REACT_STATICS = {
                childContextTypes: !0,
                contextTypes: !0,
                defaultProps: !0,
                displayName: !0,
                getDerivedStateFromProps: !0,
                propTypes: !0,
                type: !0
            }, KNOWN_STATICS = {
                name: !0,
                length: !0,
                prototype: !0,
                caller: !0,
                callee: !0,
                arguments: !0,
                arity: !0
            }, TYPE_STATICS = (_TYPE_STATICS = {}, _TYPE_STATICS[reactIs.ForwardRef] = {
                $$typeof: !0,
                render: !0
            }, _TYPE_STATICS), defineProperty$1 = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, _Object$getOwnPropert = Object.getOwnPropertySymbols, getOwnPropertySymbols = void 0 === _Object$getOwnPropert ? function() {
                return [];
            } : _Object$getOwnPropert, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = Object.prototype, arrayPrototype = Array.prototype, once = function(cb) {
                var called = !1;
                return function() {
                    called || (called = !0, cb.apply(void 0, arguments));
                };
            }, ThemeContext = React.createContext(), ThemeConsumer = ThemeContext.Consumer, ThemeProvider = function(_Component) {
                function ThemeProvider(props) {
                    classCallCheck(this, ThemeProvider);
                    var _this = possibleConstructorReturn(this, _Component.call(this, props));
                    return _this.getContext = memoize(_this.getContext.bind(_this)), _this.renderInner = _this.renderInner.bind(_this), 
                    _this;
                }
                /**
	   * Get the theme from the props, supporting both (outerTheme) => {}
	   * as well as object notation
	   */
                return inherits(ThemeProvider, _Component), ThemeProvider.prototype.render = function() {
                    return this.props.children ? React__default.createElement(ThemeContext.Consumer, null, this.renderInner) : null;
                }, ThemeProvider.prototype.renderInner = function(outerTheme) {
                    var context = this.getContext(this.props.theme, outerTheme);
                    return React__default.createElement(ThemeContext.Provider, {
                        value: context
                    }, this.props.children);
                }, ThemeProvider.prototype.getTheme = function(theme, outerTheme) {
                    if (isFunction(theme)) {
                        var mergedTheme = theme(outerTheme);
                        if ("production" !== process.env.NODE_ENV && (null === mergedTheme || Array.isArray(mergedTheme) || "object" !== ("undefined" == typeof mergedTheme ? "undefined" : _typeof(mergedTheme)))) throw new StyledComponentsError(7);
                        return mergedTheme;
                    }
                    if (null === theme || Array.isArray(theme) || "object" !== ("undefined" == typeof theme ? "undefined" : _typeof(theme))) throw new StyledComponentsError(8);
                    return _extends({}, outerTheme, theme);
                }, ThemeProvider.prototype.getContext = function(theme, outerTheme) {
                    return this.getTheme(theme, outerTheme);
                }, ThemeProvider;
            }(React.Component), ServerStyleSheet = function() {
                function ServerStyleSheet() {
                    classCallCheck(this, ServerStyleSheet), /* The master sheet might be reset, so keep a reference here */
                    this.masterSheet = StyleSheet.master, this.instance = this.masterSheet.clone(), 
                    this.sealed = !1;
                }
                /**
	   * Mark the ServerStyleSheet as being fully emitted and manually GC it from the
	   * StyleSheet singleton.
	   */
                return ServerStyleSheet.prototype.seal = function() {
                    if (!this.sealed) {
                        /* Remove sealed StyleSheets from the master sheet */
                        var index = this.masterSheet.clones.indexOf(this.instance);
                        this.masterSheet.clones.splice(index, 1), this.sealed = !0;
                    }
                }, ServerStyleSheet.prototype.collectStyles = function(children) {
                    if (this.sealed) throw new StyledComponentsError(2);
                    return React__default.createElement(StyleSheetManager, {
                        sheet: this.instance
                    }, children);
                }, ServerStyleSheet.prototype.getStyleTags = function() {
                    return this.seal(), this.instance.toHTML();
                }, ServerStyleSheet.prototype.getStyleElement = function() {
                    return this.seal(), this.instance.toReactElements();
                }, ServerStyleSheet.prototype.interleaveWithNodeStream = function(readableStream) {
                    throw new StyledComponentsError(3);
                }, ServerStyleSheet;
            }(), StyleSheetContext = React.createContext(), StyleSheetConsumer = StyleSheetContext.Consumer, StyleSheetManager = function(_Component) {
                function StyleSheetManager(props) {
                    classCallCheck(this, StyleSheetManager);
                    var _this = possibleConstructorReturn(this, _Component.call(this, props));
                    return _this.getContext = memoize(_this.getContext), _this;
                }
                return inherits(StyleSheetManager, _Component), StyleSheetManager.prototype.getContext = function(sheet, target) {
                    if (sheet) return sheet;
                    if (target) return new StyleSheet(target);
                    throw new StyledComponentsError(4);
                }, StyleSheetManager.prototype.render = function() {
                    var _props = this.props, children = _props.children, sheet = _props.sheet, target = _props.target;
                    return React__default.createElement(StyleSheetContext.Provider, {
                        value: this.getContext(sheet, target)
                    }, "production" !== process.env.NODE_ENV ? React__default.Children.only(children) : children);
                }, StyleSheetManager;
            }(React.Component);
            "production" !== process.env.NODE_ENV ? StyleSheetManager.propTypes = {
                sheet: PropTypes.oneOfType([ PropTypes.instanceOf(StyleSheet), PropTypes.instanceOf(ServerStyleSheet) ]),
                target: PropTypes.shape({
                    appendChild: PropTypes.func.isRequired
                })
            } : void 0;
            // 
            var identifiers = {}, StyledComponent = function(_Component) {
                function StyledComponent() {
                    classCallCheck(this, StyledComponent);
                    var _this = possibleConstructorReturn(this, _Component.call(this));
                    return _this.attrs = {}, _this.renderOuter = _this.renderOuter.bind(_this), _this.renderInner = _this.renderInner.bind(_this), 
                    "production" !== process.env.NODE_ENV && (_this.warnInnerRef = once(function(displayName) {
                        // eslint-disable-next-line no-console
                        return console.warn('The "innerRef" API has been removed in styled-components v4 in favor of React 16 ref forwarding, use "ref" instead like a typical component. "innerRef" was detected on component "' + displayName + '".');
                    }), _this.warnAttrsFnObjectKeyDeprecated = once(function(key, displayName) {
                        // eslint-disable-next-line no-console
                        return console.warn('Functions as object-form attrs({}) keys are now deprecated and will be removed in a future version of styled-components. Switch to the new attrs(props => ({})) syntax instead for easier and more powerful composition. The attrs key in question is "' + key + '" on component "' + displayName + '".', "\n " + new Error().stack);
                    }), _this.warnNonStyledComponentAttrsObjectKey = once(function(key, displayName) {
                        // eslint-disable-next-line no-console
                        return console.warn("It looks like you've used a non styled-component as the value for the \"" + key + '" prop in an object-form attrs constructor of "' + displayName + "\".\nYou should use the new function-form attrs constructor which avoids this issue: attrs(props => ({ yourStuff }))\nTo continue using the deprecated object syntax, you'll need to wrap your component prop in a function to make it available inside the styled component (you'll still get the deprecation warning though.)\n" + ("For example, { " + key + ": () => InnerComponent } instead of { " + key + ": InnerComponent }"));
                    })), _this;
                }
                return inherits(StyledComponent, _Component), StyledComponent.prototype.render = function() {
                    return React__default.createElement(StyleSheetConsumer, null, this.renderOuter);
                }, StyledComponent.prototype.renderOuter = function() {
                    var styleSheet = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : StyleSheet.master;
                    // No need to subscribe a static component to theme changes, it won't change anything
                    // No need to subscribe a static component to theme changes, it won't change anything
                    return this.styleSheet = styleSheet, this.props.forwardedComponent.componentStyle.isStatic ? this.renderInner() : React__default.createElement(ThemeConsumer, null, this.renderInner);
                }, StyledComponent.prototype.renderInner = function(theme) {
                    var _props$forwardedCompo = this.props.forwardedComponent, componentStyle = _props$forwardedCompo.componentStyle, defaultProps = _props$forwardedCompo.defaultProps, displayName = _props$forwardedCompo.displayName, foldedComponentIds = _props$forwardedCompo.foldedComponentIds, styledComponentId = _props$forwardedCompo.styledComponentId, target = _props$forwardedCompo.target, generatedClassName = void 0;
                    generatedClassName = componentStyle.isStatic ? this.generateAndInjectStyles(EMPTY_OBJECT, this.props) : this.generateAndInjectStyles(determineTheme(this.props, theme, defaultProps) || EMPTY_OBJECT, this.props);
                    var elementToBeCreated = this.props.as || this.attrs.as || target, isTargetTag = isTag(elementToBeCreated), propsForElement = {}, computedProps = _extends({}, this.props, this.attrs), key = void 0;
                    // eslint-disable-next-line guard-for-in
                    for (key in computedProps) "production" !== process.env.NODE_ENV && "innerRef" === key && isTargetTag && this.warnInnerRef(displayName), 
                    "forwardedComponent" !== key && "as" !== key && ("forwardedRef" === key ? propsForElement.ref = computedProps[key] : "forwardedAs" === key ? propsForElement.as = computedProps[key] : isTargetTag && !validAttr(key) || (// Don't pass through non HTML tags through to HTML elements
                    propsForElement[key] = computedProps[key]));
                    return this.props.style && this.attrs.style && (propsForElement.style = _extends({}, this.attrs.style, this.props.style)), 
                    propsForElement.className = Array.prototype.concat(foldedComponentIds, styledComponentId, generatedClassName !== styledComponentId ? generatedClassName : null, this.props.className, this.attrs.className).filter(Boolean).join(" "), 
                    React.createElement(elementToBeCreated, propsForElement);
                }, StyledComponent.prototype.buildExecutionContext = function(theme, props, attrs) {
                    var _this2 = this, context = _extends({}, props, {
                        theme: theme
                    });
                    return attrs.length ? (this.attrs = {}, attrs.forEach(function(attrDef) {
                        var resolvedAttrDef = attrDef, attrDefWasFn = !1, attr = void 0, key = void 0;
                        isFunction(resolvedAttrDef) && (// $FlowFixMe
                        resolvedAttrDef = resolvedAttrDef(context), attrDefWasFn = !0);
                        /* eslint-disable guard-for-in */
                        // $FlowFixMe
                        for (key in resolvedAttrDef) attr = resolvedAttrDef[key], attrDefWasFn || !isFunction(attr) || isDerivedReactComponent(attr) || isStyledComponent(attr) || ("production" !== process.env.NODE_ENV && _this2.warnAttrsFnObjectKeyDeprecated(key, props.forwardedComponent.displayName), 
                        attr = attr(context), "production" !== process.env.NODE_ENV && React__default.isValidElement(attr) && _this2.warnNonStyledComponentAttrsObjectKey(key, props.forwardedComponent.displayName)), 
                        _this2.attrs[key] = attr, context[key] = attr;
                    }), context) : context;
                }, StyledComponent.prototype.generateAndInjectStyles = function(theme, props) {
                    var _props$forwardedCompo2 = props.forwardedComponent, attrs = _props$forwardedCompo2.attrs, componentStyle = _props$forwardedCompo2.componentStyle, warnTooManyClasses = _props$forwardedCompo2.warnTooManyClasses;
                    // statically styled-components don't need to build an execution context object,
                    // and shouldn't be increasing the number of class names
                    if (componentStyle.isStatic && !attrs.length) return componentStyle.generateAndInjectStyles(EMPTY_OBJECT, this.styleSheet);
                    var className = componentStyle.generateAndInjectStyles(this.buildExecutionContext(theme, props, attrs), this.styleSheet);
                    return "production" !== process.env.NODE_ENV && warnTooManyClasses && warnTooManyClasses(className), 
                    className;
                }, StyledComponent;
            }(React.Component), domElements = [ "a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", // SVG
            "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan" ], styled = function(tag) {
                return constructWithOptions(createStyledComponent, tag);
            };
            // Shorthands for all valid HTML Elements
            domElements.forEach(function(domElement) {
                styled[domElement] = styled(domElement);
            });
            // 
            var GlobalStyle = function() {
                function GlobalStyle(rules, componentId) {
                    classCallCheck(this, GlobalStyle), this.rules = rules, this.componentId = componentId, 
                    this.isStatic = isStaticRules(rules, EMPTY_ARRAY), StyleSheet.master.hasId(componentId) || StyleSheet.master.deferredInject(componentId, []);
                }
                // TODO: overwrite in-place instead of remove+create?
                return GlobalStyle.prototype.createStyles = function(executionContext, styleSheet) {
                    var flatCSS = flatten(this.rules, executionContext, styleSheet), css = stringifyRules(flatCSS, "");
                    styleSheet.inject(this.componentId, css);
                }, GlobalStyle.prototype.removeStyles = function(styleSheet) {
                    var componentId = this.componentId;
                    styleSheet.hasId(componentId) && styleSheet.remove(componentId);
                }, GlobalStyle.prototype.renderStyles = function(executionContext, styleSheet) {
                    this.removeStyles(styleSheet), this.createStyles(executionContext, styleSheet);
                }, GlobalStyle;
            }();
            // 
            // place our cache into shared context so it'll persist between HMRs
            IS_BROWSER && (window.scCGSHMRCache = {});
            // 
            var replaceWhitespace = function(str) {
                return str.replace(/\s|\\n/g, "");
            }, withTheme = function(Component) {
                var WithTheme = React__default.forwardRef(function(props, ref) {
                    return React__default.createElement(ThemeConsumer, null, function(theme) {
                        // $FlowFixMe
                        var defaultProps = Component.defaultProps, themeProp = determineTheme(props, theme, defaultProps);
                        // eslint-disable-next-line no-console
                        return "production" !== process.env.NODE_ENV && void 0 === themeProp && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "' + getComponentName(Component) + '"'), 
                        React__default.createElement(Component, _extends({}, props, {
                            theme: themeProp,
                            ref: ref
                        }));
                    });
                });
                return hoistNonReactStatics(WithTheme, Component), WithTheme.displayName = "WithTheme(" + getComponentName(Component) + ")", 
                WithTheme;
            }, __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = {
                StyleSheet: StyleSheet
            };
            // 
            /* Warning if you've imported this file on React Native */
            "production" !== process.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && // eslint-disable-next-line no-console
            console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), 
            /* Warning if there are several instances of styled-components */
            "production" !== process.env.NODE_ENV && "test" !== process.env.NODE_ENV && "undefined" != typeof window && "undefined" != typeof navigator && "string" == typeof navigator.userAgent && navigator.userAgent.indexOf("Node.js") === -1 && navigator.userAgent.indexOf("jsdom") === -1 && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 
            1 === window["__styled-components-init__"] && // eslint-disable-next-line no-console
            console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles not rendering properly, errors happening during rehydration process and makes your application bigger without a good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), 
            window["__styled-components-init__"] += 1), //
            exports.default = styled, exports.createGlobalStyle = createGlobalStyle, exports.css = css, 
            exports.isStyledComponent = isStyledComponent, exports.keyframes = keyframes, exports.ServerStyleSheet = ServerStyleSheet, 
            exports.StyleSheetConsumer = StyleSheetConsumer, exports.StyleSheetContext = StyleSheetContext, 
            exports.StyleSheetManager = StyleSheetManager, exports.ThemeConsumer = ThemeConsumer, 
            exports.ThemeContext = ThemeContext, exports.ThemeProvider = ThemeProvider, exports.withTheme = withTheme, 
            exports.__DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS;
        }).call(exports, __webpack_require__(110));
    }, /* 133 */
    /***/
    function(module, exports, __webpack_require__) {
        !function(e) {
            module.exports = e(null);
        }(function e(a) {
            "use strict";
            function He(e, a, s, t, i) {
                for (var f, n, o = 0, h = 0, u = 0, d = 0, g = 0, A = 0, C = 0, w = 0, m = 0, $ = 0, y = 0, O = 0, j = 0, z = 0, R = 0, we = 0, $e = 0, Oe = 0, je = 0, ze = s.length, Je = ze - 1, Re = "", Te = "", Ue = "", Ve = "", Xe = "", Ye = ""; R < ze; ) {
                    if (C = s.charCodeAt(R), R === Je && h + d + u + o !== 0 && (0 !== h && (C = h === Z ? I : Z), 
                    d = u = o = 0, ze++, Je++), h + d + u + o === 0) {
                        if (R === Je && (we > 0 && (Te = Te.replace(c, "")), Te.trim().length > 0)) {
                            switch (C) {
                              case M:
                              case K:
                              case W:
                              case J:
                              case I:
                                break;

                              default:
                                Te += s.charAt(R);
                            }
                            C = W;
                        }
                        if (1 === $e) switch (C) {
                          case B:
                          case q:
                          case W:
                          case Y:
                          case X:
                          case D:
                          case E:
                          case U:
                            $e = 0;

                          case K:
                          case J:
                          case I:
                          case M:
                            break;

                          default:
                            for ($e = 0, je = R, g = C, R--, C = W; je < ze; ) switch (s.charCodeAt(je++)) {
                              case I:
                              case J:
                              case W:
                                ++R, C = g, je = ze;
                                break;

                              case V:
                                we > 0 && (++R, C = g);

                              case B:
                                je = ze;
                            }
                        }
                        switch (C) {
                          case B:
                            for (g = (Te = Te.trim()).charCodeAt(0), y = 1, je = ++R; R < ze; ) {
                                switch (C = s.charCodeAt(R)) {
                                  case B:
                                    y++;
                                    break;

                                  case q:
                                    y--;
                                    break;

                                  case Z:
                                    switch (A = s.charCodeAt(R + 1)) {
                                      case T:
                                      case Z:
                                        R = Qe(A, R, Je, s);
                                    }
                                    break;

                                  case G:
                                    C++;

                                  case D:
                                    C++;

                                  case Y:
                                  case X:
                                    for (;R++ < Je && s.charCodeAt(R) !== C; ) ;
                                }
                                if (0 === y) break;
                                R++;
                            }
                            switch (Ue = s.substring(je, R), g === re && (g = (Te = Te.replace(r, "").trim()).charCodeAt(0)), 
                            g) {
                              case L:
                                switch (we > 0 && (Te = Te.replace(c, "")), A = Te.charCodeAt(1)) {
                                  case ue:
                                  case ie:
                                  case fe:
                                  case Q:
                                    f = a;
                                    break;

                                  default:
                                    f = xe;
                                }
                                if (je = (Ue = He(a, f, Ue, A, i + 1)).length, me > 0 && 0 === je && (je = Te.length), 
                                ye > 0 && (f = Ie(xe, Te, Oe), n = Pe(We, Ue, f, a, pe, be, je, A, i, t), Te = f.join(""), 
                                void 0 !== n && 0 === (je = (Ue = n.trim()).length) && (A = 0, Ue = "")), je > 0) switch (A) {
                                  case fe:
                                    Te = Te.replace(x, Me);

                                  case ue:
                                  case ie:
                                  case Q:
                                    Ue = Te + "{" + Ue + "}";
                                    break;

                                  case te:
                                    Ue = (Te = Te.replace(b, "$1 $2" + (Be > 0 ? De : ""))) + "{" + Ue + "}", Ue = 1 === Ae || 2 === Ae && Le("@" + Ue, 3) ? "@" + N + Ue + "@" + Ue : "@" + Ue;
                                    break;

                                  default:
                                    Ue = Te + Ue, t === de && (Ve += Ue, Ue = "");
                                } else Ue = "";
                                break;

                              default:
                                Ue = He(a, Ie(a, Te, Oe), Ue, t, i + 1);
                            }
                            Xe += Ue, O = 0, $e = 0, z = 0, we = 0, Oe = 0, j = 0, Te = "", Ue = "", C = s.charCodeAt(++R);
                            break;

                          case q:
                          case W:
                            if ((je = (Te = (we > 0 ? Te.replace(c, "") : Te).trim()).length) > 1) switch (0 === z && ((g = Te.charCodeAt(0)) === Q || g > 96 && g < 123) && (je = (Te = Te.replace(" ", ":")).length), 
                            ye > 0 && void 0 !== (n = Pe(Se, Te, a, e, pe, be, Ve.length, t, i, t)) && 0 === (je = (Te = n.trim()).length) && (Te = "\0\0"), 
                            g = Te.charCodeAt(0), A = Te.charCodeAt(1), g) {
                              case re:
                                break;

                              case L:
                                if (A === oe || A === he) {
                                    Ye += Te + s.charAt(R);
                                    break;
                                }

                              default:
                                if (Te.charCodeAt(je - 1) === V) break;
                                Ve += Ke(Te, g, A, Te.charCodeAt(2));
                            }
                            O = 0, $e = 0, z = 0, we = 0, Oe = 0, Te = "", C = s.charCodeAt(++R);
                        }
                    }
                    switch (C) {
                      case J:
                      case I:
                        if (h + d + u + o + ve === 0) switch ($) {
                          case E:
                          case X:
                          case Y:
                          case L:
                          case ae:
                          case _:
                          case T:
                          case ee:
                          case Z:
                          case Q:
                          case V:
                          case U:
                          case W:
                          case B:
                          case q:
                            break;

                          default:
                            z > 0 && ($e = 1);
                        }
                        h === Z ? h = 0 : ge + O === 0 && t !== te && Te.length > 0 && (we = 1, Te += "\0"), 
                        ye * qe > 0 && Pe(Ne, Te, a, e, pe, be, Ve.length, t, i, t), be = 1, pe++;
                        break;

                      case W:
                      case q:
                        if (h + d + u + o === 0) {
                            be++;
                            break;
                        }

                      default:
                        switch (be++, Re = s.charAt(R), C) {
                          case K:
                          case M:
                            if (d + o + h === 0) switch (w) {
                              case U:
                              case V:
                              case K:
                              case M:
                                Re = "";
                                break;

                              default:
                                C !== M && (Re = " ");
                            }
                            break;

                          case re:
                            Re = "\\0";
                            break;

                          case ce:
                            Re = "\\f";
                            break;

                          case se:
                            Re = "\\v";
                            break;

                          case P:
                            d + h + o === 0 && ge > 0 && (Oe = 1, we = 1, Re = "\f" + Re);
                            break;

                          case 108:
                            if (d + h + o + ke === 0 && z > 0) switch (R - z) {
                              case 2:
                                w === ne && s.charCodeAt(R - 3) === V && (ke = w);

                              case 8:
                                m === le && (ke = m);
                            }
                            break;

                          case V:
                            d + h + o === 0 && (z = R);
                            break;

                          case U:
                            h + u + d + o === 0 && (we = 1, Re += "\r");
                            break;

                          case Y:
                          case X:
                            0 === h && (d = d === C ? 0 : 0 === d ? C : d);
                            break;

                          case G:
                            d + h + u === 0 && o++;
                            break;

                          case H:
                            d + h + u === 0 && o--;
                            break;

                          case E:
                            d + h + o === 0 && u--;
                            break;

                          case D:
                            if (d + h + o === 0) {
                                if (0 === O) switch (2 * w + 3 * m) {
                                  case 533:
                                    break;

                                  default:
                                    y = 0, O = 1;
                                }
                                u++;
                            }
                            break;

                          case L:
                            h + u + d + o + z + j === 0 && (j = 1);
                            break;

                          case T:
                          case Z:
                            if (d + o + u > 0) break;
                            switch (h) {
                              case 0:
                                switch (2 * C + 3 * s.charCodeAt(R + 1)) {
                                  case 235:
                                    h = Z;
                                    break;

                                  case 220:
                                    je = R, h = T;
                                }
                                break;

                              case T:
                                C === Z && w === T && je + 2 !== R && (33 === s.charCodeAt(je + 2) && (Ve += s.substring(je, R + 1)), 
                                Re = "", h = 0);
                            }
                        }
                        if (0 === h) {
                            if (ge + d + o + j === 0 && t !== te && C !== W) switch (C) {
                              case U:
                              case ae:
                              case _:
                              case ee:
                              case E:
                              case D:
                                if (0 === O) {
                                    switch (w) {
                                      case K:
                                      case M:
                                      case I:
                                      case J:
                                        Re += "\0";
                                        break;

                                      default:
                                        Re = "\0" + Re + (C === U ? "" : "\0");
                                    }
                                    we = 1;
                                } else switch (C) {
                                  case D:
                                    z + 7 === R && 108 === w && (z = 0), O = ++y;
                                    break;

                                  case E:
                                    0 == (O = --y) && (we = 1, Re += "\0");
                                }
                                break;

                              case K:
                              case M:
                                switch (w) {
                                  case re:
                                  case B:
                                  case q:
                                  case W:
                                  case U:
                                  case ce:
                                  case K:
                                  case M:
                                  case I:
                                  case J:
                                    break;

                                  default:
                                    0 === O && (we = 1, Re += "\0");
                                }
                            }
                            Te += Re, C !== M && C !== K && ($ = C);
                        }
                    }
                    m = w, w = C, R++;
                }
                if (je = Ve.length, me > 0 && 0 === je && 0 === Xe.length && 0 === a[0].length == 0 && (t !== ie || 1 === a.length && (ge > 0 ? Ee : Ge) === a[0]) && (je = a.join(",").length + 2), 
                je > 0) {
                    if (f = 0 === ge && t !== te ? function(e) {
                        for (var a, r, s = 0, t = e.length, i = Array(t); s < t; ++s) {
                            for (var f = e[s].split(l), n = "", o = 0, h = 0, u = 0, d = 0, b = f.length; o < b; ++o) if (!(0 === (h = (r = f[o]).length) && b > 1)) {
                                if (u = n.charCodeAt(n.length - 1), d = r.charCodeAt(0), a = "", 0 !== o) switch (u) {
                                  case T:
                                  case ae:
                                  case _:
                                  case ee:
                                  case M:
                                  case D:
                                    break;

                                  default:
                                    a = " ";
                                }
                                switch (d) {
                                  case P:
                                    r = a + Ee;

                                  case ae:
                                  case _:
                                  case ee:
                                  case M:
                                  case E:
                                  case D:
                                    break;

                                  case G:
                                    r = a + r + Ee;
                                    break;

                                  case V:
                                    switch (2 * r.charCodeAt(1) + 3 * r.charCodeAt(2)) {
                                      case 530:
                                        if (Ce > 0) {
                                            r = a + r.substring(8, h - 1);
                                            break;
                                        }

                                      default:
                                        (o < 1 || f[o - 1].length < 1) && (r = a + Ee + r);
                                    }
                                    break;

                                  case U:
                                    a = "";

                                  default:
                                    r = h > 1 && r.indexOf(":") > 0 ? a + r.replace(v, "$1" + Ee + "$2") : a + r + Ee;
                                }
                                n += r;
                            }
                            i[s] = n.replace(c, "").trim();
                        }
                        return i;
                    }(a) : a, ye > 0 && void 0 !== (n = Pe(Fe, Ve, f, e, pe, be, je, t, i, t)) && 0 === (Ve = n).length) return Ye + Ve + Xe;
                    if (Ve = f.join(",") + "{" + Ve + "}", Ae * ke != 0) {
                        switch (2 !== Ae || Le(Ve, 2) || (ke = 0), ke) {
                          case le:
                            Ve = Ve.replace(k, ":" + S + "$1") + Ve;
                            break;

                          case ne:
                            Ve = Ve.replace(p, "::" + N + "input-$1") + Ve.replace(p, "::" + S + "$1") + Ve.replace(p, ":" + F + "input-$1") + Ve;
                        }
                        ke = 0;
                    }
                }
                return Ye + Ve + Xe;
            }
            function Ie(e, a, r) {
                var c = a.trim().split(o), s = c, t = c.length, i = e.length;
                switch (i) {
                  case 0:
                  case 1:
                    for (var f = 0, n = 0 === i ? "" : e[0] + " "; f < t; ++f) s[f] = Je(n, s[f], r, i).trim();
                    break;

                  default:
                    f = 0;
                    var l = 0;
                    for (s = []; f < t; ++f) for (var h = 0; h < i; ++h) s[l++] = Je(e[h] + " ", c[f], r, i).trim();
                }
                return s;
            }
            function Je(e, a, r, c) {
                var s = a, t = s.charCodeAt(0);
                switch (t < 33 && (t = (s = s.trim()).charCodeAt(0)), t) {
                  case P:
                    switch (ge + c) {
                      case 0:
                      case 1:
                        if (0 === e.trim().length) break;

                      default:
                        return s.replace(h, "$1" + e.trim());
                    }
                    break;

                  case V:
                    switch (s.charCodeAt(1)) {
                      case 103:
                        if (Ce > 0 && ge > 0) return s.replace(u, "$1").replace(h, "$1" + Ge);
                        break;

                      default:
                        return e.trim() + s.replace(h, "$1" + e.trim());
                    }

                  default:
                    if (r * ge > 0 && s.indexOf("\f") > 0) return s.replace(h, (e.charCodeAt(0) === V ? "" : "$1") + e.trim());
                }
                return e + s;
            }
            function Ke(e, a, r, c) {
                var l, o = 0, h = e + ";", u = 2 * a + 3 * r + 4 * c;
                if (944 === u) return function(e) {
                    var a = e.length, r = e.indexOf(":", 9) + 1, c = e.substring(0, r).trim(), s = e.substring(r, a - 1).trim();
                    switch (e.charCodeAt(9) * Be) {
                      case 0:
                        break;

                      case Q:
                        if (110 !== e.charCodeAt(10)) break;

                      default:
                        for (var t = s.split((s = "", f)), i = 0, r = 0, a = t.length; i < a; r = 0, ++i) {
                            for (var l = t[i], o = l.split(n); l = o[r]; ) {
                                var h = l.charCodeAt(0);
                                if (1 === Be && (h > L && h < 90 || h > 96 && h < 123 || h === R || h === Q && l.charCodeAt(1) !== Q)) switch (isNaN(parseFloat(l)) + (-1 !== l.indexOf("("))) {
                                  case 1:
                                    switch (l) {
                                      case "infinite":
                                      case "alternate":
                                      case "backwards":
                                      case "running":
                                      case "normal":
                                      case "forwards":
                                      case "both":
                                      case "none":
                                      case "linear":
                                      case "ease":
                                      case "ease-in":
                                      case "ease-out":
                                      case "ease-in-out":
                                      case "paused":
                                      case "reverse":
                                      case "alternate-reverse":
                                      case "inherit":
                                      case "initial":
                                      case "unset":
                                      case "step-start":
                                      case "step-end":
                                        break;

                                      default:
                                        l += De;
                                    }
                                }
                                o[r++] = l;
                            }
                            s += (0 === i ? "" : ",") + o.join(" ");
                        }
                    }
                    return s = c + s + ";", 1 === Ae || 2 === Ae && Le(s, 1) ? N + s + s : s;
                }(h);
                if (0 === Ae || 2 === Ae && !Le(h, 1)) return h;
                switch (u) {
                  case 1015:
                    return 97 === h.charCodeAt(10) ? N + h + h : h;

                  case 951:
                    return 116 === h.charCodeAt(3) ? N + h + h : h;

                  case 963:
                    return 110 === h.charCodeAt(5) ? N + h + h : h;

                  case 1009:
                    if (100 !== h.charCodeAt(4)) break;

                  case 969:
                  case 942:
                    return N + h + h;

                  case 978:
                    return N + h + S + h + h;

                  case 1019:
                  case 983:
                    return N + h + S + h + F + h + h;

                  case 883:
                    return h.charCodeAt(8) === Q ? N + h + h : h.indexOf("image-set(", 11) > 0 ? h.replace(z, "$1" + N + "$2") + h : h;

                  case 932:
                    if (h.charCodeAt(4) === Q) switch (h.charCodeAt(5)) {
                      case 103:
                        return N + "box-" + h.replace("-grow", "") + N + h + F + h.replace("grow", "positive") + h;

                      case 115:
                        return N + h + F + h.replace("shrink", "negative") + h;

                      case 98:
                        return N + h + F + h.replace("basis", "preferred-size") + h;
                    }
                    return N + h + F + h + h;

                  case 964:
                    return N + h + F + "flex-" + h + h;

                  case 1023:
                    if (99 !== h.charCodeAt(8)) break;
                    return l = h.substring(h.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), 
                    N + "box-pack" + l + N + h + F + "flex-pack" + l + h;

                  case 1005:
                    return t.test(h) ? h.replace(s, ":" + N) + h.replace(s, ":" + S) + h : h;

                  case 1e3:
                    switch (o = (l = h.substring(13).trim()).indexOf("-") + 1, l.charCodeAt(0) + l.charCodeAt(o)) {
                      case 226:
                        l = h.replace(m, "tb");
                        break;

                      case 232:
                        l = h.replace(m, "tb-rl");
                        break;

                      case 220:
                        l = h.replace(m, "lr");
                        break;

                      default:
                        return h;
                    }
                    return N + h + F + l + h;

                  case 1017:
                    if (-1 === h.indexOf("sticky", 9)) return h;

                  case 975:
                    switch (o = (h = e).length - 10, u = (l = (33 === h.charCodeAt(o) ? h.substring(0, o) : h).substring(e.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | l.charCodeAt(7))) {
                      case 203:
                        if (l.charCodeAt(8) < 111) break;

                      case 115:
                        h = h.replace(l, N + l) + ";" + h;
                        break;

                      case 207:
                      case 102:
                        h = h.replace(l, N + (u > 102 ? "inline-" : "") + "box") + ";" + h.replace(l, N + l) + ";" + h.replace(l, F + l + "box") + ";" + h;
                    }
                    return h + ";";

                  case 938:
                    if (h.charCodeAt(5) === Q) switch (h.charCodeAt(6)) {
                      case 105:
                        return l = h.replace("-items", ""), N + h + N + "box-" + l + F + "flex-" + l + h;

                      case 115:
                        return N + h + F + "flex-item-" + h.replace(y, "") + h;

                      default:
                        return N + h + F + "flex-line-pack" + h.replace("align-content", "").replace(y, "") + h;
                    }
                    break;

                  case 973:
                  case 989:
                    if (h.charCodeAt(3) !== Q || 122 === h.charCodeAt(4)) break;

                  case 931:
                  case 953:
                    if (!0 === j.test(e)) return 115 === (l = e.substring(e.indexOf(":") + 1)).charCodeAt(0) ? Ke(e.replace("stretch", "fill-available"), a, r, c).replace(":fill-available", ":stretch") : h.replace(l, N + l) + h.replace(l, S + l.replace("fill-", "")) + h;
                    break;

                  case 962:
                    if (h = N + h + (102 === h.charCodeAt(5) ? F + h : "") + h, r + c === 211 && 105 === h.charCodeAt(13) && h.indexOf("transform", 10) > 0) return h.substring(0, h.indexOf(";", 27) + 1).replace(i, "$1" + N + "$2") + h;
                }
                return h;
            }
            function Le(e, a) {
                var r = e.indexOf(1 === a ? ":" : "{"), c = e.substring(0, 3 !== a ? r : 10), s = e.substring(r + 1, e.length - 1);
                return Oe(2 !== a ? c : c.replace(O, "$1"), s, a);
            }
            function Me(e, a) {
                var r = Ke(a, a.charCodeAt(0), a.charCodeAt(1), a.charCodeAt(2));
                return r !== a + ";" ? r.replace($, " or ($1)").substring(4) : "(" + a + ")";
            }
            function Pe(e, a, r, c, s, t, i, f, n, l) {
                for (var o, h = 0, u = a; h < ye; ++h) switch (o = $e[h].call(Te, e, u, r, c, s, t, i, f, n, l)) {
                  case void 0:
                  case !1:
                  case !0:
                  case null:
                    break;

                  default:
                    u = o;
                }
                if (u !== a) return u;
            }
            function Qe(e, a, r, c) {
                for (var s = a + 1; s < r; ++s) switch (c.charCodeAt(s)) {
                  case Z:
                    if (e === T && c.charCodeAt(s - 1) === T && a + 2 !== s) return s + 1;
                    break;

                  case I:
                    if (e === Z) return s + 1;
                }
                return s;
            }
            function Re(e) {
                for (var a in e) {
                    var r = e[a];
                    switch (a) {
                      case "keyframe":
                        Be = 0 | r;
                        break;

                      case "global":
                        Ce = 0 | r;
                        break;

                      case "cascade":
                        ge = 0 | r;
                        break;

                      case "compress":
                        we = 0 | r;
                        break;

                      case "semicolon":
                        ve = 0 | r;
                        break;

                      case "preserve":
                        me = 0 | r;
                        break;

                      case "prefix":
                        Oe = null, r ? "function" != typeof r ? Ae = 1 : (Ae = 2, Oe = r) : Ae = 0;
                    }
                }
                return Re;
            }
            function Te(a, r) {
                if (void 0 !== this && this.constructor === Te) return e(a);
                var s = a, t = s.charCodeAt(0);
                t < 33 && (t = (s = s.trim()).charCodeAt(0)), Be > 0 && (De = s.replace(d, t === G ? "" : "-")), 
                t = 1, 1 === ge ? Ge = s : Ee = s;
                var i, f = [ Ge ];
                ye > 0 && void 0 !== (i = Pe(ze, r, f, f, pe, be, 0, 0, 0, 0)) && "string" == typeof i && (r = i);
                var n = He(xe, f, r, 0, 0);
                return ye > 0 && void 0 !== (i = Pe(je, n, f, f, pe, be, n.length, 0, 0, 0)) && "string" != typeof (n = i) && (t = 0), 
                De = "", Ge = "", Ee = "", ke = 0, pe = 1, be = 1, we * t == 0 ? n : n.replace(c, "").replace(g, "").replace(A, "$1").replace(C, "$1").replace(w, " ");
            }
            var r = /^\0+/g, c = /[\0\r\f]/g, s = /: */g, t = /zoo|gra/, i = /([,: ])(transform)/g, f = /,+\s*(?![^(]*[)])/g, n = / +\s*(?![^(]*[)])/g, l = / *[\0] */g, o = /,\r+?/g, h = /([\t\r\n ])*\f?&/g, u = /:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g, d = /\W+/g, b = /@(k\w+)\s*(\S*)\s*/, p = /::(place)/g, k = /:(read-only)/g, g = /\s+(?=[{\];=:>])/g, A = /([[}=:>])\s+/g, C = /(\{[^{]+?);(?=\})/g, w = /\s{2,}/g, v = /([^\(])(:+) */g, m = /[svh]\w+-[tblr]{2}/, x = /\(\s*(.*)\s*\)/g, $ = /([\s\S]*?);/g, y = /-self|flex-/g, O = /[^]*?(:[rp][el]a[\w-]+)[^]*/, j = /stretch|:\s*\w+\-(?:conte|avail)/, z = /([^-])(image-set\()/, N = "-webkit-", S = "-moz-", F = "-ms-", W = 59, q = 125, B = 123, D = 40, E = 41, G = 91, H = 93, I = 10, J = 13, K = 9, L = 64, M = 32, P = 38, Q = 45, R = 95, T = 42, U = 44, V = 58, X = 39, Y = 34, Z = 47, _ = 62, ee = 43, ae = 126, re = 0, ce = 12, se = 11, te = 107, ie = 109, fe = 115, ne = 112, le = 111, oe = 105, he = 99, ue = 100, de = 112, be = 1, pe = 1, ke = 0, ge = 1, Ae = 1, Ce = 1, we = 0, ve = 0, me = 0, xe = [], $e = [], ye = 0, Oe = null, je = -2, ze = -1, Ne = 0, Se = 1, Fe = 2, We = 3, qe = 0, Be = 1, De = "", Ee = "", Ge = "";
            return Te.use = function e(a) {
                switch (a) {
                  case void 0:
                  case null:
                    ye = $e.length = 0;
                    break;

                  default:
                    if ("function" == typeof a) $e[ye++] = a; else if ("object" == typeof a) for (var r = 0, c = a.length; r < c; ++r) e(a[r]); else qe = 0 | !!a;
                }
                return e;
            }, Te.set = Re, void 0 !== a && Re(a), Te;
        });
    }, /* 134 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(module) {
            !function(factory) {
                module.exports = factory();
            }(function() {
                "use strict";
                return function(insertRule) {
                    function toSheet(block) {
                        if (block) try {
                            insertRule(block + "}");
                        } catch (e) {}
                    }
                    var delimiter = "/*|*/", needle = delimiter + "}";
                    return function(context, content, selectors, parents, line, column, length, ns, depth, at) {
                        switch (context) {
                          // property
                            case 1:
                            // @import
                            if (0 === depth && 64 === content.charCodeAt(0)) return insertRule(content + ";"), 
                            "";
                            break;

                          // selector
                            case 2:
                            if (0 === ns) return content + delimiter;
                            break;

                          // at-rule
                            case 3:
                            switch (ns) {
                              // @font-face, @page
                                case 102:
                              case 112:
                                return insertRule(selectors[0] + content), "";

                              default:
                                return content + (0 === at ? delimiter : "");
                            }

                          case -2:
                            content.split(needle).forEach(toSheet);
                        }
                    };
                };
            });
        }).call(exports, __webpack_require__(124)(module));
    }, /* 135 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var unitlessKeys = {
            animationIterationCount: 1,
            borderImageOutset: 1,
            borderImageSlice: 1,
            borderImageWidth: 1,
            boxFlex: 1,
            boxFlexGroup: 1,
            boxOrdinalGroup: 1,
            columnCount: 1,
            columns: 1,
            flex: 1,
            flexGrow: 1,
            flexPositive: 1,
            flexShrink: 1,
            flexNegative: 1,
            flexOrder: 1,
            gridRow: 1,
            gridRowEnd: 1,
            gridRowSpan: 1,
            gridRowStart: 1,
            gridColumn: 1,
            gridColumnEnd: 1,
            gridColumnSpan: 1,
            gridColumnStart: 1,
            msGridRow: 1,
            msGridRowSpan: 1,
            msGridColumn: 1,
            msGridColumnSpan: 1,
            fontWeight: 1,
            lineHeight: 1,
            opacity: 1,
            order: 1,
            orphans: 1,
            tabSize: 1,
            widows: 1,
            zIndex: 1,
            zoom: 1,
            WebkitLineClamp: 1,
            // SVG-related properties
            fillOpacity: 1,
            floodOpacity: 1,
            stopOpacity: 1,
            strokeDasharray: 1,
            strokeDashoffset: 1,
            strokeMiterlimit: 1,
            strokeOpacity: 1,
            strokeWidth: 1
        };
        exports.default = unitlessKeys;
    }, /* 136 */
    /***/
    function(module, exports) {
        "use strict";
        function areInputsEqual(newInputs, lastInputs) {
            if (newInputs.length !== lastInputs.length) return !1;
            for (var i = 0; i < newInputs.length; i++) if (newInputs[i] !== lastInputs[i]) return !1;
            return !0;
        }
        function memoizeOne(resultFn, isEqual) {
            function memoized() {
                for (var newArgs = [], _i = 0; _i < arguments.length; _i++) newArgs[_i] = arguments[_i];
                return calledOnce && lastThis === this && isEqual(newArgs, lastArgs) ? lastResult : (lastResult = resultFn.apply(this, newArgs), 
                calledOnce = !0, lastThis = this, lastArgs = newArgs, lastResult);
            }
            void 0 === isEqual && (isEqual = areInputsEqual);
            var lastThis, lastResult, lastArgs = [], calledOnce = !1;
            return memoized;
        }
        module.exports = memoizeOne;
    }, /* 137 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopDefault(ex) {
            return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var memoize = _interopDefault(__webpack_require__(138)), reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, index = memoize(function(prop) {
            return reactPropsRegex.test(prop) || 111 === prop.charCodeAt(0) && 110 === prop.charCodeAt(1) && prop.charCodeAt(2) < 91;
        });
        exports.default = index;
    }, /* 138 */
    /***/
    function(module, exports) {
        "use strict";
        function memoize(fn) {
            var cache = {};
            return function(arg) {
                return void 0 === cache[arg] && (cache[arg] = fn(arg)), cache[arg];
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = memoize;
    }, /* 139 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
        function __spreadArrays() {
            for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
            for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
            k++) r[k] = a[j];
            return r;
        }
        function assignProp(carry, key, newVal, originalObject) {
            var propType = originalObject.propertyIsEnumerable(key) ? "enumerable" : "nonenumerable";
            "enumerable" === propType && (carry[key] = newVal), "nonenumerable" === propType && Object.defineProperty(carry, key, {
                value: newVal,
                enumerable: !1,
                writable: !0,
                configurable: !0
            });
        }
        function mergeRecursively(origin, newComer, extensions) {
            // work directly on newComer if its not an object
            if (!isWhat.isPlainObject(newComer)) // extend merge rules
            return extensions && isWhat.isArray(extensions) && extensions.forEach(function(extend) {
                newComer = extend(origin, newComer);
            }), newComer;
            // define newObject to merge all values upon
            var newObject = {};
            if (isWhat.isPlainObject(origin)) {
                var props_1 = Object.getOwnPropertyNames(origin), symbols_1 = Object.getOwnPropertySymbols(origin);
                newObject = __spreadArrays(props_1, symbols_1).reduce(function(carry, key) {
                    // @ts-ignore
                    var targetVal = origin[key];
                    return (!isWhat.isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key) || isWhat.isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key)) && assignProp(carry, key, targetVal, origin), 
                    carry;
                }, {});
            }
            var props = Object.getOwnPropertyNames(newComer), symbols = Object.getOwnPropertySymbols(newComer), result = __spreadArrays(props, symbols).reduce(function(carry, key) {
                // re-define the origin and newComer as targetVal and newVal
                var newVal = newComer[key], targetVal = isWhat.isPlainObject(origin) ? origin[key] : void 0;
                // extend merge rules
                // When newVal is an object do the merge recursively
                return extensions && isWhat.isArray(extensions) && extensions.forEach(function(extend) {
                    newVal = extend(targetVal, newVal);
                }), void 0 !== targetVal && isWhat.isPlainObject(newVal) && (newVal = mergeRecursively(targetVal, newVal, extensions)), 
                assignProp(carry, key, newVal, newComer), carry;
            }, newObject);
            return result;
        }
        /**
	 * Merge anything recursively.
	 * Objects get merged, special objects (classes etc.) are re-assigned "as is".
	 * Basic types overwrite objects or other basic types.
	 *
	 * @param {(IConfig | any)} origin
	 * @param {...any[]} newComers
	 * @returns the result
	 */
        function merge(origin) {
            for (var newComers = [], _i = 1; _i < arguments.length; _i++) newComers[_i - 1] = arguments[_i];
            var extensions = null, base = origin;
            return isWhat.isPlainObject(origin) && origin.extensions && 1 === Object.keys(origin).length && (base = {}, 
            extensions = origin.extensions), newComers.reduce(function(result, newComer) {
                return mergeRecursively(result, newComer, extensions);
            }, base);
        }
        function concatArrays(originVal, newVal) {
            return isWhat.isArray(originVal) && isWhat.isArray(newVal) ? originVal.concat(newVal) : newVal;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var isWhat = __webpack_require__(140);
        exports.concatArrays = concatArrays, exports.default = merge, exports.merge = merge;
    }, /* 140 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Returns the object type of the given payload
	 *
	 * @param {*} payload
	 * @returns {string}
	 */
        function getType(payload) {
            return Object.prototype.toString.call(payload).slice(8, -1);
        }
        /**
	 * Returns whether the payload is undefined
	 *
	 * @param {*} payload
	 * @returns {payload is undefined}
	 */
        function isUndefined(payload) {
            return "Undefined" === getType(payload);
        }
        /**
	 * Returns whether the payload is null
	 *
	 * @param {*} payload
	 * @returns {payload is null}
	 */
        function isNull(payload) {
            return "Null" === getType(payload);
        }
        /**
	 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
	 *
	 * @param {*} payload
	 * @returns {payload is Record<string, any>}
	 */
        function isPlainObject(payload) {
            return "Object" === getType(payload) && (payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype);
        }
        /**
	 * Returns whether the payload is a plain JavaScript object (excluding special classes or objects with other prototypes)
	 *
	 * @param {*} payload
	 * @returns {payload is Record<string, any>}
	 */
        function isObject(payload) {
            return isPlainObject(payload);
        }
        /**
	 * Returns whether the payload is a an empty object (excluding special classes or objects with other prototypes)
	 *
	 * @param {*} payload
	 * @returns {payload is { [K in any]: never }}
	 */
        function isEmptyObject(payload) {
            return isPlainObject(payload) && 0 === Object.keys(payload).length;
        }
        /**
	 * Returns whether the payload is an any kind of object (including special classes or objects with different prototypes)
	 *
	 * @param {*} payload
	 * @returns {payload is Record<string, any>}
	 */
        function isAnyObject(payload) {
            return "Object" === getType(payload);
        }
        /**
	 * Returns whether the payload is an object like a type passed in < >
	 *
	 * Usage: isObjectLike<{id: any}>(payload) // will make sure it's an object and has an `id` prop.
	 *
	 * @template T this must be passed in < >
	 * @param {*} payload
	 * @returns {payload is T}
	 */
        function isObjectLike(payload) {
            return isAnyObject(payload);
        }
        /**
	 * Returns whether the payload is a function
	 *
	 * @param {*} payload
	 * @returns {payload is AnyFunction}
	 */
        function isFunction(payload) {
            return "Function" === getType(payload);
        }
        /**
	 * Returns whether the payload is an array
	 *
	 * @param {any} payload
	 * @returns {payload is any[]}
	 */
        function isArray(payload) {
            return "Array" === getType(payload);
        }
        /**
	 * Returns whether the payload is a an empty array
	 *
	 * @param {*} payload
	 * @returns {payload is []}
	 */
        function isEmptyArray(payload) {
            return isArray(payload) && 0 === payload.length;
        }
        /**
	 * Returns whether the payload is a string
	 *
	 * @param {*} payload
	 * @returns {payload is string}
	 */
        function isString(payload) {
            return "String" === getType(payload);
        }
        /**
	 * Returns whether the payload is a string, BUT returns false for ''
	 *
	 * @param {*} payload
	 * @returns {payload is string}
	 */
        function isFullString(payload) {
            return isString(payload) && "" !== payload;
        }
        /**
	 * Returns whether the payload is ''
	 *
	 * @param {*} payload
	 * @returns {payload is string}
	 */
        function isEmptyString(payload) {
            return "" === payload;
        }
        /**
	 * Returns whether the payload is a number (but not NaN)
	 *
	 * This will return `false` for `NaN`!!
	 *
	 * @param {*} payload
	 * @returns {payload is number}
	 */
        function isNumber(payload) {
            return "Number" === getType(payload) && !isNaN(payload);
        }
        /**
	 * Returns whether the payload is a boolean
	 *
	 * @param {*} payload
	 * @returns {payload is boolean}
	 */
        function isBoolean(payload) {
            return "Boolean" === getType(payload);
        }
        /**
	 * Returns whether the payload is a regular expression (RegExp)
	 *
	 * @param {*} payload
	 * @returns {payload is RegExp}
	 */
        function isRegExp(payload) {
            return "RegExp" === getType(payload);
        }
        /**
	 * Returns whether the payload is a Map
	 *
	 * @param {*} payload
	 * @returns {payload is Map<any, any>}
	 */
        function isMap(payload) {
            return "Map" === getType(payload);
        }
        /**
	 * Returns whether the payload is a WeakMap
	 *
	 * @param {*} payload
	 * @returns {payload is WeakMap<any, any>}
	 */
        function isWeakMap(payload) {
            return "WeakMap" === getType(payload);
        }
        /**
	 * Returns whether the payload is a Set
	 *
	 * @param {*} payload
	 * @returns {payload is Set<any>}
	 */
        function isSet(payload) {
            return "Set" === getType(payload);
        }
        /**
	 * Returns whether the payload is a WeakSet
	 *
	 * @param {*} payload
	 * @returns {payload is WeakSet<any>}
	 */
        function isWeakSet(payload) {
            return "WeakSet" === getType(payload);
        }
        /**
	 * Returns whether the payload is a Symbol
	 *
	 * @param {*} payload
	 * @returns {payload is symbol}
	 */
        function isSymbol(payload) {
            return "Symbol" === getType(payload);
        }
        /**
	 * Returns whether the payload is a Date, and that the date is valid
	 *
	 * @param {*} payload
	 * @returns {payload is Date}
	 */
        function isDate(payload) {
            return "Date" === getType(payload) && !isNaN(payload);
        }
        /**
	 * Returns whether the payload is a Blob
	 *
	 * @param {*} payload
	 * @returns {payload is Blob}
	 */
        function isBlob(payload) {
            return "Blob" === getType(payload);
        }
        /**
	 * Returns whether the payload is a File
	 *
	 * @param {*} payload
	 * @returns {payload is File}
	 */
        function isFile(payload) {
            return "File" === getType(payload);
        }
        /**
	 * Returns whether the payload is a Promise
	 *
	 * @param {*} payload
	 * @returns {payload is Promise<any>}
	 */
        function isPromise(payload) {
            return "Promise" === getType(payload);
        }
        /**
	 * Returns whether the payload is an Error
	 *
	 * @param {*} payload
	 * @returns {payload is Error}
	 */
        function isError(payload) {
            return "Error" === getType(payload);
        }
        /**
	 * Returns whether the payload is literally the value `NaN` (it's `NaN` and also a `number`)
	 *
	 * @param {*} payload
	 * @returns {payload is typeof NaN}
	 */
        function isNaNValue(payload) {
            return "Number" === getType(payload) && isNaN(payload);
        }
        /**
	 * Returns whether the payload is a primitive type (eg. Boolean | Null | Undefined | Number | String | Symbol)
	 *
	 * @param {*} payload
	 * @returns {(payload is boolean | null | undefined | number | string | symbol)}
	 */
        function isPrimitive(payload) {
            return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
        }
        /**
	 * Returns true whether the payload is null or undefined
	 *
	 * @param {*} payload
	 * @returns {(payload is null | undefined)}
	 */
        function isNullOrUndefined(payload) {
            return isNull(payload) || isUndefined(payload);
        }
        /**
	 * Does a generic check to check that the given payload is of a given type.
	 * In cases like Number, it will return true for NaN as NaN is a Number (thanks javascript!);
	 * It will, however, differentiate between object and null
	 *
	 * @template T
	 * @param {*} payload
	 * @param {T} type
	 * @throws {TypeError} Will throw type error if type is an invalid type
	 * @returns {payload is T}
	 */
        function isType(payload, type) {
            if (!(type instanceof Function)) throw new TypeError("Type must be a function");
            if (!Object.prototype.hasOwnProperty.call(type, "prototype")) throw new TypeError("Type is not a class");
            // Classes usually have names (as functions usually have names)
            var name = type.name;
            return getType(payload) === name || Boolean(payload && payload.constructor === type);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getType = getType, exports.isAnyObject = isAnyObject, exports.isArray = isArray, 
        exports.isBlob = isBlob, exports.isBoolean = isBoolean, exports.isDate = isDate, 
        exports.isEmptyArray = isEmptyArray, exports.isEmptyObject = isEmptyObject, exports.isEmptyString = isEmptyString, 
        exports.isError = isError, exports.isFile = isFile, exports.isFullString = isFullString, 
        exports.isFunction = isFunction, exports.isMap = isMap, exports.isNaNValue = isNaNValue, 
        exports.isNull = isNull, exports.isNullOrUndefined = isNullOrUndefined, exports.isNumber = isNumber, 
        exports.isObject = isObject, exports.isObjectLike = isObjectLike, exports.isPlainObject = isPlainObject, 
        exports.isPrimitive = isPrimitive, exports.isPromise = isPromise, exports.isRegExp = isRegExp, 
        exports.isSet = isSet, exports.isString = isString, exports.isSymbol = isSymbol, 
        exports.isType = isType, exports.isUndefined = isUndefined, exports.isWeakMap = isWeakMap, 
        exports.isWeakSet = isWeakSet;
    }, /* 141 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: https://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(131), __webpack_require__(142), __webpack_require__(143));
        }(function(CodeMirror) {
            "use strict";
            // Depth means the amount of open braces in JS context, in XML
            // context 0 means not in tag, 1 means in tag, and 2 means in tag
            // and js block comment.
            function Context(state, mode, depth, prev) {
                this.state = state, this.mode = mode, this.depth = depth, this.prev = prev;
            }
            function copyContext(context) {
                return new Context(CodeMirror.copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev));
            }
            CodeMirror.defineMode("jsx", function(config, modeConfig) {
                function flatXMLIndent(state) {
                    var tagName = state.tagName;
                    state.tagName = null;
                    var result = xmlMode.indent(state, "", "");
                    return state.tagName = tagName, result;
                }
                function token(stream, state) {
                    return state.context.mode == xmlMode ? xmlToken(stream, state, state.context) : jsToken(stream, state, state.context);
                }
                function xmlToken(stream, state, cx) {
                    if (2 == cx.depth) // Inside a JS /* */ comment
                    return stream.match(/^.*?\*\//) ? cx.depth = 1 : stream.skipToEnd(), "comment";
                    if ("{" == stream.peek()) {
                        xmlMode.skipAttribute(cx.state);
                        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context;
                        // If JS starts on same line as tag
                        if (xmlContext && stream.match(/^[^>]*>\s*$/, !1)) {
                            for (;xmlContext.prev && !xmlContext.startOfLine; ) xmlContext = xmlContext.prev;
                            // If tag starts the line, use XML indentation level
                            xmlContext.startOfLine ? indent -= config.indentUnit : cx.prev.state.lexical && (indent = cx.prev.state.lexical.indented);
                        } else 1 == cx.depth && (indent += config.indentUnit);
                        return state.context = new Context(CodeMirror.startState(jsMode, indent), jsMode, 0, state.context), 
                        null;
                    }
                    if (1 == cx.depth) {
                        // Inside of tag
                        if ("<" == stream.peek()) // Tag inside of tag
                        return xmlMode.skipAttribute(cx.state), state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context), 
                        null;
                        if (stream.match("//")) return stream.skipToEnd(), "comment";
                        if (stream.match("/*")) return cx.depth = 2, token(stream, state);
                    }
                    var stop, style = xmlMode.token(stream, cx.state), cur = stream.current();
                    return /\btag\b/.test(style) ? />$/.test(cur) ? cx.state.context ? cx.depth = 0 : state.context = state.context.prev : /^</.test(cur) && (cx.depth = 1) : !style && (stop = cur.indexOf("{")) > -1 && stream.backUp(cur.length - stop), 
                    style;
                }
                function jsToken(stream, state, cx) {
                    if ("<" == stream.peek() && jsMode.expressionAllowed(stream, cx.state)) return jsMode.skipExpression(cx.state), 
                    state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "", "")), xmlMode, 0, state.context), 
                    null;
                    var style = jsMode.token(stream, cx.state);
                    if (!style && null != cx.depth) {
                        var cur = stream.current();
                        "{" == cur ? cx.depth++ : "}" == cur && 0 == --cx.depth && (state.context = state.context.prev);
                    }
                    return style;
                }
                var xmlMode = CodeMirror.getMode(config, {
                    name: "xml",
                    allowMissing: !0,
                    multilineTagIndentPastTag: !1,
                    allowMissingTagName: !0
                }), jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript");
                return {
                    startState: function() {
                        return {
                            context: new Context(CodeMirror.startState(jsMode), jsMode)
                        };
                    },
                    copyState: function(state) {
                        return {
                            context: copyContext(state.context)
                        };
                    },
                    token: token,
                    indent: function(state, textAfter, fullLine) {
                        return state.context.mode.indent(state.context.state, textAfter, fullLine);
                    },
                    innerMode: function(state) {
                        return state.context;
                    }
                };
            }, "xml", "javascript"), CodeMirror.defineMIME("text/jsx", "jsx"), CodeMirror.defineMIME("text/typescript-jsx", {
                name: "jsx",
                base: {
                    name: "javascript",
                    typescript: !0
                }
            });
        });
    }, /* 142 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: https://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(131));
        }(function(CodeMirror) {
            "use strict";
            var htmlConfig = {
                autoSelfClosers: {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    command: !0,
                    embed: !0,
                    frame: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0,
                    menuitem: !0
                },
                implicitlyClosed: {
                    dd: !0,
                    li: !0,
                    optgroup: !0,
                    option: !0,
                    p: !0,
                    rp: !0,
                    rt: !0,
                    tbody: !0,
                    td: !0,
                    tfoot: !0,
                    th: !0,
                    tr: !0
                },
                contextGrabbers: {
                    dd: {
                        dd: !0,
                        dt: !0
                    },
                    dt: {
                        dd: !0,
                        dt: !0
                    },
                    li: {
                        li: !0
                    },
                    option: {
                        option: !0,
                        optgroup: !0
                    },
                    optgroup: {
                        optgroup: !0
                    },
                    p: {
                        address: !0,
                        article: !0,
                        aside: !0,
                        blockquote: !0,
                        dir: !0,
                        div: !0,
                        dl: !0,
                        fieldset: !0,
                        footer: !0,
                        form: !0,
                        h1: !0,
                        h2: !0,
                        h3: !0,
                        h4: !0,
                        h5: !0,
                        h6: !0,
                        header: !0,
                        hgroup: !0,
                        hr: !0,
                        menu: !0,
                        nav: !0,
                        ol: !0,
                        p: !0,
                        pre: !0,
                        section: !0,
                        table: !0,
                        ul: !0
                    },
                    rp: {
                        rp: !0,
                        rt: !0
                    },
                    rt: {
                        rp: !0,
                        rt: !0
                    },
                    tbody: {
                        tbody: !0,
                        tfoot: !0
                    },
                    td: {
                        td: !0,
                        th: !0
                    },
                    tfoot: {
                        tbody: !0
                    },
                    th: {
                        td: !0,
                        th: !0
                    },
                    thead: {
                        tbody: !0,
                        tfoot: !0
                    },
                    tr: {
                        tr: !0
                    }
                },
                doNotIndent: {
                    pre: !0
                },
                allowUnquoted: !0,
                allowMissing: !0,
                caseFold: !0
            }, xmlConfig = {
                autoSelfClosers: {},
                implicitlyClosed: {},
                contextGrabbers: {},
                doNotIndent: {},
                allowUnquoted: !1,
                allowMissing: !1,
                allowMissingTagName: !1,
                caseFold: !1
            };
            CodeMirror.defineMode("xml", function(editorConf, config_) {
                function inText(stream, state) {
                    function chain(parser) {
                        return state.tokenize = parser, parser(stream, state);
                    }
                    var ch = stream.next();
                    if ("<" == ch) return stream.eat("!") ? stream.eat("[") ? stream.match("CDATA[") ? chain(inBlock("atom", "]]>")) : null : stream.match("--") ? chain(inBlock("comment", "-->")) : stream.match("DOCTYPE", !0, !0) ? (stream.eatWhile(/[\w\._\-]/), 
                    chain(doctype(1))) : null : stream.eat("?") ? (stream.eatWhile(/[\w\._\-]/), state.tokenize = inBlock("meta", "?>"), 
                    "meta") : (type = stream.eat("/") ? "closeTag" : "openTag", state.tokenize = inTag, 
                    "tag bracket");
                    if ("&" == ch) {
                        var ok;
                        return ok = stream.eat("#") ? stream.eat("x") ? stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";") : stream.eatWhile(/[\d]/) && stream.eat(";") : stream.eatWhile(/[\w\.\-:]/) && stream.eat(";"), 
                        ok ? "atom" : "error";
                    }
                    return stream.eatWhile(/[^&<]/), null;
                }
                function inTag(stream, state) {
                    var ch = stream.next();
                    if (">" == ch || "/" == ch && stream.eat(">")) return state.tokenize = inText, type = ">" == ch ? "endTag" : "selfcloseTag", 
                    "tag bracket";
                    if ("=" == ch) return type = "equals", null;
                    if ("<" == ch) {
                        state.tokenize = inText, state.state = baseState, state.tagName = state.tagStart = null;
                        var next = state.tokenize(stream, state);
                        return next ? next + " tag error" : "tag error";
                    }
                    return /[\'\"]/.test(ch) ? (state.tokenize = inAttribute(ch), state.stringStartCol = stream.column(), 
                    state.tokenize(stream, state)) : (stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), 
                    "word");
                }
                function inAttribute(quote) {
                    var closure = function(stream, state) {
                        for (;!stream.eol(); ) if (stream.next() == quote) {
                            state.tokenize = inTag;
                            break;
                        }
                        return "string";
                    };
                    return closure.isInAttribute = !0, closure;
                }
                function inBlock(style, terminator) {
                    return function(stream, state) {
                        for (;!stream.eol(); ) {
                            if (stream.match(terminator)) {
                                state.tokenize = inText;
                                break;
                            }
                            stream.next();
                        }
                        return style;
                    };
                }
                function doctype(depth) {
                    return function(stream, state) {
                        for (var ch; null != (ch = stream.next()); ) {
                            if ("<" == ch) return state.tokenize = doctype(depth + 1), state.tokenize(stream, state);
                            if (">" == ch) {
                                if (1 == depth) {
                                    state.tokenize = inText;
                                    break;
                                }
                                return state.tokenize = doctype(depth - 1), state.tokenize(stream, state);
                            }
                        }
                        return "meta";
                    };
                }
                function Context(state, tagName, startOfLine) {
                    this.prev = state.context, this.tagName = tagName, this.indent = state.indented, 
                    this.startOfLine = startOfLine, (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) && (this.noIndent = !0);
                }
                function popContext(state) {
                    state.context && (state.context = state.context.prev);
                }
                function maybePopContext(state, nextTagName) {
                    for (var parentTagName; ;) {
                        if (!state.context) return;
                        if (parentTagName = state.context.tagName, !config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) return;
                        popContext(state);
                    }
                }
                function baseState(type, stream, state) {
                    return "openTag" == type ? (state.tagStart = stream.column(), tagNameState) : "closeTag" == type ? closeTagNameState : baseState;
                }
                function tagNameState(type, stream, state) {
                    return "word" == type ? (state.tagName = stream.current(), setStyle = "tag", attrState) : config.allowMissingTagName && "endTag" == type ? (setStyle = "tag bracket", 
                    attrState(type, stream, state)) : (setStyle = "error", tagNameState);
                }
                function closeTagNameState(type, stream, state) {
                    if ("word" == type) {
                        var tagName = stream.current();
                        return state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName) && popContext(state), 
                        state.context && state.context.tagName == tagName || config.matchClosing === !1 ? (setStyle = "tag", 
                        closeState) : (setStyle = "tag error", closeStateErr);
                    }
                    return config.allowMissingTagName && "endTag" == type ? (setStyle = "tag bracket", 
                    closeState(type, stream, state)) : (setStyle = "error", closeStateErr);
                }
                function closeState(type, _stream, state) {
                    return "endTag" != type ? (setStyle = "error", closeState) : (popContext(state), 
                    baseState);
                }
                function closeStateErr(type, stream, state) {
                    return setStyle = "error", closeState(type, stream, state);
                }
                function attrState(type, _stream, state) {
                    if ("word" == type) return setStyle = "attribute", attrEqState;
                    if ("endTag" == type || "selfcloseTag" == type) {
                        var tagName = state.tagName, tagStart = state.tagStart;
                        return state.tagName = state.tagStart = null, "selfcloseTag" == type || config.autoSelfClosers.hasOwnProperty(tagName) ? maybePopContext(state, tagName) : (maybePopContext(state, tagName), 
                        state.context = new Context(state, tagName, tagStart == state.indented)), baseState;
                    }
                    return setStyle = "error", attrState;
                }
                function attrEqState(type, stream, state) {
                    return "equals" == type ? attrValueState : (config.allowMissing || (setStyle = "error"), 
                    attrState(type, stream, state));
                }
                function attrValueState(type, stream, state) {
                    return "string" == type ? attrContinuedState : "word" == type && config.allowUnquoted ? (setStyle = "string", 
                    attrState) : (setStyle = "error", attrState(type, stream, state));
                }
                function attrContinuedState(type, stream, state) {
                    return "string" == type ? attrContinuedState : attrState(type, stream, state);
                }
                var indentUnit = editorConf.indentUnit, config = {}, defaults = config_.htmlMode ? htmlConfig : xmlConfig;
                for (var prop in defaults) config[prop] = defaults[prop];
                for (var prop in config_) config[prop] = config_[prop];
                // Return variables for tokenizers
                var type, setStyle;
                return inText.isInText = !0, {
                    startState: function(baseIndent) {
                        var state = {
                            tokenize: inText,
                            state: baseState,
                            indented: baseIndent || 0,
                            tagName: null,
                            tagStart: null,
                            context: null
                        };
                        return null != baseIndent && (state.baseIndent = baseIndent), state;
                    },
                    token: function(stream, state) {
                        if (!state.tagName && stream.sol() && (state.indented = stream.indentation()), stream.eatSpace()) return null;
                        type = null;
                        var style = state.tokenize(stream, state);
                        return (style || type) && "comment" != style && (setStyle = null, state.state = state.state(type || style, stream, state), 
                        setStyle && (style = "error" == setStyle ? style + " error" : setStyle)), style;
                    },
                    indent: function(state, textAfter, fullLine) {
                        var context = state.context;
                        // Indent multi-line strings (e.g. css).
                        if (state.tokenize.isInAttribute) return state.tagStart == state.indented ? state.stringStartCol + 1 : state.indented + indentUnit;
                        if (context && context.noIndent) return CodeMirror.Pass;
                        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
                        // Indent the starts of attribute names.
                        if (state.tagName) return config.multilineTagIndentPastTag !== !1 ? state.tagStart + state.tagName.length + 2 : state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
                        if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
                        var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
                        if (tagAfter && tagAfter[1]) // Closing tag spotted
                        for (;context; ) {
                            if (context.tagName == tagAfter[2]) {
                                context = context.prev;
                                break;
                            }
                            if (!config.implicitlyClosed.hasOwnProperty(context.tagName)) break;
                            context = context.prev;
                        } else if (tagAfter) // Opening tag spotted
                        for (;context; ) {
                            var grabbers = config.contextGrabbers[context.tagName];
                            if (!grabbers || !grabbers.hasOwnProperty(tagAfter[2])) break;
                            context = context.prev;
                        }
                        for (;context && context.prev && !context.startOfLine; ) context = context.prev;
                        return context ? context.indent + indentUnit : state.baseIndent || 0;
                    },
                    electricInput: /<\/[\s\w:]+>$/,
                    blockCommentStart: "<!--",
                    blockCommentEnd: "-->",
                    configuration: config.htmlMode ? "html" : "xml",
                    helperType: config.htmlMode ? "html" : "xml",
                    skipAttribute: function(state) {
                        state.state == attrValueState && (state.state = attrState);
                    },
                    xmlCurrentTag: function(state) {
                        return state.tagName ? {
                            name: state.tagName,
                            close: "closeTag" == state.type
                        } : null;
                    },
                    xmlCurrentContext: function(state) {
                        for (var context = [], cx = state.context; cx; cx = cx.prev) cx.tagName && context.push(cx.tagName);
                        return context.reverse();
                    }
                };
            }), CodeMirror.defineMIME("text/xml", "xml"), CodeMirror.defineMIME("application/xml", "xml"), 
            CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", {
                name: "xml",
                htmlMode: !0
            });
        });
    }, /* 143 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: https://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(131));
        }(function(CodeMirror) {
            "use strict";
            CodeMirror.defineMode("javascript", function(config, parserConfig) {
                function readRegexp(stream) {
                    for (var next, escaped = !1, inSet = !1; null != (next = stream.next()); ) {
                        if (!escaped) {
                            if ("/" == next && !inSet) return;
                            "[" == next ? inSet = !0 : inSet && "]" == next && (inSet = !1);
                        }
                        escaped = !escaped && "\\" == next;
                    }
                }
                function ret(tp, style, cont) {
                    return type = tp, content = cont, style;
                }
                function tokenBase(stream, state) {
                    var ch = stream.next();
                    if ('"' == ch || "'" == ch) return state.tokenize = tokenString(ch), state.tokenize(stream, state);
                    if ("." == ch && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return ret("number", "number");
                    if ("." == ch && stream.match("..")) return ret("spread", "meta");
                    if (/[\[\]{}\(\),;\:\.]/.test(ch)) return ret(ch);
                    if ("=" == ch && stream.eat(">")) return ret("=>", "operator");
                    if ("0" == ch && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return ret("number", "number");
                    if (/\d/.test(ch)) return stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), 
                    ret("number", "number");
                    if ("/" == ch) return stream.eat("*") ? (state.tokenize = tokenComment, tokenComment(stream, state)) : stream.eat("/") ? (stream.skipToEnd(), 
                    ret("comment", "comment")) : expressionAllowed(stream, state, 1) ? (readRegexp(stream), 
                    stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), ret("regexp", "string-2")) : (stream.eat("="), 
                    ret("operator", "operator", stream.current()));
                    if ("`" == ch) return state.tokenize = tokenQuasi, tokenQuasi(stream, state);
                    if ("#" == ch && "!" == stream.peek()) return stream.skipToEnd(), ret("meta", "meta");
                    if ("#" == ch && stream.eatWhile(wordRE)) return ret("variable", "property");
                    if ("<" == ch && stream.match("!--") || "-" == ch && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) return stream.skipToEnd(), 
                    ret("comment", "comment");
                    if (isOperatorChar.test(ch)) return ">" == ch && state.lexical && ">" == state.lexical.type || (stream.eat("=") ? "!" != ch && "=" != ch || stream.eat("=") : /[<>*+\-|&?]/.test(ch) && (stream.eat(ch), 
                    ">" == ch && stream.eat(ch))), "?" == ch && stream.eat(".") ? ret(".") : ret("operator", "operator", stream.current());
                    if (wordRE.test(ch)) {
                        stream.eatWhile(wordRE);
                        var word = stream.current();
                        if ("." != state.lastType) {
                            if (keywords.propertyIsEnumerable(word)) {
                                var kw = keywords[word];
                                return ret(kw.type, kw.style, word);
                            }
                            if ("async" == word && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1)) return ret("async", "keyword", word);
                        }
                        return ret("variable", "variable", word);
                    }
                }
                function tokenString(quote) {
                    return function(stream, state) {
                        var next, escaped = !1;
                        if (jsonldMode && "@" == stream.peek() && stream.match(isJsonldKeyword)) return state.tokenize = tokenBase, 
                        ret("jsonld-keyword", "meta");
                        for (;null != (next = stream.next()) && (next != quote || escaped); ) escaped = !escaped && "\\" == next;
                        return escaped || (state.tokenize = tokenBase), ret("string", "string");
                    };
                }
                function tokenComment(stream, state) {
                    for (var ch, maybeEnd = !1; ch = stream.next(); ) {
                        if ("/" == ch && maybeEnd) {
                            state.tokenize = tokenBase;
                            break;
                        }
                        maybeEnd = "*" == ch;
                    }
                    return ret("comment", "comment");
                }
                function tokenQuasi(stream, state) {
                    for (var next, escaped = !1; null != (next = stream.next()); ) {
                        if (!escaped && ("`" == next || "$" == next && stream.eat("{"))) {
                            state.tokenize = tokenBase;
                            break;
                        }
                        escaped = !escaped && "\\" == next;
                    }
                    return ret("quasi", "string-2", stream.current());
                }
                // This is a crude lookahead trick to try and notice that we're
                // parsing the argument patterns for a fat-arrow function before we
                // actually hit the arrow token. It only works if the arrow is on
                // the same line as the arguments and there's no strange noise
                // (comments) in between. Fallback is to only notice when we hit the
                // arrow, and not declare the arguments as locals for the arrow
                // body.
                function findFatArrow(stream, state) {
                    state.fatArrowAt && (state.fatArrowAt = null);
                    var arrow = stream.string.indexOf("=>", stream.start);
                    if (!(arrow < 0)) {
                        if (isTS) {
                            // Try to skip TypeScript return type declarations after the arguments
                            var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
                            m && (arrow = m.index);
                        }
                        for (var depth = 0, sawSomething = !1, pos = arrow - 1; pos >= 0; --pos) {
                            var ch = stream.string.charAt(pos), bracket = brackets.indexOf(ch);
                            if (bracket >= 0 && bracket < 3) {
                                if (!depth) {
                                    ++pos;
                                    break;
                                }
                                if (0 == --depth) {
                                    "(" == ch && (sawSomething = !0);
                                    break;
                                }
                            } else if (bracket >= 3 && bracket < 6) ++depth; else if (wordRE.test(ch)) sawSomething = !0; else if (/["'\/`]/.test(ch)) for (;;--pos) {
                                if (0 == pos) return;
                                var next = stream.string.charAt(pos - 1);
                                if (next == ch && "\\" != stream.string.charAt(pos - 2)) {
                                    pos--;
                                    break;
                                }
                            } else if (sawSomething && !depth) {
                                ++pos;
                                break;
                            }
                        }
                        sawSomething && !depth && (state.fatArrowAt = pos);
                    }
                }
                function JSLexical(indented, column, type, align, prev, info) {
                    this.indented = indented, this.column = column, this.type = type, this.prev = prev, 
                    this.info = info, null != align && (this.align = align);
                }
                function inScope(state, varname) {
                    for (var v = state.localVars; v; v = v.next) if (v.name == varname) return !0;
                    for (var cx = state.context; cx; cx = cx.prev) for (var v = cx.vars; v; v = v.next) if (v.name == varname) return !0;
                }
                function parseJS(state, style, type, content, stream) {
                    var cc = state.cc;
                    for (// Communicate our context to the combinators.
                    // (Less wasteful than consing up a hundred closures on every call.)
                    cx.state = state, cx.stream = stream, cx.marked = null, cx.cc = cc, cx.style = style, 
                    state.lexical.hasOwnProperty("align") || (state.lexical.align = !0); ;) {
                        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                        if (combinator(type, content)) {
                            for (;cc.length && cc[cc.length - 1].lex; ) cc.pop()();
                            return cx.marked ? cx.marked : "variable" == type && inScope(state, content) ? "variable-2" : style;
                        }
                    }
                }
                function pass() {
                    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
                }
                function cont() {
                    return pass.apply(null, arguments), !0;
                }
                function inList(name, list) {
                    for (var v = list; v; v = v.next) if (v.name == name) return !0;
                    return !1;
                }
                function register(varname) {
                    var state = cx.state;
                    if (cx.marked = "def", state.context) if ("var" == state.lexical.info && state.context && state.context.block) {
                        // FIXME function decls are also not block scoped
                        var newContext = registerVarScoped(varname, state.context);
                        if (null != newContext) return void (state.context = newContext);
                    } else if (!inList(varname, state.localVars)) return void (state.localVars = new Var(varname, state.localVars));
                    // Fall through means this is global
                    parserConfig.globalVars && !inList(varname, state.globalVars) && (state.globalVars = new Var(varname, state.globalVars));
                }
                function registerVarScoped(varname, context) {
                    if (context) {
                        if (context.block) {
                            var inner = registerVarScoped(varname, context.prev);
                            return inner ? inner == context.prev ? context : new Context(inner, context.vars, !0) : null;
                        }
                        return inList(varname, context.vars) ? context : new Context(context.prev, new Var(varname, context.vars), !1);
                    }
                    return null;
                }
                function isModifier(name) {
                    return "public" == name || "private" == name || "protected" == name || "abstract" == name || "readonly" == name;
                }
                // Combinators
                function Context(prev, vars, block) {
                    this.prev = prev, this.vars = vars, this.block = block;
                }
                function Var(name, next) {
                    this.name = name, this.next = next;
                }
                function pushcontext() {
                    cx.state.context = new Context(cx.state.context, cx.state.localVars, !1), cx.state.localVars = defaultVars;
                }
                function pushblockcontext() {
                    cx.state.context = new Context(cx.state.context, cx.state.localVars, !0), cx.state.localVars = null;
                }
                function popcontext() {
                    cx.state.localVars = cx.state.context.vars, cx.state.context = cx.state.context.prev;
                }
                function pushlex(type, info) {
                    var result = function() {
                        var state = cx.state, indent = state.indented;
                        if ("stat" == state.lexical.type) indent = state.lexical.indented; else for (var outer = state.lexical; outer && ")" == outer.type && outer.align; outer = outer.prev) indent = outer.indented;
                        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
                    };
                    return result.lex = !0, result;
                }
                function poplex() {
                    var state = cx.state;
                    state.lexical.prev && (")" == state.lexical.type && (state.indented = state.lexical.indented), 
                    state.lexical = state.lexical.prev);
                }
                function expect(wanted) {
                    function exp(type) {
                        return type == wanted ? cont() : ";" == wanted || "}" == type || ")" == type || "]" == type ? pass() : cont(exp);
                    }
                    return exp;
                }
                function statement(type, value) {
                    return "var" == type ? cont(pushlex("vardef", value), vardef, expect(";"), poplex) : "keyword a" == type ? cont(pushlex("form"), parenExpr, statement, poplex) : "keyword b" == type ? cont(pushlex("form"), statement, poplex) : "keyword d" == type ? cx.stream.match(/^\s*$/, !1) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex) : "debugger" == type ? cont(expect(";")) : "{" == type ? cont(pushlex("}"), pushblockcontext, block, poplex, popcontext) : ";" == type ? cont() : "if" == type ? ("else" == cx.state.lexical.info && cx.state.cc[cx.state.cc.length - 1] == poplex && cx.state.cc.pop()(), 
                    cont(pushlex("form"), parenExpr, statement, poplex, maybeelse)) : "function" == type ? cont(functiondef) : "for" == type ? cont(pushlex("form"), forspec, statement, poplex) : "class" == type || isTS && "interface" == value ? (cx.marked = "keyword", 
                    cont(pushlex("form", "class" == type ? type : value), className, poplex)) : "variable" == type ? isTS && "declare" == value ? (cx.marked = "keyword", 
                    cont(statement)) : isTS && ("module" == value || "enum" == value || "type" == value) && cx.stream.match(/^\s*\w/, !1) ? (cx.marked = "keyword", 
                    "enum" == value ? cont(enumdef) : "type" == value ? cont(typename, expect("operator"), typeexpr, expect(";")) : cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)) : isTS && "namespace" == value ? (cx.marked = "keyword", 
                    cont(pushlex("form"), expression, statement, poplex)) : isTS && "abstract" == value ? (cx.marked = "keyword", 
                    cont(statement)) : cont(pushlex("stat"), maybelabel) : "switch" == type ? cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext) : "case" == type ? cont(expression, expect(":")) : "default" == type ? cont(expect(":")) : "catch" == type ? cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext) : "export" == type ? cont(pushlex("stat"), afterExport, poplex) : "import" == type ? cont(pushlex("stat"), afterImport, poplex) : "async" == type ? cont(statement) : "@" == value ? cont(expression, statement) : pass(pushlex("stat"), expression, expect(";"), poplex);
                }
                function maybeCatchBinding(type) {
                    if ("(" == type) return cont(funarg, expect(")"));
                }
                function expression(type, value) {
                    return expressionInner(type, value, !1);
                }
                function expressionNoComma(type, value) {
                    return expressionInner(type, value, !0);
                }
                function parenExpr(type) {
                    return "(" != type ? pass() : cont(pushlex(")"), maybeexpression, expect(")"), poplex);
                }
                function expressionInner(type, value, noComma) {
                    if (cx.state.fatArrowAt == cx.stream.start) {
                        var body = noComma ? arrowBodyNoComma : arrowBody;
                        if ("(" == type) return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
                        if ("variable" == type) return pass(pushcontext, pattern, expect("=>"), body, popcontext);
                    }
                    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
                    return atomicTypes.hasOwnProperty(type) ? cont(maybeop) : "function" == type ? cont(functiondef, maybeop) : "class" == type || isTS && "interface" == value ? (cx.marked = "keyword", 
                    cont(pushlex("form"), classExpression, poplex)) : "keyword c" == type || "async" == type ? cont(noComma ? expressionNoComma : expression) : "(" == type ? cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop) : "operator" == type || "spread" == type ? cont(noComma ? expressionNoComma : expression) : "[" == type ? cont(pushlex("]"), arrayLiteral, poplex, maybeop) : "{" == type ? contCommasep(objprop, "}", null, maybeop) : "quasi" == type ? pass(quasi, maybeop) : "new" == type ? cont(maybeTarget(noComma)) : "import" == type ? cont(expression) : cont();
                }
                function maybeexpression(type) {
                    return type.match(/[;\}\)\],]/) ? pass() : pass(expression);
                }
                function maybeoperatorComma(type, value) {
                    return "," == type ? cont(maybeexpression) : maybeoperatorNoComma(type, value, !1);
                }
                function maybeoperatorNoComma(type, value, noComma) {
                    var me = 0 == noComma ? maybeoperatorComma : maybeoperatorNoComma, expr = 0 == noComma ? expression : expressionNoComma;
                    return "=>" == type ? cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext) : "operator" == type ? /\+\+|--/.test(value) || isTS && "!" == value ? cont(me) : isTS && "<" == value && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me) : "?" == value ? cont(expression, expect(":"), expr) : cont(expr) : "quasi" == type ? pass(quasi, me) : ";" != type ? "(" == type ? contCommasep(expressionNoComma, ")", "call", me) : "." == type ? cont(property, me) : "[" == type ? cont(pushlex("]"), maybeexpression, expect("]"), poplex, me) : isTS && "as" == value ? (cx.marked = "keyword", 
                    cont(typeexpr, me)) : "regexp" == type ? (cx.state.lastType = cx.marked = "operator", 
                    cx.stream.backUp(cx.stream.pos - cx.stream.start - 1), cont(expr)) : void 0 : void 0;
                }
                function quasi(type, value) {
                    return "quasi" != type ? pass() : "${" != value.slice(value.length - 2) ? cont(quasi) : cont(expression, continueQuasi);
                }
                function continueQuasi(type) {
                    if ("}" == type) return cx.marked = "string-2", cx.state.tokenize = tokenQuasi, 
                    cont(quasi);
                }
                function arrowBody(type) {
                    return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expression);
                }
                function arrowBodyNoComma(type) {
                    return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expressionNoComma);
                }
                function maybeTarget(noComma) {
                    return function(type) {
                        return "." == type ? cont(noComma ? targetNoComma : target) : "variable" == type && isTS ? cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma) : pass(noComma ? expressionNoComma : expression);
                    };
                }
                function target(_, value) {
                    if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorComma);
                }
                function targetNoComma(_, value) {
                    if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorNoComma);
                }
                function maybelabel(type) {
                    return ":" == type ? cont(poplex, statement) : pass(maybeoperatorComma, expect(";"), poplex);
                }
                function property(type) {
                    if ("variable" == type) return cx.marked = "property", cont();
                }
                function objprop(type, value) {
                    if ("async" == type) return cx.marked = "property", cont(objprop);
                    if ("variable" == type || "keyword" == cx.style) {
                        if (cx.marked = "property", "get" == value || "set" == value) return cont(getterSetter);
                        var m;
                        // Work around fat-arrow-detection complication for detecting typescript typed arrow params
                        return isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, !1)) && (cx.state.fatArrowAt = cx.stream.pos + m[0].length), 
                        cont(afterprop);
                    }
                    return "number" == type || "string" == type ? (cx.marked = jsonldMode ? "property" : cx.style + " property", 
                    cont(afterprop)) : "jsonld-keyword" == type ? cont(afterprop) : isTS && isModifier(value) ? (cx.marked = "keyword", 
                    cont(objprop)) : "[" == type ? cont(expression, maybetype, expect("]"), afterprop) : "spread" == type ? cont(expressionNoComma, afterprop) : "*" == value ? (cx.marked = "keyword", 
                    cont(objprop)) : ":" == type ? pass(afterprop) : void 0;
                }
                function getterSetter(type) {
                    return "variable" != type ? pass(afterprop) : (cx.marked = "property", cont(functiondef));
                }
                function afterprop(type) {
                    return ":" == type ? cont(expressionNoComma) : "(" == type ? pass(functiondef) : void 0;
                }
                function commasep(what, end, sep) {
                    function proceed(type, value) {
                        if (sep ? sep.indexOf(type) > -1 : "," == type) {
                            var lex = cx.state.lexical;
                            return "call" == lex.info && (lex.pos = (lex.pos || 0) + 1), cont(function(type, value) {
                                return type == end || value == end ? pass() : pass(what);
                            }, proceed);
                        }
                        return type == end || value == end ? cont() : sep && sep.indexOf(";") > -1 ? pass(what) : cont(expect(end));
                    }
                    return function(type, value) {
                        return type == end || value == end ? cont() : pass(what, proceed);
                    };
                }
                function contCommasep(what, end, info) {
                    for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
                    return cont(pushlex(end, info), commasep(what, end), poplex);
                }
                function block(type) {
                    return "}" == type ? cont() : pass(statement, block);
                }
                function maybetype(type, value) {
                    if (isTS) {
                        if (":" == type) return cont(typeexpr);
                        if ("?" == value) return cont(maybetype);
                    }
                }
                function maybetypeOrIn(type, value) {
                    if (isTS && (":" == type || "in" == value)) return cont(typeexpr);
                }
                function mayberettype(type) {
                    if (isTS && ":" == type) return cx.stream.match(/^\s*\w+\s+is\b/, !1) ? cont(expression, isKW, typeexpr) : cont(typeexpr);
                }
                function isKW(_, value) {
                    if ("is" == value) return cx.marked = "keyword", cont();
                }
                function typeexpr(type, value) {
                    return "keyof" == value || "typeof" == value || "infer" == value ? (cx.marked = "keyword", 
                    cont("typeof" == value ? expressionNoComma : typeexpr)) : "variable" == type || "void" == value ? (cx.marked = "type", 
                    cont(afterType)) : "|" == value || "&" == value ? cont(typeexpr) : "string" == type || "number" == type || "atom" == type ? cont(afterType) : "[" == type ? cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType) : "{" == type ? cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType) : "(" == type ? cont(commasep(typearg, ")"), maybeReturnType, afterType) : "<" == type ? cont(commasep(typeexpr, ">"), typeexpr) : void 0;
                }
                function maybeReturnType(type) {
                    if ("=>" == type) return cont(typeexpr);
                }
                function typeprop(type, value) {
                    return "variable" == type || "keyword" == cx.style ? (cx.marked = "property", cont(typeprop)) : "?" == value || "number" == type || "string" == type ? cont(typeprop) : ":" == type ? cont(typeexpr) : "[" == type ? cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop) : "(" == type ? pass(functiondecl, typeprop) : void 0;
                }
                function typearg(type, value) {
                    return "variable" == type && cx.stream.match(/^\s*[?:]/, !1) || "?" == value ? cont(typearg) : ":" == type ? cont(typeexpr) : "spread" == type ? cont(typearg) : pass(typeexpr);
                }
                function afterType(type, value) {
                    return "<" == value ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType) : "|" == value || "." == type || "&" == value ? cont(typeexpr) : "[" == type ? cont(typeexpr, expect("]"), afterType) : "extends" == value || "implements" == value ? (cx.marked = "keyword", 
                    cont(typeexpr)) : "?" == value ? cont(typeexpr, expect(":"), typeexpr) : void 0;
                }
                function maybeTypeArgs(_, value) {
                    if ("<" == value) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
                }
                function typeparam() {
                    return pass(typeexpr, maybeTypeDefault);
                }
                function maybeTypeDefault(_, value) {
                    if ("=" == value) return cont(typeexpr);
                }
                function vardef(_, value) {
                    return "enum" == value ? (cx.marked = "keyword", cont(enumdef)) : pass(pattern, maybetype, maybeAssign, vardefCont);
                }
                function pattern(type, value) {
                    return isTS && isModifier(value) ? (cx.marked = "keyword", cont(pattern)) : "variable" == type ? (register(value), 
                    cont()) : "spread" == type ? cont(pattern) : "[" == type ? contCommasep(eltpattern, "]") : "{" == type ? contCommasep(proppattern, "}") : void 0;
                }
                function proppattern(type, value) {
                    return "variable" != type || cx.stream.match(/^\s*:/, !1) ? ("variable" == type && (cx.marked = "property"), 
                    "spread" == type ? cont(pattern) : "}" == type ? pass() : "[" == type ? cont(expression, expect("]"), expect(":"), proppattern) : cont(expect(":"), pattern, maybeAssign)) : (register(value), 
                    cont(maybeAssign));
                }
                function eltpattern() {
                    return pass(pattern, maybeAssign);
                }
                function maybeAssign(_type, value) {
                    if ("=" == value) return cont(expressionNoComma);
                }
                function vardefCont(type) {
                    if ("," == type) return cont(vardef);
                }
                function maybeelse(type, value) {
                    if ("keyword b" == type && "else" == value) return cont(pushlex("form", "else"), statement, poplex);
                }
                function forspec(type, value) {
                    return "await" == value ? cont(forspec) : "(" == type ? cont(pushlex(")"), forspec1, poplex) : void 0;
                }
                function forspec1(type) {
                    return "var" == type ? cont(vardef, forspec2) : "variable" == type ? cont(forspec2) : pass(forspec2);
                }
                function forspec2(type, value) {
                    return ")" == type ? cont() : ";" == type ? cont(forspec2) : "in" == value || "of" == value ? (cx.marked = "keyword", 
                    cont(expression, forspec2)) : pass(expression, forspec2);
                }
                function functiondef(type, value) {
                    return "*" == value ? (cx.marked = "keyword", cont(functiondef)) : "variable" == type ? (register(value), 
                    cont(functiondef)) : "(" == type ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext) : isTS && "<" == value ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef) : void 0;
                }
                function functiondecl(type, value) {
                    return "*" == value ? (cx.marked = "keyword", cont(functiondecl)) : "variable" == type ? (register(value), 
                    cont(functiondecl)) : "(" == type ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext) : isTS && "<" == value ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl) : void 0;
                }
                function typename(type, value) {
                    return "keyword" == type || "variable" == type ? (cx.marked = "type", cont(typename)) : "<" == value ? cont(pushlex(">"), commasep(typeparam, ">"), poplex) : void 0;
                }
                function funarg(type, value) {
                    return "@" == value && cont(expression, funarg), "spread" == type ? cont(funarg) : isTS && isModifier(value) ? (cx.marked = "keyword", 
                    cont(funarg)) : isTS && "this" == type ? cont(maybetype, maybeAssign) : pass(pattern, maybetype, maybeAssign);
                }
                function classExpression(type, value) {
                    // Class expressions may have an optional name.
                    // Class expressions may have an optional name.
                    return "variable" == type ? className(type, value) : classNameAfter(type, value);
                }
                function className(type, value) {
                    if ("variable" == type) return register(value), cont(classNameAfter);
                }
                function classNameAfter(type, value) {
                    return "<" == value ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter) : "extends" == value || "implements" == value || isTS && "," == type ? ("implements" == value && (cx.marked = "keyword"), 
                    cont(isTS ? typeexpr : expression, classNameAfter)) : "{" == type ? cont(pushlex("}"), classBody, poplex) : void 0;
                }
                function classBody(type, value) {
                    return "async" == type || "variable" == type && ("static" == value || "get" == value || "set" == value || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (cx.marked = "keyword", 
                    cont(classBody)) : "variable" == type || "keyword" == cx.style ? (cx.marked = "property", 
                    cont(classfield, classBody)) : "number" == type || "string" == type ? cont(classfield, classBody) : "[" == type ? cont(expression, maybetype, expect("]"), classfield, classBody) : "*" == value ? (cx.marked = "keyword", 
                    cont(classBody)) : isTS && "(" == type ? pass(functiondecl, classBody) : ";" == type || "," == type ? cont(classBody) : "}" == type ? cont() : "@" == value ? cont(expression, classBody) : void 0;
                }
                function classfield(type, value) {
                    if ("?" == value) return cont(classfield);
                    if (":" == type) return cont(typeexpr, maybeAssign);
                    if ("=" == value) return cont(expressionNoComma);
                    var context = cx.state.lexical.prev, isInterface = context && "interface" == context.info;
                    return pass(isInterface ? functiondecl : functiondef);
                }
                function afterExport(type, value) {
                    return "*" == value ? (cx.marked = "keyword", cont(maybeFrom, expect(";"))) : "default" == value ? (cx.marked = "keyword", 
                    cont(expression, expect(";"))) : "{" == type ? cont(commasep(exportField, "}"), maybeFrom, expect(";")) : pass(statement);
                }
                function exportField(type, value) {
                    return "as" == value ? (cx.marked = "keyword", cont(expect("variable"))) : "variable" == type ? pass(expressionNoComma, exportField) : void 0;
                }
                function afterImport(type) {
                    return "string" == type ? cont() : "(" == type ? pass(expression) : pass(importSpec, maybeMoreImports, maybeFrom);
                }
                function importSpec(type, value) {
                    return "{" == type ? contCommasep(importSpec, "}") : ("variable" == type && register(value), 
                    "*" == value && (cx.marked = "keyword"), cont(maybeAs));
                }
                function maybeMoreImports(type) {
                    if ("," == type) return cont(importSpec, maybeMoreImports);
                }
                function maybeAs(_type, value) {
                    if ("as" == value) return cx.marked = "keyword", cont(importSpec);
                }
                function maybeFrom(_type, value) {
                    if ("from" == value) return cx.marked = "keyword", cont(expression);
                }
                function arrayLiteral(type) {
                    return "]" == type ? cont() : pass(commasep(expressionNoComma, "]"));
                }
                function enumdef() {
                    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
                }
                function enummember() {
                    return pass(pattern, maybeAssign);
                }
                function isContinuedStatement(state, textAfter) {
                    return "operator" == state.lastType || "," == state.lastType || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
                }
                function expressionAllowed(stream, state, backUp) {
                    return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || "quasi" == state.lastType && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
                }
                var type, content, indentUnit = config.indentUnit, statementIndent = parserConfig.statementIndent, jsonldMode = parserConfig.jsonld, jsonMode = parserConfig.json || jsonldMode, isTS = parserConfig.typescript, wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/, keywords = function() {
                    function kw(type) {
                        return {
                            type: type,
                            style: "keyword"
                        };
                    }
                    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d"), operator = kw("operator"), atom = {
                        type: "atom",
                        style: "atom"
                    };
                    return {
                        if: kw("if"),
                        while: A,
                        with: A,
                        else: B,
                        do: B,
                        try: B,
                        finally: B,
                        return: D,
                        break: D,
                        continue: D,
                        new: kw("new"),
                        delete: C,
                        void: C,
                        throw: C,
                        debugger: kw("debugger"),
                        var: kw("var"),
                        const: kw("var"),
                        let: kw("var"),
                        function: kw("function"),
                        catch: kw("catch"),
                        for: kw("for"),
                        switch: kw("switch"),
                        case: kw("case"),
                        default: kw("default"),
                        in: operator,
                        typeof: operator,
                        instanceof: operator,
                        true: atom,
                        false: atom,
                        null: atom,
                        undefined: atom,
                        NaN: atom,
                        Infinity: atom,
                        this: kw("this"),
                        class: kw("class"),
                        super: kw("atom"),
                        yield: C,
                        export: kw("export"),
                        import: kw("import"),
                        extends: C,
                        await: C
                    };
                }(), isOperatorChar = /[+\-*&%=<>!?|~^@]/, isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/, brackets = "([{}])", atomicTypes = {
                    atom: !0,
                    number: !0,
                    variable: !0,
                    string: !0,
                    regexp: !0,
                    this: !0,
                    "jsonld-keyword": !0
                }, cx = {
                    state: null,
                    column: null,
                    marked: null,
                    cc: null
                }, defaultVars = new Var("this", new Var("arguments", null));
                // Interface
                return popcontext.lex = !0, poplex.lex = !0, {
                    startState: function(basecolumn) {
                        var state = {
                            tokenize: tokenBase,
                            lastType: "sof",
                            cc: [],
                            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", !1),
                            localVars: parserConfig.localVars,
                            context: parserConfig.localVars && new Context(null, null, !1),
                            indented: basecolumn || 0
                        };
                        return parserConfig.globalVars && "object" == typeof parserConfig.globalVars && (state.globalVars = parserConfig.globalVars), 
                        state;
                    },
                    token: function(stream, state) {
                        if (stream.sol() && (state.lexical.hasOwnProperty("align") || (state.lexical.align = !1), 
                        state.indented = stream.indentation(), findFatArrow(stream, state)), state.tokenize != tokenComment && stream.eatSpace()) return null;
                        var style = state.tokenize(stream, state);
                        return "comment" == type ? style : (state.lastType = "operator" != type || "++" != content && "--" != content ? type : "incdec", 
                        parseJS(state, style, type, content, stream));
                    },
                    indent: function(state, textAfter) {
                        if (state.tokenize == tokenComment) return CodeMirror.Pass;
                        if (state.tokenize != tokenBase) return 0;
                        var top, firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
                        // Kludge to prevent 'maybelse' from blocking lexical scope pops
                        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
                            var c = state.cc[i];
                            if (c == poplex) lexical = lexical.prev; else if (c != maybeelse) break;
                        }
                        for (;("stat" == lexical.type || "form" == lexical.type) && ("}" == firstChar || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)); ) lexical = lexical.prev;
                        statementIndent && ")" == lexical.type && "stat" == lexical.prev.type && (lexical = lexical.prev);
                        var type = lexical.type, closing = firstChar == type;
                        return "vardef" == type ? lexical.indented + ("operator" == state.lastType || "," == state.lastType ? lexical.info.length + 1 : 0) : "form" == type && "{" == firstChar ? lexical.indented : "form" == type ? lexical.indented + indentUnit : "stat" == type ? lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0) : "switch" != lexical.info || closing || 0 == parserConfig.doubleIndentSwitch ? lexical.align ? lexical.column + (closing ? 0 : 1) : lexical.indented + (closing ? 0 : indentUnit) : lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
                    },
                    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
                    blockCommentStart: jsonMode ? null : "/*",
                    blockCommentEnd: jsonMode ? null : "*/",
                    blockCommentContinue: jsonMode ? null : " * ",
                    lineComment: jsonMode ? null : "//",
                    fold: "brace",
                    closeBrackets: "()[]{}''\"\"``",
                    helperType: jsonMode ? "json" : "javascript",
                    jsonldMode: jsonldMode,
                    jsonMode: jsonMode,
                    expressionAllowed: expressionAllowed,
                    skipExpression: function(state) {
                        var top = state.cc[state.cc.length - 1];
                        top != expression && top != expressionNoComma || state.cc.pop();
                    }
                };
            }), CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/), CodeMirror.defineMIME("text/javascript", "javascript"), 
            CodeMirror.defineMIME("text/ecmascript", "javascript"), CodeMirror.defineMIME("application/javascript", "javascript"), 
            CodeMirror.defineMIME("application/x-javascript", "javascript"), CodeMirror.defineMIME("application/ecmascript", "javascript"), 
            CodeMirror.defineMIME("application/json", {
                name: "javascript",
                json: !0
            }), CodeMirror.defineMIME("application/x-json", {
                name: "javascript",
                json: !0
            }), CodeMirror.defineMIME("application/ld+json", {
                name: "javascript",
                jsonld: !0
            }), CodeMirror.defineMIME("text/typescript", {
                name: "javascript",
                typescript: !0
            }), CodeMirror.defineMIME("application/typescript", {
                name: "javascript",
                typescript: !0
            });
        });
    }, /* 144 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  height: 100%;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n\n  h1 {\n    paddingRight: 9rem;\n  }\n" ], [ "\n  height: 100%;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n\n  h1 {\n    paddingRight: 9rem;\n  }\n" ]), _styledComponents = __webpack_require__(132), _styledComponents2 = _interopRequireDefault(_styledComponents), _presenterSlideStyle = __webpack_require__(145), _presenterSlideStyle2 = _interopRequireDefault(_presenterSlideStyle);
        exports.default = _styledComponents2.default.div(_templateObject, _presenterSlideStyle2.default);
    }, /* 145 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(props) {
            return props.theme.isPresenterMode && "\n  outline: 0.25rem solid #37F;\n  outline-offset: -0.25rem;\n\n  &::before {\n    content: 'presenter';\n    position: fixed;\n    top: 0;\n    left: 0;\n    background-color: #36F;\n    padding: 0.25rem;\n    color: #fff;\n    font-size: 0.65rem;\n  }\n";
        };
    }, /* 146 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 1rem;\n  right: 7rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 6.5rem;\n  }\n" ], [ "\n  position: absolute;\n  top: 1rem;\n  right: 7rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 6.5rem;\n  }\n" ]), _templateObject2 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, .5);\n" ], [ "\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, .5);\n" ]), _templateObject3 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: rgba(255, 255, 255, .1);\n  padding: 1rem;\n  border-radius: 0.5rem;\n  z-index: 2;\n\n  .VirtualizedSelect {\n    width: 250px;\n    max-width: 100%;\n  }\n" ], [ "\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: rgba(255, 255, 255, .1);\n  padding: 1rem;\n  border-radius: 0.5rem;\n  z-index: 2;\n\n  .VirtualizedSelect {\n    width: 250px;\n    max-width: 100%;\n  }\n" ]), _templateObject4 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n" ], [ "\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n" ]), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _reactVirtualizedSelect = (_interopRequireDefault(_propTypes), 
        __webpack_require__(147)), _reactVirtualizedSelect2 = _interopRequireDefault(_reactVirtualizedSelect), _reactDom = __webpack_require__(120), _styledComponents = __webpack_require__(132), _styledComponents2 = _interopRequireDefault(_styledComponents), _IconButton = __webpack_require__(203), _IconButton2 = _interopRequireDefault(_IconButton), _Icons = __webpack_require__(204), _PropTypes = __webpack_require__(206), _reactSelectStyles = __webpack_require__(207), _reactSelectStyles2 = _interopRequireDefault(_reactSelectStyles), ButtonGroup = _styledComponents2.default.div(_templateObject), Overlay = _styledComponents2.default.div(_templateObject2), SelectWrapper = _styledComponents2.default.div(_templateObject3), Row = _styledComponents2.default.div(_templateObject4), NavigateToSlide = function(_Component) {
            function NavigateToSlide(props, context) {
                (0, _classCallCheck3.default)(this, NavigateToSlide);
                var _this = (0, _possibleConstructorReturn3.default)(this, (NavigateToSlide.__proto__ || (0, 
                _getPrototypeOf2.default)(NavigateToSlide)).call(this, props, context));
                return _this.state = {
                    active: !1
                }, _this._onChange = _this._onChange.bind(_this), _this._onClick = _this._onClick.bind(_this), 
                _this._onKeyDown = _this._onKeyDown.bind(_this), _this._optionRenderer = _this._optionRenderer.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(NavigateToSlide, _Component), (0, _createClass3.default)(NavigateToSlide, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("click", this._onClick);
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("click", this._onClick);
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, slideIndex = this.context.slideIndex, options = this.props.options, active = this.state.active;
                    return active ? _react2.default.createElement(_react.Fragment, null, _react2.default.createElement(_reactSelectStyles2.default, null), _react2.default.createElement(Overlay, null, _react2.default.createElement(SelectWrapper, null, _react2.default.createElement(_reactVirtualizedSelect2.default, {
                        autofocus: !0,
                        className: "VirtualizedSelect",
                        clearable: !1,
                        options: options,
                        onChange: this._onChange,
                        onInputKeyDown: this._onKeyDown,
                        optionHeight: 35,
                        optionRenderer: this._optionRenderer,
                        ref: function(_ref) {
                            _this2._select = _ref;
                        },
                        value: slideIndex
                    })))) : options.length ? _react2.default.createElement(ButtonGroup, null, _react2.default.createElement(_IconButton2.default, {
                        onClick: function() {
                            return _this2.setState({
                                active: !0
                            });
                        }
                    }, _react2.default.createElement(_Icons.IconMore, null))) : null;
                }
            }, {
                key: "_onChange",
                value: function(option) {
                    var slideIndex = option.value, presentation = this.context.presentation;
                    this.setState({
                        active: !1
                    }), presentation.goToSlide({
                        slideIndex: slideIndex
                    });
                }
            }, {
                key: "_onClick",
                value: function(event) {
                    var active = this.state.active;
                    if (active) {
                        var select = (0, _reactDom.findDOMNode)(this._select);
                        select === event.target || select.contains(event.target) || this.setState({
                            active: !1
                        });
                    }
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    switch (event.key) {
                      case "Escape":
                        this.setState({
                            active: !1
                        });
                    }
                }
            }, {
                key: "_optionRenderer",
                value: function(_ref2) {
                    var focusedOption = _ref2.focusedOption, focusOption = _ref2.focusOption, key = _ref2.key, labelKey = _ref2.labelKey, option = _ref2.option, selectValue = _ref2.selectValue, style = _ref2.style, classNames = [ "VirtualizedSelectOption" ];
                    option === focusedOption && classNames.push("VirtualizedSelectFocusedOption"), option.disabled && classNames.push("VirtualizedSelectOptionHeader");
                    var text = option[labelKey], events = option.disabled ? {} : {
                        onClick: function() {
                            return selectValue(option);
                        },
                        onMouseOver: function() {
                            return focusOption(option);
                        }
                    };
                    return _react2.default.createElement("div", (0, _extends3.default)({
                        className: classNames.join(" "),
                        key: key,
                        style: style,
                        title: text
                    }, events), _react2.default.createElement(Row, null, text));
                }
            } ]), NavigateToSlide;
        }(_react.Component);
        NavigateToSlide.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = NavigateToSlide;
    }, /* 147 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _VirtualizedSelect = __webpack_require__(148), _VirtualizedSelect2 = _interopRequireDefault(_VirtualizedSelect);
        exports.default = _VirtualizedSelect2.default;
    }, /* 148 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _VirtualizedSelect = __webpack_require__(149), _VirtualizedSelect2 = _interopRequireDefault(_VirtualizedSelect);
        exports.default = _VirtualizedSelect2.default;
    }, /* 149 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _reactSelect = __webpack_require__(150), _reactSelect2 = _interopRequireDefault(_reactSelect), _AutoSizer = __webpack_require__(165), _AutoSizer2 = _interopRequireDefault(_AutoSizer), _List = __webpack_require__(179), _List2 = _interopRequireDefault(_List), VirtualizedSelect = function(_Component) {
            function VirtualizedSelect(props, context) {
                _classCallCheck(this, VirtualizedSelect);
                var _this = _possibleConstructorReturn(this, (VirtualizedSelect.__proto__ || Object.getPrototypeOf(VirtualizedSelect)).call(this, props, context));
                return _this._renderMenu = _this._renderMenu.bind(_this), _this._optionRenderer = _this._optionRenderer.bind(_this), 
                _this._setListRef = _this._setListRef.bind(_this), _this._setSelectRef = _this._setSelectRef.bind(_this), 
                _this;
            }
            /** See List#recomputeRowHeights */
            return _inherits(VirtualizedSelect, _Component), _createClass(VirtualizedSelect, [ {
                key: "recomputeOptionHeights",
                value: function() {
                    var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    this._listRef && this._listRef.recomputeRowHeights(index);
                }
            }, {
                key: "focus",
                value: function() {
                    if (this._selectRef) return this._selectRef.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var SelectComponent = this._getSelectComponent();
                    return _react2.default.createElement(SelectComponent, _extends({}, this.props, {
                        ref: this._setSelectRef,
                        menuRenderer: this._renderMenu,
                        menuStyle: {
                            overflow: "hidden"
                        }
                    }));
                }
            }, {
                key: "_renderMenu",
                value: function(_ref) {
                    // react-select 1.0.0-rc2 passes duplicate `onSelect` and `selectValue` props to `menuRenderer`
                    // The `Creatable` HOC only overrides `onSelect` which breaks an edge-case
                    // In order to support creating items via clicking on the placeholder option,
                    // We need to ensure that the specified `onSelect` handle is the one we use.
                    // See issue #33
                    function wrappedRowRenderer(_ref2) {
                        var index = _ref2.index, key = _ref2.key, style = _ref2.style, option = options[index];
                        return innerRowRenderer({
                            focusedOption: focusedOption,
                            focusedOptionIndex: focusedOptionIndex,
                            focusOption: focusOption,
                            key: key,
                            labelKey: labelKey,
                            onSelect: onSelect,
                            option: option,
                            optionIndex: index,
                            options: options,
                            selectValue: onSelect,
                            style: style,
                            valueArray: valueArray,
                            valueKey: valueKey
                        });
                    }
                    var _this2 = this, focusedOption = _ref.focusedOption, focusOption = _ref.focusOption, labelKey = _ref.labelKey, onSelect = _ref.onSelect, options = _ref.options, valueArray = (_ref.selectValue, 
                    _ref.valueArray), valueKey = _ref.valueKey, _props = this.props, listProps = _props.listProps, optionRenderer = _props.optionRenderer, focusedOptionIndex = options.indexOf(focusedOption), height = this._calculateListHeight({
                        options: options
                    }), innerRowRenderer = optionRenderer || this._optionRenderer;
                    return _react2.default.createElement(_AutoSizer2.default, {
                        disableHeight: !0
                    }, function(_ref3) {
                        var width = _ref3.width;
                        return _react2.default.createElement(_List2.default, _extends({
                            className: "VirtualSelectGrid",
                            height: height,
                            ref: _this2._setListRef,
                            rowCount: options.length,
                            rowHeight: function(_ref4) {
                                var index = _ref4.index;
                                return _this2._getOptionHeight({
                                    option: options[index]
                                });
                            },
                            rowRenderer: wrappedRowRenderer,
                            scrollToIndex: focusedOptionIndex,
                            width: width
                        }, listProps));
                    });
                }
            }, {
                key: "_calculateListHeight",
                value: function(_ref5) {
                    for (var options = _ref5.options, maxHeight = this.props.maxHeight, height = 0, optionIndex = 0; optionIndex < options.length; optionIndex++) {
                        var option = options[optionIndex];
                        if (height += this._getOptionHeight({
                            option: option
                        }), height > maxHeight) return maxHeight;
                    }
                    return height;
                }
            }, {
                key: "_getOptionHeight",
                value: function(_ref6) {
                    var option = _ref6.option, optionHeight = this.props.optionHeight;
                    return optionHeight instanceof Function ? optionHeight({
                        option: option
                    }) : optionHeight;
                }
            }, {
                key: "_getSelectComponent",
                value: function() {
                    var _props2 = this.props, async = _props2.async, selectComponent = _props2.selectComponent;
                    return selectComponent ? selectComponent : async ? _reactSelect2.default.Async : _reactSelect2.default;
                }
            }, {
                key: "_optionRenderer",
                value: function(_ref7) {
                    var focusedOption = _ref7.focusedOption, focusOption = _ref7.focusOption, key = _ref7.key, labelKey = _ref7.labelKey, option = _ref7.option, selectValue = _ref7.selectValue, style = _ref7.style, valueArray = _ref7.valueArray, className = [ "VirtualizedSelectOption" ];
                    option === focusedOption && className.push("VirtualizedSelectFocusedOption"), option.disabled && className.push("VirtualizedSelectDisabledOption"), 
                    valueArray && valueArray.indexOf(option) >= 0 && className.push("VirtualizedSelectSelectedOption"), 
                    option.className && className.push(option.className);
                    var events = option.disabled ? {} : {
                        onClick: function() {
                            return selectValue(option);
                        },
                        onMouseEnter: function() {
                            return focusOption(option);
                        }
                    };
                    return _react2.default.createElement("div", _extends({
                        className: className.join(" "),
                        key: key,
                        style: style,
                        title: option.title
                    }, events), option[labelKey]);
                }
            }, {
                key: "_setListRef",
                value: function(ref) {
                    this._listRef = ref;
                }
            }, {
                key: "_setSelectRef",
                value: function(ref) {
                    this._selectRef = ref;
                }
            } ]), VirtualizedSelect;
        }(_react.Component);
        VirtualizedSelect.propTypes = {
            async: _propTypes2.default.bool,
            listProps: _propTypes2.default.object,
            maxHeight: _propTypes2.default.number,
            optionHeight: _propTypes2.default.oneOfType([ _propTypes2.default.number, _propTypes2.default.func ]),
            optionRenderer: _propTypes2.default.func,
            selectComponent: _propTypes2.default.func
        }, VirtualizedSelect.defaultProps = {
            async: !1,
            maxHeight: 200,
            optionHeight: 35
        }, exports.default = VirtualizedSelect;
    }, /* 150 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.defaultFilterOptions = exports.defaultClearRenderer = exports.defaultArrowRenderer = exports.defaultMenuRenderer = exports.Option = exports.Value = exports.Creatable = exports.AsyncCreatable = exports.Async = void 0;
        var _Select = __webpack_require__(151), _Select2 = _interopRequireDefault(_Select), _Async = __webpack_require__(162), _Async2 = _interopRequireDefault(_Async), _AsyncCreatable = __webpack_require__(163), _AsyncCreatable2 = _interopRequireDefault(_AsyncCreatable), _Creatable = __webpack_require__(164), _Creatable2 = _interopRequireDefault(_Creatable), _Value = __webpack_require__(161), _Value2 = _interopRequireDefault(_Value), _Option = __webpack_require__(159), _Option2 = _interopRequireDefault(_Option), _defaultMenuRenderer = __webpack_require__(158), _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer), _defaultArrowRenderer = __webpack_require__(153), _defaultArrowRenderer2 = _interopRequireDefault(_defaultArrowRenderer), _defaultClearRenderer = __webpack_require__(154), _defaultClearRenderer2 = _interopRequireDefault(_defaultClearRenderer), _defaultFilterOptions = __webpack_require__(155), _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions);
        _Select2.default.Async = _Async2.default, _Select2.default.AsyncCreatable = _AsyncCreatable2.default, 
        _Select2.default.Creatable = _Creatable2.default, _Select2.default.Value = _Value2.default, 
        _Select2.default.Option = _Option2.default, exports.default = _Select2.default, 
        exports.Async = _Async2.default, exports.AsyncCreatable = _AsyncCreatable2.default, 
        exports.Creatable = _Creatable2.default, exports.Value = _Value2.default, exports.Option = _Option2.default, 
        exports.defaultMenuRenderer = _defaultMenuRenderer2.default, exports.defaultArrowRenderer = _defaultArrowRenderer2.default, 
        exports.defaultClearRenderer = _defaultClearRenderer2.default, exports.defaultFilterOptions = _defaultFilterOptions2.default;
    }, /* 151 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _reactInputAutosize = __webpack_require__(152), _reactInputAutosize2 = _interopRequireDefault(_reactInputAutosize), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _reactDom = __webpack_require__(120), _defaultArrowRenderer = __webpack_require__(153), _defaultArrowRenderer2 = _interopRequireDefault(_defaultArrowRenderer), _defaultClearRenderer = __webpack_require__(154), _defaultClearRenderer2 = _interopRequireDefault(_defaultClearRenderer), _defaultFilterOptions = __webpack_require__(155), _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions), _defaultMenuRenderer = __webpack_require__(158), _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer), _Option = __webpack_require__(159), _Option2 = _interopRequireDefault(_Option), _Value = __webpack_require__(161), _Value2 = _interopRequireDefault(_Value), stringifyValue = function(value) {
            return "string" == typeof value ? value : null !== value && JSON.stringify(value) || "";
        }, stringOrNode = _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.node ]), stringOrNumber = _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.number ]), instanceId = 1, shouldShowValue = function(state, props) {
            var inputValue = state.inputValue, isPseudoFocused = state.isPseudoFocused, isFocused = state.isFocused, onSelectResetsInput = props.onSelectResetsInput;
            return !inputValue || !onSelectResetsInput && !(!isFocused && isPseudoFocused || isFocused && !isPseudoFocused);
        }, shouldShowPlaceholder = function(state, props, isOpen) {
            var inputValue = state.inputValue, isPseudoFocused = state.isPseudoFocused, isFocused = state.isFocused, onSelectResetsInput = props.onSelectResetsInput;
            return !inputValue || !onSelectResetsInput && !isOpen && !isPseudoFocused && !isFocused;
        }, expandValue = function(value, props) {
            var valueType = "undefined" == typeof value ? "undefined" : _typeof(value);
            if ("string" !== valueType && "number" !== valueType && "boolean" !== valueType) return value;
            var options = props.options, valueKey = props.valueKey;
            if (options) for (var i = 0; i < options.length; i++) if (String(options[i][valueKey]) === String(value)) return options[i];
        }, handleRequired = function(value, multi) {
            return !value || (multi ? 0 === value.length : 0 === Object.keys(value).length);
        }, Select = function(_React$Component) {
            function Select(props) {
                _classCallCheck(this, Select);
                var _this = _possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, props));
                return [ "clearValue", "focusOption", "getOptionLabel", "handleInputBlur", "handleInputChange", "handleInputFocus", "handleInputValueChange", "handleKeyDown", "handleMenuScroll", "handleMouseDown", "handleMouseDownOnArrow", "handleMouseDownOnMenu", "handleTouchEnd", "handleTouchEndClearValue", "handleTouchMove", "handleTouchOutside", "handleTouchStart", "handleValueClick", "onOptionRef", "removeValue", "selectValue" ].forEach(function(fn) {
                    return _this[fn] = _this[fn].bind(_this);
                }), _this.state = {
                    inputValue: "",
                    isFocused: !1,
                    isOpen: !1,
                    isPseudoFocused: !1,
                    required: !1
                }, _this;
            }
            return _inherits(Select, _React$Component), _createClass(Select, [ {
                key: "componentWillMount",
                value: function() {
                    this._instancePrefix = "react-select-" + (this.props.instanceId || ++instanceId) + "-";
                    var valueArray = this.getValueArray(this.props.value);
                    this.props.required && this.setState({
                        required: handleRequired(valueArray[0], this.props.multi)
                    });
                }
            }, {
                key: "componentDidMount",
                value: function() {
                    "undefined" != typeof this.props.autofocus && "undefined" != typeof console && console.warn("Warning: The autofocus prop has changed to autoFocus, support will be removed after react-select@1.0"), 
                    (this.props.autoFocus || this.props.autofocus) && this.focus();
                }
            }, {
                key: "componentWillReceiveProps",
                value: function(nextProps) {
                    var valueArray = this.getValueArray(nextProps.value, nextProps);
                    nextProps.required ? this.setState({
                        required: handleRequired(valueArray[0], nextProps.multi)
                    }) : this.props.required && // Used to be required but it's not any more
                    this.setState({
                        required: !1
                    }), this.state.inputValue && this.props.value !== nextProps.value && nextProps.onSelectResetsInput && this.setState({
                        inputValue: this.handleInputValueChange("")
                    });
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps, prevState) {
                    // focus to the selected option
                    if (this.menu && this.focused && this.state.isOpen && !this.hasScrolledToOption) {
                        var focusedOptionNode = (0, _reactDom.findDOMNode)(this.focused), menuNode = (0, 
                        _reactDom.findDOMNode)(this.menu), scrollTop = menuNode.scrollTop, scrollBottom = scrollTop + menuNode.offsetHeight, optionTop = focusedOptionNode.offsetTop, optionBottom = optionTop + focusedOptionNode.offsetHeight;
                        (scrollTop > optionTop || scrollBottom < optionBottom) && (menuNode.scrollTop = focusedOptionNode.offsetTop), 
                        // We still set hasScrolledToOption to true even if we didn't
                        // actually need to scroll, as we've still confirmed that the
                        // option is in view.
                        this.hasScrolledToOption = !0;
                    } else this.state.isOpen || (this.hasScrolledToOption = !1);
                    if (this._scrollToFocusedOptionOnUpdate && this.focused && this.menu) {
                        this._scrollToFocusedOptionOnUpdate = !1;
                        var focusedDOM = (0, _reactDom.findDOMNode)(this.focused), menuDOM = (0, _reactDom.findDOMNode)(this.menu), focusedRect = focusedDOM.getBoundingClientRect(), menuRect = menuDOM.getBoundingClientRect();
                        focusedRect.bottom > menuRect.bottom ? menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight : focusedRect.top < menuRect.top && (menuDOM.scrollTop = focusedDOM.offsetTop);
                    }
                    if (this.props.scrollMenuIntoView && this.menuContainer) {
                        var menuContainerRect = this.menuContainer.getBoundingClientRect();
                        window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer && window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);
                    }
                    if (prevProps.disabled !== this.props.disabled && (this.setState({
                        isFocused: !1
                    }), // eslint-disable-line react/no-did-update-set-state
                    this.closeMenu()), prevState.isOpen !== this.state.isOpen) {
                        this.toggleTouchOutsideEvent(this.state.isOpen);
                        var handler = this.state.isOpen ? this.props.onOpen : this.props.onClose;
                        handler && handler();
                    }
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this.toggleTouchOutsideEvent(!1);
                }
            }, {
                key: "toggleTouchOutsideEvent",
                value: function(enabled) {
                    var eventTogglerName = enabled ? document.addEventListener ? "addEventListener" : "attachEvent" : document.removeEventListener ? "removeEventListener" : "detachEvent", pref = document.addEventListener ? "" : "on";
                    document[eventTogglerName](pref + "touchstart", this.handleTouchOutside), document[eventTogglerName](pref + "mousedown", this.handleTouchOutside);
                }
            }, {
                key: "handleTouchOutside",
                value: function(event) {
                    // handle touch outside on ios to dismiss menu
                    this.wrapper && !this.wrapper.contains(event.target) && this.closeMenu();
                }
            }, {
                key: "focus",
                value: function() {
                    this.input && this.input.focus();
                }
            }, {
                key: "blurInput",
                value: function() {
                    this.input && this.input.blur();
                }
            }, {
                key: "handleTouchMove",
                value: function() {
                    // Set a flag that the view is being dragged
                    this.dragging = !0;
                }
            }, {
                key: "handleTouchStart",
                value: function() {
                    // Set a flag that the view is not being dragged
                    this.dragging = !1;
                }
            }, {
                key: "handleTouchEnd",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || // Fire the mouse events
                    this.handleMouseDown(event);
                }
            }, {
                key: "handleTouchEndClearValue",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || // Clear the value
                    this.clearValue(event);
                }
            }, {
                key: "handleMouseDown",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, or if the component is disabled, ignore it.
                    if (!(this.props.disabled || "mousedown" === event.type && 0 !== event.button)) {
                        if ("INPUT" === event.target.tagName) return void (this.state.isFocused ? this.state.isOpen || this.setState({
                            isOpen: !0,
                            isPseudoFocused: !1,
                            focusedOption: null
                        }) : (this._openAfterFocus = this.props.openOnClick, this.focus()));
                        // for the non-searchable select, toggle the menu
                        if (// prevent default event handlers
                        event.preventDefault(), !this.props.searchable) // This code means that if a select is searchable, onClick the options menu will not appear, only on subsequent click will it open.
                        return this.focus(), this.setState({
                            isOpen: !this.state.isOpen,
                            focusedOption: null
                        });
                        if (this.state.isFocused) {
                            // On iOS, we can get into a state where we think the input is focused but it isn't really,
                            // since iOS ignores programmatic calls to input.focus() that weren't triggered by a click event.
                            // Call focus() again here to be safe.
                            this.focus();
                            var input = this.input, toOpen = !0;
                            "function" == typeof input.getInput && (// Get the actual DOM input if the ref is an <AutosizeInput /> component
                            input = input.getInput()), // clears the value so that the cursor will be at the end of input when the component re-renders
                            input.value = "", this._focusAfterClear && (toOpen = !1, this._focusAfterClear = !1), 
                            // if the input is focused, ensure the menu is open
                            this.setState({
                                isOpen: toOpen,
                                isPseudoFocused: !1,
                                focusedOption: null
                            });
                        } else // otherwise, focus the input and open the menu
                        this._openAfterFocus = this.props.openOnClick, this.focus(), this.setState({
                            focusedOption: null
                        });
                    }
                }
            }, {
                key: "handleMouseDownOnArrow",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, or if the component is disabled, ignore it.
                    this.props.disabled || "mousedown" === event.type && 0 !== event.button || (this.state.isOpen ? (// prevent default event handlers
                    event.stopPropagation(), event.preventDefault(), // close the menu
                    this.closeMenu()) : // If the menu isn't open, let the event bubble to the main handleMouseDown
                    this.setState({
                        isOpen: !0
                    }));
                }
            }, {
                key: "handleMouseDownOnMenu",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, or if the component is disabled, ignore it.
                    this.props.disabled || "mousedown" === event.type && 0 !== event.button || (event.stopPropagation(), 
                    event.preventDefault(), this._openAfterFocus = !0, this.focus());
                }
            }, {
                key: "closeMenu",
                value: function() {
                    this.props.onCloseResetsInput ? this.setState({
                        inputValue: this.handleInputValueChange(""),
                        isOpen: !1,
                        isPseudoFocused: this.state.isFocused && !this.props.multi
                    }) : this.setState({
                        isOpen: !1,
                        isPseudoFocused: this.state.isFocused && !this.props.multi
                    }), this.hasScrolledToOption = !1;
                }
            }, {
                key: "handleInputFocus",
                value: function(event) {
                    if (!this.props.disabled) {
                        var toOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;
                        toOpen = !this._focusAfterClear && toOpen, //if focus happens after clear values, don't open dropdown yet.
                        this.props.onFocus && this.props.onFocus(event), this.setState({
                            isFocused: !0,
                            isOpen: !!toOpen
                        }), this._focusAfterClear = !1, this._openAfterFocus = !1;
                    }
                }
            }, {
                key: "handleInputBlur",
                value: function(event) {
                    // The check for menu.contains(activeElement) is necessary to prevent IE11's scrollbar from closing the menu in certain contexts.
                    if (this.menu && (this.menu === document.activeElement || this.menu.contains(document.activeElement))) return void this.focus();
                    this.props.onBlur && this.props.onBlur(event);
                    var onBlurredState = {
                        isFocused: !1,
                        isOpen: !1,
                        isPseudoFocused: !1
                    };
                    this.props.onBlurResetsInput && (onBlurredState.inputValue = this.handleInputValueChange("")), 
                    this.setState(onBlurredState);
                }
            }, {
                key: "handleInputChange",
                value: function(event) {
                    var newInputValue = event.target.value;
                    this.state.inputValue !== event.target.value && (newInputValue = this.handleInputValueChange(newInputValue)), 
                    this.setState({
                        inputValue: newInputValue,
                        isOpen: !0,
                        isPseudoFocused: !1
                    });
                }
            }, {
                key: "setInputValue",
                value: function(newValue) {
                    if (this.props.onInputChange) {
                        var nextState = this.props.onInputChange(newValue);
                        null != nextState && "object" !== ("undefined" == typeof nextState ? "undefined" : _typeof(nextState)) && (newValue = "" + nextState);
                    }
                    this.setState({
                        inputValue: newValue
                    });
                }
            }, {
                key: "handleInputValueChange",
                value: function(newValue) {
                    if (this.props.onInputChange) {
                        var nextState = this.props.onInputChange(newValue);
                        // Note: != used deliberately here to catch undefined and null
                        null != nextState && "object" !== ("undefined" == typeof nextState ? "undefined" : _typeof(nextState)) && (newValue = "" + nextState);
                    }
                    return newValue;
                }
            }, {
                key: "handleKeyDown",
                value: function(event) {
                    if (!(this.props.disabled || "function" == typeof this.props.onInputKeyDown && (this.props.onInputKeyDown(event), 
                    event.defaultPrevented))) switch (event.keyCode) {
                      case 8:
                        // backspace
                        !this.state.inputValue && this.props.backspaceRemoves && (event.preventDefault(), 
                        this.popValue());
                        break;

                      case 9:
                        // tab
                        if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) break;
                        event.preventDefault(), this.selectFocusedOption();
                        break;

                      case 13:
                        // enter
                        event.preventDefault(), event.stopPropagation(), this.state.isOpen ? this.selectFocusedOption() : this.focusNextOption();
                        break;

                      case 27:
                        // escape
                        event.preventDefault(), this.state.isOpen ? (this.closeMenu(), event.stopPropagation()) : this.props.clearable && this.props.escapeClearsValue && (this.clearValue(event), 
                        event.stopPropagation());
                        break;

                      case 32:
                        // space
                        if (this.props.searchable) break;
                        if (event.preventDefault(), !this.state.isOpen) {
                            this.focusNextOption();
                            break;
                        }
                        event.stopPropagation(), this.selectFocusedOption();
                        break;

                      case 38:
                        // up
                        event.preventDefault(), this.focusPreviousOption();
                        break;

                      case 40:
                        // down
                        event.preventDefault(), this.focusNextOption();
                        break;

                      case 33:
                        // page up
                        event.preventDefault(), this.focusPageUpOption();
                        break;

                      case 34:
                        // page down
                        event.preventDefault(), this.focusPageDownOption();
                        break;

                      case 35:
                        // end key
                        if (event.shiftKey) break;
                        event.preventDefault(), this.focusEndOption();
                        break;

                      case 36:
                        // home key
                        if (event.shiftKey) break;
                        event.preventDefault(), this.focusStartOption();
                        break;

                      case 46:
                        // delete
                        !this.state.inputValue && this.props.deleteRemoves && (event.preventDefault(), this.popValue());
                    }
                }
            }, {
                key: "handleValueClick",
                value: function(option, event) {
                    this.props.onValueClick && this.props.onValueClick(option, event);
                }
            }, {
                key: "handleMenuScroll",
                value: function(event) {
                    if (this.props.onMenuScrollToBottom) {
                        var target = event.target;
                        target.scrollHeight > target.offsetHeight && target.scrollHeight - target.offsetHeight - target.scrollTop <= 0 && this.props.onMenuScrollToBottom();
                    }
                }
            }, {
                key: "getOptionLabel",
                value: function(op) {
                    return op[this.props.labelKey];
                }
            }, {
                key: "getValueArray",
                value: function(value) {
                    var nextProps = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, props = "object" === ("undefined" == typeof nextProps ? "undefined" : _typeof(nextProps)) ? nextProps : this.props;
                    if (props.multi) {
                        if ("string" == typeof value && (value = value.split(props.delimiter)), !Array.isArray(value)) {
                            if (null === value || void 0 === value) return [];
                            value = [ value ];
                        }
                        return value.map(function(value) {
                            return expandValue(value, props);
                        }).filter(function(i) {
                            return i;
                        });
                    }
                    var expandedValue = expandValue(value, props);
                    return expandedValue ? [ expandedValue ] : [];
                }
            }, {
                key: "setValue",
                value: function(value) {
                    var _this2 = this;
                    if (this.props.autoBlur && this.blurInput(), this.props.required) {
                        var required = handleRequired(value, this.props.multi);
                        this.setState({
                            required: required
                        });
                    }
                    this.props.simpleValue && value && (value = this.props.multi ? value.map(function(i) {
                        return i[_this2.props.valueKey];
                    }).join(this.props.delimiter) : value[this.props.valueKey]), this.props.onChange && this.props.onChange(value);
                }
            }, {
                key: "selectValue",
                value: function(value) {
                    var _this3 = this;
                    // NOTE: we actually add/set the value in a callback to make sure the
                    // input value is empty to avoid styling issues in Chrome
                    this.props.closeOnSelect && (this.hasScrolledToOption = !1);
                    var updatedValue = this.props.onSelectResetsInput ? "" : this.state.inputValue;
                    this.props.multi ? this.setState({
                        focusedIndex: null,
                        inputValue: this.handleInputValueChange(updatedValue),
                        isOpen: !this.props.closeOnSelect
                    }, function() {
                        var valueArray = _this3.getValueArray(_this3.props.value);
                        valueArray.some(function(i) {
                            return i[_this3.props.valueKey] === value[_this3.props.valueKey];
                        }) ? _this3.removeValue(value) : _this3.addValue(value);
                    }) : this.setState({
                        inputValue: this.handleInputValueChange(updatedValue),
                        isOpen: !this.props.closeOnSelect,
                        isPseudoFocused: this.state.isFocused
                    }, function() {
                        _this3.setValue(value);
                    });
                }
            }, {
                key: "addValue",
                value: function(value) {
                    var valueArray = this.getValueArray(this.props.value), visibleOptions = this._visibleOptions.filter(function(val) {
                        return !val.disabled;
                    }), lastValueIndex = visibleOptions.indexOf(value);
                    this.setValue(valueArray.concat(value)), this.props.closeOnSelect && (visibleOptions.length - 1 === lastValueIndex ? // the last option was selected; focus the second-last one
                    this.focusOption(visibleOptions[lastValueIndex - 1]) : visibleOptions.length > lastValueIndex && // focus the option below the selected one
                    this.focusOption(visibleOptions[lastValueIndex + 1]));
                }
            }, {
                key: "popValue",
                value: function() {
                    var valueArray = this.getValueArray(this.props.value);
                    valueArray.length && valueArray[valueArray.length - 1].clearableValue !== !1 && this.setValue(this.props.multi ? valueArray.slice(0, valueArray.length - 1) : null);
                }
            }, {
                key: "removeValue",
                value: function(value) {
                    var _this4 = this, valueArray = this.getValueArray(this.props.value);
                    this.setValue(valueArray.filter(function(i) {
                        return i[_this4.props.valueKey] !== value[_this4.props.valueKey];
                    })), this.focus();
                }
            }, {
                key: "clearValue",
                value: function(event) {
                    // if the event was triggered by a mousedown and not the primary
                    // button, ignore it.
                    event && "mousedown" === event.type && 0 !== event.button || (event.preventDefault(), 
                    this.setValue(this.getResetValue()), this.setState({
                        inputValue: this.handleInputValueChange(""),
                        isOpen: !1
                    }, this.focus), this._focusAfterClear = !0);
                }
            }, {
                key: "getResetValue",
                value: function() {
                    return void 0 !== this.props.resetValue ? this.props.resetValue : this.props.multi ? [] : null;
                }
            }, {
                key: "focusOption",
                value: function(option) {
                    this.setState({
                        focusedOption: option
                    });
                }
            }, {
                key: "focusNextOption",
                value: function() {
                    this.focusAdjacentOption("next");
                }
            }, {
                key: "focusPreviousOption",
                value: function() {
                    this.focusAdjacentOption("previous");
                }
            }, {
                key: "focusPageUpOption",
                value: function() {
                    this.focusAdjacentOption("page_up");
                }
            }, {
                key: "focusPageDownOption",
                value: function() {
                    this.focusAdjacentOption("page_down");
                }
            }, {
                key: "focusStartOption",
                value: function() {
                    this.focusAdjacentOption("start");
                }
            }, {
                key: "focusEndOption",
                value: function() {
                    this.focusAdjacentOption("end");
                }
            }, {
                key: "focusAdjacentOption",
                value: function(dir) {
                    var options = this._visibleOptions.map(function(option, index) {
                        return {
                            option: option,
                            index: index
                        };
                    }).filter(function(option) {
                        return !option.option.disabled;
                    });
                    if (this._scrollToFocusedOptionOnUpdate = !0, !this.state.isOpen) {
                        var newState = {
                            focusedOption: this._focusedOption || (options.length ? options["next" === dir ? 0 : options.length - 1].option : null),
                            isOpen: !0
                        };
                        return this.props.onSelectResetsInput && (newState.inputValue = ""), void this.setState(newState);
                    }
                    if (options.length) {
                        for (var focusedIndex = -1, i = 0; i < options.length; i++) if (this._focusedOption === options[i].option) {
                            focusedIndex = i;
                            break;
                        }
                        if ("next" === dir && focusedIndex !== -1) focusedIndex = (focusedIndex + 1) % options.length; else if ("previous" === dir) focusedIndex > 0 ? focusedIndex -= 1 : focusedIndex = options.length - 1; else if ("start" === dir) focusedIndex = 0; else if ("end" === dir) focusedIndex = options.length - 1; else if ("page_up" === dir) {
                            var potentialIndex = focusedIndex - this.props.pageSize;
                            focusedIndex = potentialIndex < 0 ? 0 : potentialIndex;
                        } else if ("page_down" === dir) {
                            var _potentialIndex = focusedIndex + this.props.pageSize;
                            focusedIndex = _potentialIndex > options.length - 1 ? options.length - 1 : _potentialIndex;
                        }
                        focusedIndex === -1 && (focusedIndex = 0), this.setState({
                            focusedIndex: options[focusedIndex].index,
                            focusedOption: options[focusedIndex].option
                        });
                    }
                }
            }, {
                key: "getFocusedOption",
                value: function() {
                    return this._focusedOption;
                }
            }, {
                key: "selectFocusedOption",
                value: function() {
                    if (this._focusedOption) return this.selectValue(this._focusedOption);
                }
            }, {
                key: "renderLoading",
                value: function() {
                    if (this.props.isLoading) return _react2.default.createElement("span", {
                        className: "Select-loading-zone",
                        "aria-hidden": "true"
                    }, _react2.default.createElement("span", {
                        className: "Select-loading"
                    }));
                }
            }, {
                key: "renderValue",
                value: function(valueArray, isOpen) {
                    var _this5 = this, renderLabel = this.props.valueRenderer || this.getOptionLabel, ValueComponent = this.props.valueComponent;
                    if (!valueArray.length) {
                        var showPlaceholder = shouldShowPlaceholder(this.state, this.props, isOpen);
                        return showPlaceholder ? _react2.default.createElement("div", {
                            className: "Select-placeholder"
                        }, this.props.placeholder) : null;
                    }
                    var onClick = this.props.onValueClick ? this.handleValueClick : null;
                    return this.props.multi ? valueArray.map(function(value, i) {
                        return _react2.default.createElement(ValueComponent, {
                            disabled: _this5.props.disabled || value.clearableValue === !1,
                            id: _this5._instancePrefix + "-value-" + i,
                            instancePrefix: _this5._instancePrefix,
                            key: "value-" + i + "-" + value[_this5.props.valueKey],
                            onClick: onClick,
                            onRemove: _this5.removeValue,
                            placeholder: _this5.props.placeholder,
                            value: value,
                            values: valueArray
                        }, renderLabel(value, i), _react2.default.createElement("span", {
                            className: "Select-aria-only"
                        }, " "));
                    }) : shouldShowValue(this.state, this.props) ? (isOpen && (onClick = null), _react2.default.createElement(ValueComponent, {
                        disabled: this.props.disabled,
                        id: this._instancePrefix + "-value-item",
                        instancePrefix: this._instancePrefix,
                        onClick: onClick,
                        placeholder: this.props.placeholder,
                        value: valueArray[0]
                    }, renderLabel(valueArray[0]))) : void 0;
                }
            }, {
                key: "renderInput",
                value: function(valueArray, focusedOptionIndex) {
                    var _classNames, _this6 = this, className = (0, _classnames2.default)("Select-input", this.props.inputProps.className), isOpen = this.state.isOpen, ariaOwns = (0, 
                    _classnames2.default)((_classNames = {}, _defineProperty(_classNames, this._instancePrefix + "-list", isOpen), 
                    _defineProperty(_classNames, this._instancePrefix + "-backspace-remove-message", this.props.multi && !this.props.disabled && this.state.isFocused && !this.state.inputValue), 
                    _classNames)), value = this.state.inputValue;
                    !value || this.props.onSelectResetsInput || this.state.isFocused || (// it hides input value when it is not focused and was not reset on select
                    value = "");
                    var inputProps = _extends({}, this.props.inputProps, {
                        "aria-activedescendant": isOpen ? this._instancePrefix + "-option-" + focusedOptionIndex : this._instancePrefix + "-value",
                        "aria-describedby": this.props["aria-describedby"],
                        "aria-expanded": "" + isOpen,
                        "aria-haspopup": "" + isOpen,
                        "aria-label": this.props["aria-label"],
                        "aria-labelledby": this.props["aria-labelledby"],
                        "aria-owns": ariaOwns,
                        onBlur: this.handleInputBlur,
                        onChange: this.handleInputChange,
                        onFocus: this.handleInputFocus,
                        ref: function(_ref) {
                            return _this6.input = _ref;
                        },
                        role: "combobox",
                        required: this.state.required,
                        tabIndex: this.props.tabIndex,
                        value: value
                    });
                    if (this.props.inputRenderer) return this.props.inputRenderer(inputProps);
                    if (this.props.disabled || !this.props.searchable) {
                        var divProps = _objectWithoutProperties(this.props.inputProps, []), _ariaOwns = (0, 
                        _classnames2.default)(_defineProperty({}, this._instancePrefix + "-list", isOpen));
                        return _react2.default.createElement("div", _extends({}, divProps, {
                            "aria-expanded": isOpen,
                            "aria-owns": _ariaOwns,
                            "aria-activedescendant": isOpen ? this._instancePrefix + "-option-" + focusedOptionIndex : this._instancePrefix + "-value",
                            "aria-disabled": "" + this.props.disabled,
                            "aria-label": this.props["aria-label"],
                            "aria-labelledby": this.props["aria-labelledby"],
                            className: className,
                            onBlur: this.handleInputBlur,
                            onFocus: this.handleInputFocus,
                            ref: function(_ref2) {
                                return _this6.input = _ref2;
                            },
                            role: "combobox",
                            style: {
                                border: 0,
                                width: 1,
                                display: "inline-block"
                            },
                            tabIndex: this.props.tabIndex || 0
                        }));
                    }
                    return this.props.autosize ? _react2.default.createElement(_reactInputAutosize2.default, _extends({
                        id: this.props.id
                    }, inputProps, {
                        className: className,
                        minWidth: "5"
                    })) : _react2.default.createElement("div", {
                        className: className,
                        key: "input-wrap",
                        style: {
                            display: "inline-block"
                        }
                    }, _react2.default.createElement("input", _extends({
                        id: this.props.id
                    }, inputProps)));
                }
            }, {
                key: "renderClear",
                value: function() {
                    var valueArray = this.getValueArray(this.props.value);
                    if (this.props.clearable && valueArray.length && !this.props.disabled && !this.props.isLoading) {
                        var ariaLabel = this.props.multi ? this.props.clearAllText : this.props.clearValueText, clear = this.props.clearRenderer();
                        return _react2.default.createElement("span", {
                            "aria-label": ariaLabel,
                            className: "Select-clear-zone",
                            onMouseDown: this.clearValue,
                            onTouchEnd: this.handleTouchEndClearValue,
                            onTouchMove: this.handleTouchMove,
                            onTouchStart: this.handleTouchStart,
                            title: ariaLabel
                        }, clear);
                    }
                }
            }, {
                key: "renderArrow",
                value: function() {
                    if (this.props.arrowRenderer) {
                        var onMouseDown = this.handleMouseDownOnArrow, isOpen = this.state.isOpen, arrow = this.props.arrowRenderer({
                            onMouseDown: onMouseDown,
                            isOpen: isOpen
                        });
                        return arrow ? _react2.default.createElement("span", {
                            className: "Select-arrow-zone",
                            onMouseDown: onMouseDown
                        }, arrow) : null;
                    }
                }
            }, {
                key: "filterOptions",
                value: function filterOptions(excludeOptions) {
                    var filterValue = this.state.inputValue, options = this.props.options || [];
                    if (this.props.filterOptions) {
                        // Maintain backwards compatibility with boolean attribute
                        var filterOptions = "function" == typeof this.props.filterOptions ? this.props.filterOptions : _defaultFilterOptions2.default;
                        return filterOptions(options, filterValue, excludeOptions, {
                            filterOption: this.props.filterOption,
                            ignoreAccents: this.props.ignoreAccents,
                            ignoreCase: this.props.ignoreCase,
                            labelKey: this.props.labelKey,
                            matchPos: this.props.matchPos,
                            matchProp: this.props.matchProp,
                            trimFilter: this.props.trimFilter,
                            valueKey: this.props.valueKey
                        });
                    }
                    return options;
                }
            }, {
                key: "onOptionRef",
                value: function(ref, isFocused) {
                    isFocused && (this.focused = ref);
                }
            }, {
                key: "renderMenu",
                value: function(options, valueArray, focusedOption) {
                    return options && options.length ? this.props.menuRenderer({
                        focusedOption: focusedOption,
                        focusOption: this.focusOption,
                        inputValue: this.state.inputValue,
                        instancePrefix: this._instancePrefix,
                        labelKey: this.props.labelKey,
                        onFocus: this.focusOption,
                        onOptionRef: this.onOptionRef,
                        onSelect: this.selectValue,
                        optionClassName: this.props.optionClassName,
                        optionComponent: this.props.optionComponent,
                        optionRenderer: this.props.optionRenderer || this.getOptionLabel,
                        options: options,
                        removeValue: this.removeValue,
                        selectValue: this.selectValue,
                        valueArray: valueArray,
                        valueKey: this.props.valueKey
                    }) : this.props.noResultsText ? _react2.default.createElement("div", {
                        className: "Select-noresults"
                    }, this.props.noResultsText) : null;
                }
            }, {
                key: "renderHiddenField",
                value: function(valueArray) {
                    var _this7 = this;
                    if (this.props.name) {
                        if (this.props.joinValues) {
                            var value = valueArray.map(function(i) {
                                return stringifyValue(i[_this7.props.valueKey]);
                            }).join(this.props.delimiter);
                            return _react2.default.createElement("input", {
                                disabled: this.props.disabled,
                                name: this.props.name,
                                ref: function(_ref3) {
                                    return _this7.value = _ref3;
                                },
                                type: "hidden",
                                value: value
                            });
                        }
                        return valueArray.map(function(item, index) {
                            return _react2.default.createElement("input", {
                                disabled: _this7.props.disabled,
                                key: "hidden." + index,
                                name: _this7.props.name,
                                ref: "value" + index,
                                type: "hidden",
                                value: stringifyValue(item[_this7.props.valueKey])
                            });
                        });
                    }
                }
            }, {
                key: "getFocusableOptionIndex",
                value: function(selectedOption) {
                    var options = this._visibleOptions;
                    if (!options.length) return null;
                    var valueKey = this.props.valueKey, focusedOption = this.state.focusedOption || selectedOption;
                    if (focusedOption && !focusedOption.disabled) {
                        var focusedOptionIndex = -1;
                        if (options.some(function(option, index) {
                            var isOptionEqual = option[valueKey] === focusedOption[valueKey];
                            return isOptionEqual && (focusedOptionIndex = index), isOptionEqual;
                        }), focusedOptionIndex !== -1) return focusedOptionIndex;
                    }
                    for (var i = 0; i < options.length; i++) if (!options[i].disabled) return i;
                    return null;
                }
            }, {
                key: "renderOuter",
                value: function(options, valueArray, focusedOption) {
                    var _this8 = this, menu = this.renderMenu(options, valueArray, focusedOption);
                    return menu ? _react2.default.createElement("div", {
                        ref: function(_ref5) {
                            return _this8.menuContainer = _ref5;
                        },
                        className: "Select-menu-outer",
                        style: this.props.menuContainerStyle
                    }, _react2.default.createElement("div", {
                        className: "Select-menu",
                        id: this._instancePrefix + "-list",
                        onMouseDown: this.handleMouseDownOnMenu,
                        onScroll: this.handleMenuScroll,
                        ref: function(_ref4) {
                            return _this8.menu = _ref4;
                        },
                        role: "listbox",
                        style: this.props.menuStyle,
                        tabIndex: -1
                    }, menu)) : null;
                }
            }, {
                key: "render",
                value: function() {
                    var _this9 = this, valueArray = this.getValueArray(this.props.value), options = this._visibleOptions = this.filterOptions(this.props.multi && this.props.removeSelected ? valueArray : null), isOpen = this.state.isOpen;
                    this.props.multi && !options.length && valueArray.length && !this.state.inputValue && (isOpen = !1);
                    var focusedOptionIndex = this.getFocusableOptionIndex(valueArray[0]), focusedOption = null;
                    focusedOption = null !== focusedOptionIndex ? this._focusedOption = options[focusedOptionIndex] : this._focusedOption = null;
                    var className = (0, _classnames2.default)("Select", this.props.className, {
                        "has-value": valueArray.length,
                        "is-clearable": this.props.clearable,
                        "is-disabled": this.props.disabled,
                        "is-focused": this.state.isFocused,
                        "is-loading": this.props.isLoading,
                        "is-open": isOpen,
                        "is-pseudo-focused": this.state.isPseudoFocused,
                        "is-searchable": this.props.searchable,
                        "Select--multi": this.props.multi,
                        "Select--rtl": this.props.rtl,
                        "Select--single": !this.props.multi
                    }), removeMessage = null;
                    return this.props.multi && !this.props.disabled && valueArray.length && !this.state.inputValue && this.state.isFocused && this.props.backspaceRemoves && (removeMessage = _react2.default.createElement("span", {
                        id: this._instancePrefix + "-backspace-remove-message",
                        className: "Select-aria-only",
                        "aria-live": "assertive"
                    }, this.props.backspaceToRemoveMessage.replace("{label}", valueArray[valueArray.length - 1][this.props.labelKey]))), 
                    _react2.default.createElement("div", {
                        ref: function(_ref7) {
                            return _this9.wrapper = _ref7;
                        },
                        className: className,
                        style: this.props.wrapperStyle
                    }, this.renderHiddenField(valueArray), _react2.default.createElement("div", {
                        ref: function(_ref6) {
                            return _this9.control = _ref6;
                        },
                        className: "Select-control",
                        onKeyDown: this.handleKeyDown,
                        onMouseDown: this.handleMouseDown,
                        onTouchEnd: this.handleTouchEnd,
                        onTouchMove: this.handleTouchMove,
                        onTouchStart: this.handleTouchStart,
                        style: this.props.style
                    }, _react2.default.createElement("div", {
                        className: "Select-multi-value-wrapper",
                        id: this._instancePrefix + "-value"
                    }, this.renderValue(valueArray, isOpen), this.renderInput(valueArray, focusedOptionIndex)), removeMessage, this.renderLoading(), this.renderClear(), this.renderArrow()), isOpen ? this.renderOuter(options, valueArray, focusedOption) : null);
                }
            } ]), Select;
        }(_react2.default.Component);
        Select.propTypes = {
            "aria-describedby": _propTypes2.default.string,
            // html id(s) of element(s) that should be used to describe this input (for assistive tech)
            "aria-label": _propTypes2.default.string,
            // aria label (for assistive tech)
            "aria-labelledby": _propTypes2.default.string,
            // html id of an element that should be used as the label (for assistive tech)
            arrowRenderer: _propTypes2.default.func,
            // create the drop-down caret element
            autoBlur: _propTypes2.default.bool,
            // automatically blur the component when an option is selected
            autoFocus: _propTypes2.default.bool,
            // autofocus the component on mount
            autofocus: _propTypes2.default.bool,
            // deprecated; use autoFocus instead
            autosize: _propTypes2.default.bool,
            // whether to enable autosizing or not
            backspaceRemoves: _propTypes2.default.bool,
            // whether backspace removes an item if there is no text input
            backspaceToRemoveMessage: _propTypes2.default.string,
            // message to use for screenreaders to press backspace to remove the current item - {label} is replaced with the item label
            className: _propTypes2.default.string,
            // className for the outer element
            clearAllText: stringOrNode,
            // title for the "clear" control when multi: true
            clearRenderer: _propTypes2.default.func,
            // create clearable x element
            clearValueText: stringOrNode,
            // title for the "clear" control
            clearable: _propTypes2.default.bool,
            // should it be possible to reset value
            closeOnSelect: _propTypes2.default.bool,
            // whether to close the menu when a value is selected
            deleteRemoves: _propTypes2.default.bool,
            // whether delete removes an item if there is no text input
            delimiter: _propTypes2.default.string,
            // delimiter to use to join multiple values for the hidden field value
            disabled: _propTypes2.default.bool,
            // whether the Select is disabled or not
            escapeClearsValue: _propTypes2.default.bool,
            // whether escape clears the value when the menu is closed
            filterOption: _propTypes2.default.func,
            // method to filter a single option (option, filterString)
            filterOptions: _propTypes2.default.any,
            // boolean to enable default filtering or function to filter the options array ([options], filterString, [values])
            id: _propTypes2.default.string,
            // html id to set on the input element for accessibility or tests
            ignoreAccents: _propTypes2.default.bool,
            // whether to strip diacritics when filtering
            ignoreCase: _propTypes2.default.bool,
            // whether to perform case-insensitive filtering
            inputProps: _propTypes2.default.object,
            // custom attributes for the Input
            inputRenderer: _propTypes2.default.func,
            // returns a custom input component
            instanceId: _propTypes2.default.string,
            // set the components instanceId
            isLoading: _propTypes2.default.bool,
            // whether the Select is loading externally or not (such as options being loaded)
            joinValues: _propTypes2.default.bool,
            // joins multiple values into a single form field with the delimiter (legacy mode)
            labelKey: _propTypes2.default.string,
            // path of the label value in option objects
            matchPos: _propTypes2.default.string,
            // (any|start) match the start or entire string when filtering
            matchProp: _propTypes2.default.string,
            // (any|label|value) which option property to filter on
            menuBuffer: _propTypes2.default.number,
            // optional buffer (in px) between the bottom of the viewport and the bottom of the menu
            menuContainerStyle: _propTypes2.default.object,
            // optional style to apply to the menu container
            menuRenderer: _propTypes2.default.func,
            // renders a custom menu with options
            menuStyle: _propTypes2.default.object,
            // optional style to apply to the menu
            multi: _propTypes2.default.bool,
            // multi-value input
            name: _propTypes2.default.string,
            // generates a hidden <input /> tag with this field name for html forms
            noResultsText: stringOrNode,
            // placeholder displayed when there are no matching search results
            onBlur: _propTypes2.default.func,
            // onBlur handler: function (event) {}
            onBlurResetsInput: _propTypes2.default.bool,
            // whether input is cleared on blur
            onChange: _propTypes2.default.func,
            // onChange handler: function (newValue) {}
            onClose: _propTypes2.default.func,
            // fires when the menu is closed
            onCloseResetsInput: _propTypes2.default.bool,
            // whether input is cleared when menu is closed through the arrow
            onFocus: _propTypes2.default.func,
            // onFocus handler: function (event) {}
            onInputChange: _propTypes2.default.func,
            // onInputChange handler: function (inputValue) {}
            onInputKeyDown: _propTypes2.default.func,
            // input keyDown handler: function (event) {}
            onMenuScrollToBottom: _propTypes2.default.func,
            // fires when the menu is scrolled to the bottom; can be used to paginate options
            onOpen: _propTypes2.default.func,
            // fires when the menu is opened
            onSelectResetsInput: _propTypes2.default.bool,
            // whether input is cleared on select (works only for multiselect)
            onValueClick: _propTypes2.default.func,
            // onClick handler for value labels: function (value, event) {}
            openOnClick: _propTypes2.default.bool,
            // boolean to control opening the menu when the control is clicked
            openOnFocus: _propTypes2.default.bool,
            // always open options menu on focus
            optionClassName: _propTypes2.default.string,
            // additional class(es) to apply to the <Option /> elements
            optionComponent: _propTypes2.default.func,
            // option component to render in dropdown
            optionRenderer: _propTypes2.default.func,
            // optionRenderer: function (option) {}
            options: _propTypes2.default.array,
            // array of options
            pageSize: _propTypes2.default.number,
            // number of entries to page when using page up/down keys
            placeholder: stringOrNode,
            // field placeholder, displayed when there's no value
            removeSelected: _propTypes2.default.bool,
            // whether the selected option is removed from the dropdown on multi selects
            required: _propTypes2.default.bool,
            // applies HTML5 required attribute when needed
            resetValue: _propTypes2.default.any,
            // value to use when you clear the control
            rtl: _propTypes2.default.bool,
            // set to true in order to use react-select in right-to-left direction
            scrollMenuIntoView: _propTypes2.default.bool,
            // boolean to enable the viewport to shift so that the full menu fully visible when engaged
            searchable: _propTypes2.default.bool,
            // whether to enable searching feature or not
            simpleValue: _propTypes2.default.bool,
            // pass the value to onChange as a simple value (legacy pre 1.0 mode), defaults to false
            style: _propTypes2.default.object,
            // optional style to apply to the control
            tabIndex: stringOrNumber,
            // optional tab index of the control
            tabSelectsValue: _propTypes2.default.bool,
            // whether to treat tabbing out while focused to be value selection
            trimFilter: _propTypes2.default.bool,
            // whether to trim whitespace around filter value
            value: _propTypes2.default.any,
            // initial field value
            valueComponent: _propTypes2.default.func,
            // value component to render
            valueKey: _propTypes2.default.string,
            // path of the label value in option objects
            valueRenderer: _propTypes2.default.func,
            // valueRenderer: function (option) {}
            wrapperStyle: _propTypes2.default.object
        }, Select.defaultProps = {
            arrowRenderer: _defaultArrowRenderer2.default,
            autosize: !0,
            backspaceRemoves: !0,
            backspaceToRemoveMessage: "Press backspace to remove {label}",
            clearable: !0,
            clearAllText: "Clear all",
            clearRenderer: _defaultClearRenderer2.default,
            clearValueText: "Clear value",
            closeOnSelect: !0,
            deleteRemoves: !0,
            delimiter: ",",
            disabled: !1,
            escapeClearsValue: !0,
            filterOptions: _defaultFilterOptions2.default,
            ignoreAccents: !0,
            ignoreCase: !0,
            inputProps: {},
            isLoading: !1,
            joinValues: !1,
            labelKey: "label",
            matchPos: "any",
            matchProp: "any",
            menuBuffer: 0,
            menuRenderer: _defaultMenuRenderer2.default,
            multi: !1,
            noResultsText: "No results found",
            onBlurResetsInput: !0,
            onCloseResetsInput: !0,
            onSelectResetsInput: !0,
            openOnClick: !0,
            optionComponent: _Option2.default,
            pageSize: 5,
            placeholder: "Select...",
            removeSelected: !0,
            required: !1,
            rtl: !1,
            scrollMenuIntoView: !0,
            searchable: !0,
            simpleValue: !1,
            tabSelectsValue: !0,
            trimFilter: !0,
            valueComponent: _Value2.default,
            valueKey: "value"
        }, exports.default = Select;
    }, /* 152 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), sizerStyle = {
            position: "absolute",
            top: 0,
            left: 0,
            visibility: "hidden",
            height: 0,
            overflow: "scroll",
            whiteSpace: "pre"
        }, INPUT_PROPS_BLACKLIST = [ "extraWidth", "injectStyles", "inputClassName", "inputRef", "inputStyle", "minWidth", "onAutosize", "placeholderIsMinWidth" ], cleanInputProps = function(inputProps) {
            return INPUT_PROPS_BLACKLIST.forEach(function(field) {
                return delete inputProps[field];
            }), inputProps;
        }, copyStyles = function(styles, node) {
            node.style.fontSize = styles.fontSize, node.style.fontFamily = styles.fontFamily, 
            node.style.fontWeight = styles.fontWeight, node.style.fontStyle = styles.fontStyle, 
            node.style.letterSpacing = styles.letterSpacing, node.style.textTransform = styles.textTransform;
        }, isIE = !("undefined" == typeof window || !window.navigator) && /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent), generateId = function() {
            // we only need an auto-generated ID for stylesheet injection, which is only
            // used for IE. so if the browser is not IE, this should return undefined.
            return isIE ? "_" + Math.random().toString(36).substr(2, 12) : void 0;
        }, AutosizeInput = function(_Component) {
            function AutosizeInput(props) {
                _classCallCheck(this, AutosizeInput);
                var _this = _possibleConstructorReturn(this, (AutosizeInput.__proto__ || Object.getPrototypeOf(AutosizeInput)).call(this, props));
                return _this.inputRef = function(el) {
                    _this.input = el, "function" == typeof _this.props.inputRef && _this.props.inputRef(el);
                }, _this.placeHolderSizerRef = function(el) {
                    _this.placeHolderSizer = el;
                }, _this.sizerRef = function(el) {
                    _this.sizer = el;
                }, _this.state = {
                    inputWidth: props.minWidth,
                    inputId: props.id || generateId()
                }, _this;
            }
            return _inherits(AutosizeInput, _Component), _createClass(AutosizeInput, [ {
                key: "componentDidMount",
                value: function() {
                    this.mounted = !0, this.copyInputStyles(), this.updateInputWidth();
                }
            }, {
                key: "UNSAFE_componentWillReceiveProps",
                value: function(nextProps) {
                    var id = nextProps.id;
                    id !== this.props.id && this.setState({
                        inputId: id || generateId()
                    });
                }
            }, {
                key: "componentDidUpdate",
                value: function(prevProps, prevState) {
                    prevState.inputWidth !== this.state.inputWidth && "function" == typeof this.props.onAutosize && this.props.onAutosize(this.state.inputWidth), 
                    this.updateInputWidth();
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this.mounted = !1;
                }
            }, {
                key: "copyInputStyles",
                value: function() {
                    if (this.mounted && window.getComputedStyle) {
                        var inputStyles = this.input && window.getComputedStyle(this.input);
                        inputStyles && (copyStyles(inputStyles, this.sizer), this.placeHolderSizer && copyStyles(inputStyles, this.placeHolderSizer));
                    }
                }
            }, {
                key: "updateInputWidth",
                value: function() {
                    if (this.mounted && this.sizer && "undefined" != typeof this.sizer.scrollWidth) {
                        var newInputWidth = void 0;
                        newInputWidth = this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth) ? Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2 : this.sizer.scrollWidth + 2;
                        // add extraWidth to the detected width. for number types, this defaults to 16 to allow for the stepper UI
                        var extraWidth = "number" === this.props.type && void 0 === this.props.extraWidth ? 16 : parseInt(this.props.extraWidth) || 0;
                        newInputWidth += extraWidth, newInputWidth < this.props.minWidth && (newInputWidth = this.props.minWidth), 
                        newInputWidth !== this.state.inputWidth && this.setState({
                            inputWidth: newInputWidth
                        });
                    }
                }
            }, {
                key: "getInput",
                value: function() {
                    return this.input;
                }
            }, {
                key: "focus",
                value: function() {
                    this.input.focus();
                }
            }, {
                key: "blur",
                value: function() {
                    this.input.blur();
                }
            }, {
                key: "select",
                value: function() {
                    this.input.select();
                }
            }, {
                key: "renderStyles",
                value: function() {
                    // this method injects styles to hide IE's clear indicator, which messes
                    // with input size detection. the stylesheet is only injected when the
                    // browser is IE, and can also be disabled by the `injectStyles` prop.
                    var injectStyles = this.props.injectStyles;
                    return isIE && injectStyles ? _react2.default.createElement("style", {
                        dangerouslySetInnerHTML: {
                            __html: "input#" + this.state.inputId + "::-ms-clear {display: none;}"
                        }
                    }) : null;
                }
            }, {
                key: "render",
                value: function() {
                    var sizerValue = [ this.props.defaultValue, this.props.value, "" ].reduce(function(previousValue, currentValue) {
                        return null !== previousValue && void 0 !== previousValue ? previousValue : currentValue;
                    }), wrapperStyle = _extends({}, this.props.style);
                    wrapperStyle.display || (wrapperStyle.display = "inline-block");
                    var inputStyle = _extends({
                        boxSizing: "content-box",
                        width: this.state.inputWidth + "px"
                    }, this.props.inputStyle), inputProps = _objectWithoutProperties(this.props, []);
                    return cleanInputProps(inputProps), inputProps.className = this.props.inputClassName, 
                    inputProps.id = this.state.inputId, inputProps.style = inputStyle, _react2.default.createElement("div", {
                        className: this.props.className,
                        style: wrapperStyle
                    }, this.renderStyles(), _react2.default.createElement("input", _extends({}, inputProps, {
                        ref: this.inputRef
                    })), _react2.default.createElement("div", {
                        ref: this.sizerRef,
                        style: sizerStyle
                    }, sizerValue), this.props.placeholder ? _react2.default.createElement("div", {
                        ref: this.placeHolderSizerRef,
                        style: sizerStyle
                    }, this.props.placeholder) : null);
                }
            } ]), AutosizeInput;
        }(_react.Component);
        AutosizeInput.propTypes = {
            className: _propTypes2.default.string,
            // className for the outer element
            defaultValue: _propTypes2.default.any,
            // default field value
            extraWidth: _propTypes2.default.oneOfType([ // additional width for input element
            _propTypes2.default.number, _propTypes2.default.string ]),
            id: _propTypes2.default.string,
            // id to use for the input, can be set for consistent snapshots
            injectStyles: _propTypes2.default.bool,
            // inject the custom stylesheet to hide clear UI, defaults to true
            inputClassName: _propTypes2.default.string,
            // className for the input element
            inputRef: _propTypes2.default.func,
            // ref callback for the input element
            inputStyle: _propTypes2.default.object,
            // css styles for the input element
            minWidth: _propTypes2.default.oneOfType([ // minimum width for input element
            _propTypes2.default.number, _propTypes2.default.string ]),
            onAutosize: _propTypes2.default.func,
            // onAutosize handler: function(newWidth) {}
            onChange: _propTypes2.default.func,
            // onChange handler: function(event) {}
            placeholder: _propTypes2.default.string,
            // placeholder text
            placeholderIsMinWidth: _propTypes2.default.bool,
            // don't collapse size to less than the placeholder
            style: _propTypes2.default.object,
            // css styles for the outer element
            value: _propTypes2.default.any
        }, AutosizeInput.defaultProps = {
            minWidth: 1,
            injectStyles: !0
        }, exports.default = AutosizeInput;
    }, /* 153 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), arrowRenderer = function(_ref) {
            var onMouseDown = _ref.onMouseDown;
            return _react2.default.createElement("span", {
                className: "Select-arrow",
                onMouseDown: onMouseDown
            });
        };
        arrowRenderer.propTypes = {
            onMouseDown: _propTypes2.default.func
        }, exports.default = arrowRenderer;
    }, /* 154 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), clearRenderer = function() {
            return _react2.default.createElement("span", {
                className: "Select-clear",
                dangerouslySetInnerHTML: {
                    __html: "&times;"
                }
            });
        };
        exports.default = clearRenderer;
    }, /* 155 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _stripDiacritics = __webpack_require__(156), _stripDiacritics2 = _interopRequireDefault(_stripDiacritics), _trim = __webpack_require__(157), _trim2 = _interopRequireDefault(_trim), isValid = function(value) {
            return "undefined" != typeof value && null !== value && "" !== value;
        }, filterOptions = function(options, filterValue, excludeOptions, props) {
            return props.ignoreAccents && (filterValue = (0, _stripDiacritics2.default)(filterValue)), 
            props.ignoreCase && (filterValue = filterValue.toLowerCase()), props.trimFilter && (filterValue = (0, 
            _trim2.default)(filterValue)), excludeOptions && (excludeOptions = excludeOptions.map(function(i) {
                return i[props.valueKey];
            })), options.filter(function(option) {
                if (excludeOptions && excludeOptions.indexOf(option[props.valueKey]) > -1) return !1;
                if (props.filterOption) return props.filterOption.call(void 0, option, filterValue);
                if (!filterValue) return !0;
                var value = option[props.valueKey], label = option[props.labelKey], hasValue = isValid(value), hasLabel = isValid(label);
                if (!hasValue && !hasLabel) return !1;
                var valueTest = hasValue ? String(value) : null, labelTest = hasLabel ? String(label) : null;
                return props.ignoreAccents && (valueTest && "label" !== props.matchProp && (valueTest = (0, 
                _stripDiacritics2.default)(valueTest)), labelTest && "value" !== props.matchProp && (labelTest = (0, 
                _stripDiacritics2.default)(labelTest))), props.ignoreCase && (valueTest && "label" !== props.matchProp && (valueTest = valueTest.toLowerCase()), 
                labelTest && "value" !== props.matchProp && (labelTest = labelTest.toLowerCase())), 
                "start" === props.matchPos ? valueTest && "label" !== props.matchProp && valueTest.substr(0, filterValue.length) === filterValue || labelTest && "value" !== props.matchProp && labelTest.substr(0, filterValue.length) === filterValue : valueTest && "label" !== props.matchProp && valueTest.indexOf(filterValue) >= 0 || labelTest && "value" !== props.matchProp && labelTest.indexOf(filterValue) >= 0;
            });
        };
        exports.default = filterOptions;
    }, /* 156 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var map = [ {
            base: "A",
            letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
        }, {
            base: "AA",
            letters: /[\uA732]/g
        }, {
            base: "AE",
            letters: /[\u00C6\u01FC\u01E2]/g
        }, {
            base: "AO",
            letters: /[\uA734]/g
        }, {
            base: "AU",
            letters: /[\uA736]/g
        }, {
            base: "AV",
            letters: /[\uA738\uA73A]/g
        }, {
            base: "AY",
            letters: /[\uA73C]/g
        }, {
            base: "B",
            letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
        }, {
            base: "C",
            letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
        }, {
            base: "D",
            letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
        }, {
            base: "DZ",
            letters: /[\u01F1\u01C4]/g
        }, {
            base: "Dz",
            letters: /[\u01F2\u01C5]/g
        }, {
            base: "E",
            letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
        }, {
            base: "F",
            letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
        }, {
            base: "G",
            letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
        }, {
            base: "H",
            letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
        }, {
            base: "I",
            letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
        }, {
            base: "J",
            letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g
        }, {
            base: "K",
            letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
        }, {
            base: "L",
            letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
        }, {
            base: "LJ",
            letters: /[\u01C7]/g
        }, {
            base: "Lj",
            letters: /[\u01C8]/g
        }, {
            base: "M",
            letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
        }, {
            base: "N",
            letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
        }, {
            base: "NJ",
            letters: /[\u01CA]/g
        }, {
            base: "Nj",
            letters: /[\u01CB]/g
        }, {
            base: "O",
            letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
        }, {
            base: "OI",
            letters: /[\u01A2]/g
        }, {
            base: "OO",
            letters: /[\uA74E]/g
        }, {
            base: "OU",
            letters: /[\u0222]/g
        }, {
            base: "P",
            letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
        }, {
            base: "Q",
            letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
        }, {
            base: "R",
            letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
        }, {
            base: "S",
            letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
        }, {
            base: "T",
            letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
        }, {
            base: "TZ",
            letters: /[\uA728]/g
        }, {
            base: "U",
            letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
        }, {
            base: "V",
            letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
        }, {
            base: "VY",
            letters: /[\uA760]/g
        }, {
            base: "W",
            letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
        }, {
            base: "X",
            letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
        }, {
            base: "Y",
            letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
        }, {
            base: "Z",
            letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
        }, {
            base: "a",
            letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
        }, {
            base: "aa",
            letters: /[\uA733]/g
        }, {
            base: "ae",
            letters: /[\u00E6\u01FD\u01E3]/g
        }, {
            base: "ao",
            letters: /[\uA735]/g
        }, {
            base: "au",
            letters: /[\uA737]/g
        }, {
            base: "av",
            letters: /[\uA739\uA73B]/g
        }, {
            base: "ay",
            letters: /[\uA73D]/g
        }, {
            base: "b",
            letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
        }, {
            base: "c",
            letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
        }, {
            base: "d",
            letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
        }, {
            base: "dz",
            letters: /[\u01F3\u01C6]/g
        }, {
            base: "e",
            letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
        }, {
            base: "f",
            letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
        }, {
            base: "g",
            letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
        }, {
            base: "h",
            letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
        }, {
            base: "hv",
            letters: /[\u0195]/g
        }, {
            base: "i",
            letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
        }, {
            base: "j",
            letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
        }, {
            base: "k",
            letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
        }, {
            base: "l",
            letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
        }, {
            base: "lj",
            letters: /[\u01C9]/g
        }, {
            base: "m",
            letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
        }, {
            base: "n",
            letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
        }, {
            base: "nj",
            letters: /[\u01CC]/g
        }, {
            base: "o",
            letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
        }, {
            base: "oi",
            letters: /[\u01A3]/g
        }, {
            base: "ou",
            letters: /[\u0223]/g
        }, {
            base: "oo",
            letters: /[\uA74F]/g
        }, {
            base: "p",
            letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
        }, {
            base: "q",
            letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
        }, {
            base: "r",
            letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
        }, {
            base: "s",
            letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
        }, {
            base: "t",
            letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
        }, {
            base: "tz",
            letters: /[\uA729]/g
        }, {
            base: "u",
            letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
        }, {
            base: "v",
            letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
        }, {
            base: "vy",
            letters: /[\uA761]/g
        }, {
            base: "w",
            letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
        }, {
            base: "x",
            letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
        }, {
            base: "y",
            letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
        }, {
            base: "z",
            letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
        } ], stripDiacritics = function(str) {
            for (var i = 0; i < map.length; i++) str = str.replace(map[i].letters, map[i].base);
            return str;
        };
        exports.default = stripDiacritics;
    }, /* 157 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var trim = function(str) {
            return str.replace(/^\s+|\s+$/g, "");
        };
        exports.default = trim;
    }, /* 158 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), menuRenderer = function(_ref) {
            var focusedOption = _ref.focusedOption, focusOption = _ref.focusOption, inputValue = _ref.inputValue, instancePrefix = _ref.instancePrefix, onFocus = _ref.onFocus, onOptionRef = _ref.onOptionRef, onSelect = _ref.onSelect, optionClassName = _ref.optionClassName, optionComponent = _ref.optionComponent, optionRenderer = _ref.optionRenderer, options = _ref.options, removeValue = _ref.removeValue, selectValue = _ref.selectValue, valueArray = _ref.valueArray, valueKey = _ref.valueKey, Option = optionComponent;
            return options.map(function(option, i) {
                var isSelected = valueArray && valueArray.some(function(x) {
                    return x[valueKey] === option[valueKey];
                }), isFocused = option === focusedOption, optionClass = (0, _classnames2.default)(optionClassName, {
                    "Select-option": !0,
                    "is-selected": isSelected,
                    "is-focused": isFocused,
                    "is-disabled": option.disabled
                });
                return _react2.default.createElement(Option, {
                    className: optionClass,
                    focusOption: focusOption,
                    inputValue: inputValue,
                    instancePrefix: instancePrefix,
                    isDisabled: option.disabled,
                    isFocused: isFocused,
                    isSelected: isSelected,
                    key: "option-" + i + "-" + option[valueKey],
                    onFocus: onFocus,
                    onSelect: onSelect,
                    option: option,
                    optionIndex: i,
                    ref: function(_ref2) {
                        onOptionRef(_ref2, isFocused);
                    },
                    removeValue: removeValue,
                    selectValue: selectValue
                }, optionRenderer(option, i, inputValue));
            });
        };
        menuRenderer.propTypes = {
            focusOption: _propTypes2.default.func,
            focusedOption: _propTypes2.default.object,
            inputValue: _propTypes2.default.string,
            instancePrefix: _propTypes2.default.string,
            onFocus: _propTypes2.default.func,
            onOptionRef: _propTypes2.default.func,
            onSelect: _propTypes2.default.func,
            optionClassName: _propTypes2.default.string,
            optionComponent: _propTypes2.default.func,
            optionRenderer: _propTypes2.default.func,
            options: _propTypes2.default.array,
            removeValue: _propTypes2.default.func,
            selectValue: _propTypes2.default.func,
            valueArray: _propTypes2.default.array,
            valueKey: _propTypes2.default.string
        }, exports.default = menuRenderer;
    }, /* 159 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _blockEvent = __webpack_require__(160), _blockEvent2 = _interopRequireDefault(_blockEvent), Option = function(_React$Component) {
            function Option(props) {
                _classCallCheck(this, Option);
                var _this = _possibleConstructorReturn(this, (Option.__proto__ || Object.getPrototypeOf(Option)).call(this, props));
                return _this.handleMouseDown = _this.handleMouseDown.bind(_this), _this.handleMouseEnter = _this.handleMouseEnter.bind(_this), 
                _this.handleMouseMove = _this.handleMouseMove.bind(_this), _this.handleTouchStart = _this.handleTouchStart.bind(_this), 
                _this.handleTouchEnd = _this.handleTouchEnd.bind(_this), _this.handleTouchMove = _this.handleTouchMove.bind(_this), 
                _this.onFocus = _this.onFocus.bind(_this), _this;
            }
            return _inherits(Option, _React$Component), _createClass(Option, [ {
                key: "handleMouseDown",
                value: function(event) {
                    event.preventDefault(), event.stopPropagation(), this.props.onSelect(this.props.option, event);
                }
            }, {
                key: "handleMouseEnter",
                value: function(event) {
                    this.onFocus(event);
                }
            }, {
                key: "handleMouseMove",
                value: function(event) {
                    this.onFocus(event);
                }
            }, {
                key: "handleTouchEnd",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || this.handleMouseDown(event);
                }
            }, {
                key: "handleTouchMove",
                value: function() {
                    // Set a flag that the view is being dragged
                    this.dragging = !0;
                }
            }, {
                key: "handleTouchStart",
                value: function() {
                    // Set a flag that the view is not being dragged
                    this.dragging = !1;
                }
            }, {
                key: "onFocus",
                value: function(event) {
                    this.props.isFocused || this.props.onFocus(this.props.option, event);
                }
            }, {
                key: "render",
                value: function() {
                    var _props = this.props, option = _props.option, instancePrefix = _props.instancePrefix, optionIndex = _props.optionIndex, className = (0, 
                    _classnames2.default)(this.props.className, option.className);
                    return option.disabled ? _react2.default.createElement("div", {
                        className: className,
                        onMouseDown: _blockEvent2.default,
                        onClick: _blockEvent2.default
                    }, this.props.children) : _react2.default.createElement("div", {
                        className: className,
                        style: option.style,
                        role: "option",
                        "aria-label": option.label,
                        onMouseDown: this.handleMouseDown,
                        onMouseEnter: this.handleMouseEnter,
                        onMouseMove: this.handleMouseMove,
                        onTouchStart: this.handleTouchStart,
                        onTouchMove: this.handleTouchMove,
                        onTouchEnd: this.handleTouchEnd,
                        id: instancePrefix + "-option-" + optionIndex,
                        title: option.title
                    }, this.props.children);
                }
            } ]), Option;
        }(_react2.default.Component);
        Option.propTypes = {
            children: _propTypes2.default.node,
            className: _propTypes2.default.string,
            // className (based on mouse position)
            instancePrefix: _propTypes2.default.string.isRequired,
            // unique prefix for the ids (used for aria)
            isDisabled: _propTypes2.default.bool,
            // the option is disabled
            isFocused: _propTypes2.default.bool,
            // the option is focused
            isSelected: _propTypes2.default.bool,
            // the option is selected
            onFocus: _propTypes2.default.func,
            // method to handle mouseEnter on option element
            onSelect: _propTypes2.default.func,
            // method to handle click on option element
            onUnfocus: _propTypes2.default.func,
            // method to handle mouseLeave on option element
            option: _propTypes2.default.object.isRequired,
            // object that is base for that option
            optionIndex: _propTypes2.default.number
        }, exports.default = Option;
    }, /* 160 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(event) {
            event.preventDefault(), event.stopPropagation(), "A" === event.target.tagName && "href" in event.target && (event.target.target ? window.open(event.target.href, event.target.target) : window.location.href = event.target.href);
        };
    }, /* 161 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _classnames = __webpack_require__(121), _classnames2 = _interopRequireDefault(_classnames), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), Value = function(_React$Component) {
            function Value(props) {
                _classCallCheck(this, Value);
                var _this = _possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).call(this, props));
                return _this.handleMouseDown = _this.handleMouseDown.bind(_this), _this.onRemove = _this.onRemove.bind(_this), 
                _this.handleTouchEndRemove = _this.handleTouchEndRemove.bind(_this), _this.handleTouchMove = _this.handleTouchMove.bind(_this), 
                _this.handleTouchStart = _this.handleTouchStart.bind(_this), _this;
            }
            return _inherits(Value, _React$Component), _createClass(Value, [ {
                key: "handleMouseDown",
                value: function(event) {
                    if ("mousedown" !== event.type || 0 === event.button) return this.props.onClick ? (event.stopPropagation(), 
                    void this.props.onClick(this.props.value, event)) : void (this.props.value.href && event.stopPropagation());
                }
            }, {
                key: "onRemove",
                value: function(event) {
                    event.preventDefault(), event.stopPropagation(), this.props.onRemove(this.props.value);
                }
            }, {
                key: "handleTouchEndRemove",
                value: function(event) {
                    // Check if the view is being dragged, In this case
                    // we don't want to fire the click event (because the user only wants to scroll)
                    this.dragging || // Fire the mouse events
                    this.onRemove(event);
                }
            }, {
                key: "handleTouchMove",
                value: function() {
                    // Set a flag that the view is being dragged
                    this.dragging = !0;
                }
            }, {
                key: "handleTouchStart",
                value: function() {
                    // Set a flag that the view is not being dragged
                    this.dragging = !1;
                }
            }, {
                key: "renderRemoveIcon",
                value: function() {
                    if (!this.props.disabled && this.props.onRemove) return _react2.default.createElement("span", {
                        className: "Select-value-icon",
                        "aria-hidden": "true",
                        onMouseDown: this.onRemove,
                        onTouchEnd: this.handleTouchEndRemove,
                        onTouchStart: this.handleTouchStart,
                        onTouchMove: this.handleTouchMove
                    }, "×");
                }
            }, {
                key: "renderLabel",
                value: function() {
                    var className = "Select-value-label";
                    return this.props.onClick || this.props.value.href ? _react2.default.createElement("a", {
                        className: className,
                        href: this.props.value.href,
                        target: this.props.value.target,
                        onMouseDown: this.handleMouseDown,
                        onTouchEnd: this.handleMouseDown
                    }, this.props.children) : _react2.default.createElement("span", {
                        className: className,
                        role: "option",
                        "aria-selected": "true",
                        id: this.props.id
                    }, this.props.children);
                }
            }, {
                key: "render",
                value: function() {
                    return _react2.default.createElement("div", {
                        className: (0, _classnames2.default)("Select-value", this.props.value.disabled ? "Select-value-disabled" : "", this.props.value.className),
                        style: this.props.value.style,
                        title: this.props.value.title
                    }, this.renderRemoveIcon(), this.renderLabel());
                }
            } ]), Value;
        }(_react2.default.Component);
        Value.propTypes = {
            children: _propTypes2.default.node,
            disabled: _propTypes2.default.bool,
            // disabled prop passed to ReactSelect
            id: _propTypes2.default.string,
            // Unique id for the value - used for aria
            onClick: _propTypes2.default.func,
            // method to handle click on value label
            onRemove: _propTypes2.default.func,
            // method to handle removal of the value
            value: _propTypes2.default.object.isRequired
        }, exports.default = Value;
    }, /* 162 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _Select = __webpack_require__(151), _Select2 = _interopRequireDefault(_Select), _stripDiacritics = __webpack_require__(156), _stripDiacritics2 = _interopRequireDefault(_stripDiacritics), propTypes = {
            autoload: _propTypes2.default.bool.isRequired,
            // automatically call the `loadOptions` prop on-mount; defaults to true
            cache: _propTypes2.default.any,
            // object to use to cache results; set to null/false to disable caching
            children: _propTypes2.default.func.isRequired,
            // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
            ignoreAccents: _propTypes2.default.bool,
            // strip diacritics when filtering; defaults to true
            ignoreCase: _propTypes2.default.bool,
            // perform case-insensitive filtering; defaults to true
            loadOptions: _propTypes2.default.func.isRequired,
            // callback to load options asynchronously; (inputValue: string, callback: Function): ?Promise
            loadingPlaceholder: _propTypes2.default.oneOfType([ // replaces the placeholder while options are loading
            _propTypes2.default.string, _propTypes2.default.node ]),
            multi: _propTypes2.default.bool,
            // multi-value input
            noResultsText: _propTypes2.default.oneOfType([ // field noResultsText, displayed when no options come back from the server
            _propTypes2.default.string, _propTypes2.default.node ]),
            onChange: _propTypes2.default.func,
            // onChange handler: function (newValue) {}
            onInputChange: _propTypes2.default.func,
            // optional for keeping track of what is being typed
            options: _propTypes2.default.array.isRequired,
            // array of options
            placeholder: _propTypes2.default.oneOfType([ // field placeholder, displayed when there's no value (shared with Select)
            _propTypes2.default.string, _propTypes2.default.node ]),
            searchPromptText: _propTypes2.default.oneOfType([ // label to prompt for search input
            _propTypes2.default.string, _propTypes2.default.node ]),
            value: _propTypes2.default.any
        }, defaultCache = {}, defaultChildren = function(props) {
            return _react2.default.createElement(_Select2.default, props);
        }, defaultProps = {
            autoload: !0,
            cache: defaultCache,
            children: defaultChildren,
            ignoreAccents: !0,
            ignoreCase: !0,
            loadingPlaceholder: "Loading...",
            options: [],
            searchPromptText: "Type to search"
        }, Async = function(_Component) {
            function Async(props, context) {
                _classCallCheck(this, Async);
                var _this = _possibleConstructorReturn(this, (Async.__proto__ || Object.getPrototypeOf(Async)).call(this, props, context));
                return _this._cache = props.cache === defaultCache ? {} : props.cache, _this.state = {
                    inputValue: "",
                    isLoading: !1,
                    options: props.options
                }, _this.onInputChange = _this.onInputChange.bind(_this), _this;
            }
            return _inherits(Async, _Component), _createClass(Async, [ {
                key: "componentDidMount",
                value: function() {
                    var autoload = this.props.autoload;
                    autoload && this.loadOptions("");
                }
            }, {
                key: "componentWillReceiveProps",
                value: function(nextProps) {
                    nextProps.options !== this.props.options && this.setState({
                        options: nextProps.options
                    });
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this._callback = null;
                }
            }, {
                key: "loadOptions",
                value: function loadOptions(inputValue) {
                    var _this2 = this, loadOptions = this.props.loadOptions, cache = this._cache;
                    if (cache && Object.prototype.hasOwnProperty.call(cache, inputValue)) return this._callback = null, 
                    void this.setState({
                        isLoading: !1,
                        options: cache[inputValue]
                    });
                    var callback = function callback(error, data) {
                        var options = data && data.options || [];
                        cache && (cache[inputValue] = options), callback === _this2._callback && (_this2._callback = null, 
                        _this2.setState({
                            isLoading: !1,
                            options: options
                        }));
                    };
                    // Ignore all but the most recent request
                    this._callback = callback;
                    var promise = loadOptions(inputValue, callback);
                    promise && promise.then(function(data) {
                        return callback(null, data);
                    }, function(error) {
                        return callback(error);
                    }), this._callback && !this.state.isLoading && this.setState({
                        isLoading: !0
                    });
                }
            }, {
                key: "onInputChange",
                value: function onInputChange(inputValue) {
                    var _props = this.props, ignoreAccents = _props.ignoreAccents, ignoreCase = _props.ignoreCase, onInputChange = _props.onInputChange, newInputValue = inputValue;
                    if (onInputChange) {
                        var value = onInputChange(newInputValue);
                        // Note: != used deliberately here to catch undefined and null
                        null != value && "object" !== ("undefined" == typeof value ? "undefined" : _typeof(value)) && (newInputValue = "" + value);
                    }
                    var transformedInputValue = newInputValue;
                    // Return new input value, but without applying toLowerCase() to avoid modifying the user's view case of the input while typing.
                    return ignoreAccents && (transformedInputValue = (0, _stripDiacritics2.default)(transformedInputValue)), 
                    ignoreCase && (transformedInputValue = transformedInputValue.toLowerCase()), this.setState({
                        inputValue: newInputValue
                    }), this.loadOptions(transformedInputValue), newInputValue;
                }
            }, {
                key: "noResultsText",
                value: function noResultsText() {
                    var _props2 = this.props, loadingPlaceholder = _props2.loadingPlaceholder, noResultsText = _props2.noResultsText, searchPromptText = _props2.searchPromptText, _state = this.state, inputValue = _state.inputValue, isLoading = _state.isLoading;
                    return isLoading ? loadingPlaceholder : inputValue && noResultsText ? noResultsText : searchPromptText;
                }
            }, {
                key: "focus",
                value: function() {
                    this.select.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var _this3 = this, _props3 = this.props, children = _props3.children, loadingPlaceholder = _props3.loadingPlaceholder, placeholder = _props3.placeholder, _state2 = this.state, isLoading = _state2.isLoading, options = _state2.options, props = {
                        noResultsText: this.noResultsText(),
                        placeholder: isLoading ? loadingPlaceholder : placeholder,
                        options: isLoading && loadingPlaceholder ? [] : options,
                        ref: function(_ref) {
                            return _this3.select = _ref;
                        }
                    };
                    return children(_extends({}, this.props, props, {
                        isLoading: isLoading,
                        onInputChange: this.onInputChange
                    }));
                }
            } ]), Async;
        }(_react.Component);
        exports.default = Async, Async.propTypes = propTypes, Async.defaultProps = defaultProps;
    }, /* 163 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _Async = __webpack_require__(162), _Async2 = _interopRequireDefault(_Async), _Creatable = __webpack_require__(164), _Creatable2 = _interopRequireDefault(_Creatable), _Select = __webpack_require__(151), _Select2 = _interopRequireDefault(_Select), AsyncCreatableSelect = function(_React$Component) {
            function AsyncCreatableSelect() {
                return _classCallCheck(this, AsyncCreatableSelect), _possibleConstructorReturn(this, (AsyncCreatableSelect.__proto__ || Object.getPrototypeOf(AsyncCreatableSelect)).apply(this, arguments));
            }
            return _inherits(AsyncCreatableSelect, _React$Component), _createClass(AsyncCreatableSelect, [ {
                key: "focus",
                value: function() {
                    this.select.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this;
                    return _react2.default.createElement(_Async2.default, this.props, function(_ref) {
                        var ref = _ref.ref, asyncProps = _objectWithoutProperties(_ref, [ "ref" ]), asyncRef = ref;
                        return _react2.default.createElement(_Creatable2.default, asyncProps, function(_ref2) {
                            var ref = _ref2.ref, creatableProps = _objectWithoutProperties(_ref2, [ "ref" ]), creatableRef = ref;
                            return _this2.props.children(_extends({}, creatableProps, {
                                ref: function(select) {
                                    creatableRef(select), asyncRef(select), _this2.select = select;
                                }
                            }));
                        });
                    });
                }
            } ]), AsyncCreatableSelect;
        }(_react2.default.Component), defaultChildren = function(props) {
            return _react2.default.createElement(_Select2.default, props);
        };
        AsyncCreatableSelect.propTypes = {
            children: _propTypes2.default.func.isRequired
        }, AsyncCreatableSelect.defaultProps = {
            children: defaultChildren
        }, exports.default = AsyncCreatableSelect;
    }, /* 164 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _defaultFilterOptions = __webpack_require__(155), _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions), _defaultMenuRenderer = __webpack_require__(158), _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer), _Select = __webpack_require__(151), _Select2 = _interopRequireDefault(_Select), CreatableSelect = function(_React$Component) {
            function CreatableSelect(props, context) {
                _classCallCheck(this, CreatableSelect);
                var _this = _possibleConstructorReturn(this, (CreatableSelect.__proto__ || Object.getPrototypeOf(CreatableSelect)).call(this, props, context));
                return _this.filterOptions = _this.filterOptions.bind(_this), _this.menuRenderer = _this.menuRenderer.bind(_this), 
                _this.onInputKeyDown = _this.onInputKeyDown.bind(_this), _this.onInputChange = _this.onInputChange.bind(_this), 
                _this.onOptionSelect = _this.onOptionSelect.bind(_this), _this;
            }
            return _inherits(CreatableSelect, _React$Component), _createClass(CreatableSelect, [ {
                key: "createNewOption",
                value: function() {
                    var _props = this.props, isValidNewOption = _props.isValidNewOption, newOptionCreator = _props.newOptionCreator, onNewOptionClick = _props.onNewOptionClick, _props$options = _props.options, options = void 0 === _props$options ? [] : _props$options;
                    if (isValidNewOption({
                        label: this.inputValue
                    })) {
                        var option = newOptionCreator({
                            label: this.inputValue,
                            labelKey: this.labelKey,
                            valueKey: this.valueKey
                        }), _isOptionUnique = this.isOptionUnique({
                            option: option,
                            options: options
                        });
                        // Don't add the same option twice.
                        _isOptionUnique && (onNewOptionClick ? onNewOptionClick(option) : (options.unshift(option), 
                        this.select.selectValue(option)));
                    }
                }
            }, {
                key: "filterOptions",
                value: function filterOptions() {
                    var _props2 = this.props, filterOptions = _props2.filterOptions, isValidNewOption = _props2.isValidNewOption, promptTextCreator = _props2.promptTextCreator, showNewOptionAtTop = _props2.showNewOptionAtTop, excludeOptions = (arguments.length <= 2 ? void 0 : arguments[2]) || [], filteredOptions = filterOptions.apply(void 0, arguments) || [];
                    if (isValidNewOption({
                        label: this.inputValue
                    })) {
                        var _newOptionCreator = this.props.newOptionCreator, option = _newOptionCreator({
                            label: this.inputValue,
                            labelKey: this.labelKey,
                            valueKey: this.valueKey
                        }), _isOptionUnique2 = this.isOptionUnique({
                            option: option,
                            options: excludeOptions.concat(filteredOptions)
                        });
                        if (_isOptionUnique2) {
                            var prompt = promptTextCreator(this.inputValue);
                            this._createPlaceholderOption = _newOptionCreator({
                                label: prompt,
                                labelKey: this.labelKey,
                                valueKey: this.valueKey
                            }), showNewOptionAtTop ? filteredOptions.unshift(this._createPlaceholderOption) : filteredOptions.push(this._createPlaceholderOption);
                        }
                    }
                    return filteredOptions;
                }
            }, {
                key: "isOptionUnique",
                value: function isOptionUnique(_ref) {
                    var option = _ref.option, options = _ref.options, isOptionUnique = this.props.isOptionUnique;
                    return options = options || this.props.options, isOptionUnique({
                        labelKey: this.labelKey,
                        option: option,
                        options: options,
                        valueKey: this.valueKey
                    });
                }
            }, {
                key: "menuRenderer",
                value: function menuRenderer(params) {
                    var menuRenderer = this.props.menuRenderer;
                    return menuRenderer(_extends({}, params, {
                        onSelect: this.onOptionSelect,
                        selectValue: this.onOptionSelect
                    }));
                }
            }, {
                key: "onInputChange",
                value: function onInputChange(input) {
                    var onInputChange = this.props.onInputChange;
                    // This value may be needed in between Select mounts (when this.select is null)
                    return this.inputValue = input, onInputChange && (this.inputValue = onInputChange(input)), 
                    this.inputValue;
                }
            }, {
                key: "onInputKeyDown",
                value: function onInputKeyDown(event) {
                    var _props3 = this.props, shouldKeyDownEventCreateNewOption = _props3.shouldKeyDownEventCreateNewOption, onInputKeyDown = _props3.onInputKeyDown, focusedOption = this.select.getFocusedOption();
                    focusedOption && focusedOption === this._createPlaceholderOption && shouldKeyDownEventCreateNewOption(event) ? (this.createNewOption(), 
                    // Prevent decorated Select from doing anything additional with this keyDown event
                    event.preventDefault()) : onInputKeyDown && onInputKeyDown(event);
                }
            }, {
                key: "onOptionSelect",
                value: function(option) {
                    option === this._createPlaceholderOption ? this.createNewOption() : this.select.selectValue(option);
                }
            }, {
                key: "focus",
                value: function() {
                    this.select.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, _props4 = this.props, refProp = _props4.ref, restProps = _objectWithoutProperties(_props4, [ "ref" ]), children = this.props.children;
                    // We can't use destructuring default values to set the children,
                    // because it won't apply work if `children` is null. A falsy check is
                    // more reliable in real world use-cases.
                    children || (children = defaultChildren);
                    var props = _extends({}, restProps, {
                        allowCreate: !0,
                        filterOptions: this.filterOptions,
                        menuRenderer: this.menuRenderer,
                        onInputChange: this.onInputChange,
                        onInputKeyDown: this.onInputKeyDown,
                        ref: function(_ref2) {
                            _this2.select = _ref2, // These values may be needed in between Select mounts (when this.select is null)
                            _ref2 && (_this2.labelKey = _ref2.props.labelKey, _this2.valueKey = _ref2.props.valueKey), 
                            refProp && refProp(_ref2);
                        }
                    });
                    return children(props);
                }
            } ]), CreatableSelect;
        }(_react2.default.Component), defaultChildren = function(props) {
            return _react2.default.createElement(_Select2.default, props);
        }, isOptionUnique = function(_ref3) {
            var option = _ref3.option, options = _ref3.options, labelKey = _ref3.labelKey, valueKey = _ref3.valueKey;
            return !options || !options.length || 0 === options.filter(function(existingOption) {
                return existingOption[labelKey] === option[labelKey] || existingOption[valueKey] === option[valueKey];
            }).length;
        }, isValidNewOption = function(_ref4) {
            var label = _ref4.label;
            return !!label;
        }, newOptionCreator = function(_ref5) {
            var label = _ref5.label, labelKey = _ref5.labelKey, valueKey = _ref5.valueKey, option = {};
            return option[valueKey] = label, option[labelKey] = label, option.className = "Select-create-option-placeholder", 
            option;
        }, promptTextCreator = function(label) {
            return 'Create option "' + label + '"';
        }, shouldKeyDownEventCreateNewOption = function(_ref6) {
            var keyCode = _ref6.keyCode;
            switch (keyCode) {
              case 9:
              // TAB
                case 13:
              // ENTER
                case 188:
                // COMMA
                return !0;

              default:
                return !1;
            }
        };
        // Default prop methods
        CreatableSelect.isOptionUnique = isOptionUnique, CreatableSelect.isValidNewOption = isValidNewOption, 
        CreatableSelect.newOptionCreator = newOptionCreator, CreatableSelect.promptTextCreator = promptTextCreator, 
        CreatableSelect.shouldKeyDownEventCreateNewOption = shouldKeyDownEventCreateNewOption, 
        CreatableSelect.defaultProps = {
            filterOptions: _defaultFilterOptions2.default,
            isOptionUnique: isOptionUnique,
            isValidNewOption: isValidNewOption,
            menuRenderer: _defaultMenuRenderer2.default,
            newOptionCreator: newOptionCreator,
            promptTextCreator: promptTextCreator,
            shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption,
            showNewOptionAtTop: !0
        }, CreatableSelect.propTypes = {
            // Child function responsible for creating the inner Select component
            // This component can be used to compose HOCs (eg Creatable and Async)
            // (props: Object): PropTypes.element
            children: _propTypes2.default.func,
            // See Select.propTypes.filterOptions
            filterOptions: _propTypes2.default.any,
            // Searches for any matching option within the set of options.
            // This function prevents duplicate options from being created.
            // ({ option: Object, options: Array, labelKey: string, valueKey: string }): boolean
            isOptionUnique: _propTypes2.default.func,
            // Determines if the current input text represents a valid option.
            // ({ label: string }): boolean
            isValidNewOption: _propTypes2.default.func,
            // See Select.propTypes.menuRenderer
            menuRenderer: _propTypes2.default.any,
            // Factory to create new option.
            // ({ label: string, labelKey: string, valueKey: string }): Object
            newOptionCreator: _propTypes2.default.func,
            // input change handler: function (inputValue) {}
            onInputChange: _propTypes2.default.func,
            // input keyDown handler: function (event) {}
            onInputKeyDown: _propTypes2.default.func,
            // new option click handler: function (option) {}
            onNewOptionClick: _propTypes2.default.func,
            // See Select.propTypes.options
            options: _propTypes2.default.array,
            // Creates prompt/placeholder option text.
            // (filterText: string): string
            promptTextCreator: _propTypes2.default.func,
            ref: _propTypes2.default.func,
            // Decides if a keyDown event (eg its `keyCode`) should result in the creation of a new option.
            shouldKeyDownEventCreateNewOption: _propTypes2.default.func,
            // Where to show prompt/placeholder option text.
            // true: new option prompt at top of list (default)
            // false: new option prompt at bottom of list
            showNewOptionAtTop: _propTypes2.default.bool
        }, exports.default = CreatableSelect;
    }, /* 165 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequireDefault = __webpack_require__(166);
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _AutoSizer.default;
            }
        }), Object.defineProperty(exports, "AutoSizer", {
            enumerable: !0,
            get: function() {
                return _AutoSizer.default;
            }
        });
        var _AutoSizer = _interopRequireDefault(__webpack_require__(167));
    }, /* 166 */
    /***/
    function(module, exports) {
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        module.exports = _interopRequireDefault;
    }, /* 167 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    enumerableOnly && (symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    })), keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    i % 2 ? ownKeys(source, !0).forEach(function(key) {
                        (0, _defineProperty2.default)(target, key, source[key]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                }
                return target;
            }
            var _interopRequireDefault = __webpack_require__(166), _interopRequireWildcard = __webpack_require__(168);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _class, _temp, _classCallCheck2 = _interopRequireDefault(__webpack_require__(170)), _createClass2 = _interopRequireDefault(__webpack_require__(171)), _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(172)), _getPrototypeOf3 = _interopRequireDefault(__webpack_require__(174)), _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(173)), _inherits2 = _interopRequireDefault(__webpack_require__(175)), _defineProperty2 = _interopRequireDefault(__webpack_require__(177)), React = _interopRequireWildcard(__webpack_require__(108)), _detectElementResize = _interopRequireDefault(__webpack_require__(178)), _propTypes = _interopRequireDefault(__webpack_require__(109)), AutoSizer = (_temp = _class = /*#__PURE__*/
            function(_React$Component) {
                function AutoSizer() {
                    var _getPrototypeOf2, _this;
                    (0, _classCallCheck2.default)(this, AutoSizer);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, 
                    _getPrototypeOf3.default)(AutoSizer)).call.apply(_getPrototypeOf2, [ this ].concat(args))), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", {
                        height: _this.props.defaultHeight || 0,
                        width: _this.props.defaultWidth || 0
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_parentNode", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_autoSizer", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_window", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_detectElementResize", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onResize", function() {
                        var _this$props = _this.props, disableHeight = _this$props.disableHeight, disableWidth = _this$props.disableWidth, onResize = _this$props.onResize;
                        if (_this._parentNode) {
                            // Guard against AutoSizer component being removed from the DOM immediately after being added.
                            // This can result in invalid style values which can result in NaN values if we don't handle them.
                            // See issue #150 for more context.
                            var height = _this._parentNode.offsetHeight || 0, width = _this._parentNode.offsetWidth || 0, win = _this._window || window, style = win.getComputedStyle(_this._parentNode) || {}, paddingLeft = parseInt(style.paddingLeft, 10) || 0, paddingRight = parseInt(style.paddingRight, 10) || 0, paddingTop = parseInt(style.paddingTop, 10) || 0, paddingBottom = parseInt(style.paddingBottom, 10) || 0, newHeight = height - paddingTop - paddingBottom, newWidth = width - paddingLeft - paddingRight;
                            (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) && (_this.setState({
                                height: height - paddingTop - paddingBottom,
                                width: width - paddingLeft - paddingRight
                            }), onResize({
                                height: height,
                                width: width
                            }));
                        }
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_setRef", function(autoSizer) {
                        _this._autoSizer = autoSizer;
                    }), _this;
                }
                return (0, _inherits2.default)(AutoSizer, _React$Component), (0, _createClass2.default)(AutoSizer, [ {
                    key: "componentDidMount",
                    value: function() {
                        var nonce = this.props.nonce;
                        this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement && (// Delay access of parentNode until mount.
                        // This handles edge-cases where the component has already been unmounted before its ref has been set,
                        // As well as libraries like react-lite which have a slightly different lifecycle.
                        this._parentNode = this._autoSizer.parentNode, this._window = this._autoSizer.parentNode.ownerDocument.defaultView, 
                        // Defer requiring resize handler in order to support server-side rendering.
                        // See issue #41
                        this._detectElementResize = (0, _detectElementResize.default)(nonce, this._window), 
                        this._detectElementResize.addResizeListener(this._parentNode, this._onResize), this._onResize());
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function() {
                        this._detectElementResize && this._parentNode && this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
                    }
                }, {
                    key: "render",
                    value: function() {
                        var _this$props2 = this.props, children = _this$props2.children, className = _this$props2.className, disableHeight = _this$props2.disableHeight, disableWidth = _this$props2.disableWidth, style = _this$props2.style, _this$state = this.state, height = _this$state.height, width = _this$state.width, outerStyle = {
                            overflow: "visible"
                        }, childParams = {};
                        /**
	       * TODO: Avoid rendering children before the initial measurements have been collected.
	       * At best this would just be wasting cycles.
	       * Add this check into version 10 though as it could break too many ref callbacks in version 9.
	       * Note that if default width/height props were provided this would still work with SSR.
	      if (
	        height !== 0 &&
	        width !== 0
	      ) {
	        child = children({ height, width })
	      }
	      */
                        return disableHeight || (outerStyle.height = 0, childParams.height = height), disableWidth || (outerStyle.width = 0, 
                        childParams.width = width), React.createElement("div", {
                            className: className,
                            ref: this._setRef,
                            style: _objectSpread({}, outerStyle, {}, style)
                        }, children(childParams));
                    }
                } ]), AutoSizer;
            }(React.Component), (0, _defineProperty2.default)(_class, "propTypes", "production" === process.env.NODE_ENV ? null : {
                /** Function responsible for rendering children.*/
                children: _propTypes.default.func.isRequired,
                /** Optional custom CSS class name to attach to root AutoSizer element.  */
                className: _propTypes.default.string,
                /** Default height to use for initial render; useful for SSR */
                defaultHeight: _propTypes.default.number,
                /** Default width to use for initial render; useful for SSR */
                defaultWidth: _propTypes.default.number,
                /** Disable dynamic :height property */
                disableHeight: _propTypes.default.bool.isRequired,
                /** Disable dynamic :width property */
                disableWidth: _propTypes.default.bool.isRequired,
                /** Nonce of the inlined stylesheet for Content Security Policy */
                nonce: _propTypes.default.string,
                /** Callback to be invoked on-resize */
                onResize: _propTypes.default.func.isRequired,
                /** Optional inline style */
                style: _propTypes.default.object
            }), _temp);
            exports.default = AutoSizer, (0, _defineProperty2.default)(AutoSizer, "defaultProps", {
                onResize: function() {},
                disableHeight: !1,
                disableWidth: !1,
                style: {}
            });
        }).call(exports, __webpack_require__(110));
    }, /* 168 */
    /***/
    function(module, exports, __webpack_require__) {
        function _getRequireWildcardCache() {
            if ("function" != typeof WeakMap) return null;
            var cache = new WeakMap();
            return _getRequireWildcardCache = function() {
                return cache;
            }, cache;
        }
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) return obj;
            if (null === obj || "object" !== _typeof(obj) && "function" != typeof obj) return {
                default: obj
            };
            var cache = _getRequireWildcardCache();
            if (cache && cache.has(obj)) return cache.get(obj);
            var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
            }
            return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
        }
        var _typeof = __webpack_require__(169);
        module.exports = _interopRequireWildcard;
    }, /* 169 */
    /***/
    function(module, exports) {
        function _typeof(obj) {
            "@babel/helpers - typeof";
            return "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? module.exports = _typeof = function(obj) {
                return typeof obj;
            } : module.exports = _typeof = function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _typeof(obj);
        }
        module.exports = _typeof;
    }, /* 170 */
    /***/
    function(module, exports) {
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        module.exports = _classCallCheck;
    }, /* 171 */
    /***/
    function(module, exports) {
        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        function _createClass(Constructor, protoProps, staticProps) {
            return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
            Constructor;
        }
        module.exports = _createClass;
    }, /* 172 */
    /***/
    function(module, exports, __webpack_require__) {
        function _possibleConstructorReturn(self, call) {
            return !call || "object" !== _typeof(call) && "function" != typeof call ? assertThisInitialized(self) : call;
        }
        var _typeof = __webpack_require__(169), assertThisInitialized = __webpack_require__(173);
        module.exports = _possibleConstructorReturn;
    }, /* 173 */
    /***/
    function(module, exports) {
        function _assertThisInitialized(self) {
            if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return self;
        }
        module.exports = _assertThisInitialized;
    }, /* 174 */
    /***/
    function(module, exports) {
        function _getPrototypeOf(o) {
            return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            }, _getPrototypeOf(o);
        }
        module.exports = _getPrototypeOf;
    }, /* 175 */
    /***/
    function(module, exports, __webpack_require__) {
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && setPrototypeOf(subClass, superClass);
        }
        var setPrototypeOf = __webpack_require__(176);
        module.exports = _inherits;
    }, /* 176 */
    /***/
    function(module, exports) {
        function _setPrototypeOf(o, p) {
            return module.exports = _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
                return o.__proto__ = p, o;
            }, _setPrototypeOf(o, p);
        }
        module.exports = _setPrototypeOf;
    }, /* 177 */
    /***/
    function(module, exports) {
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        module.exports = _defineProperty;
    }, /* 178 */
    /***/
    function(module, exports) {
        /* WEBPACK VAR INJECTION */
        (function(global) {
            "use strict";
            /**
	 * Detect Element Resize.
	 * https://github.com/sdecima/javascript-detect-element-resize
	 * Sebastian Decima
	 *
	 * Forked from version 0.5.3; includes the following modifications:
	 * 1) Guard against unsafe 'window' and 'document' references (to support SSR).
	 * 2) Defer initialization code via a top-level function wrapper (to support SSR).
	 * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
	 * 4) Add nonce for style element.
	 * 5) Added support for injecting custom window object
	 **/
            function createDetectElementResize(nonce, hostWindow) {
                // Check `document` and `window` in case of server-side rendering
                var _window;
                _window = "undefined" != typeof hostWindow ? hostWindow : "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
                var attachEvent = "undefined" != typeof _window.document && _window.document.attachEvent;
                if (!attachEvent) {
                    var requestFrame = function() {
                        var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function(fn) {
                            return _window.setTimeout(fn, 20);
                        };
                        return function(fn) {
                            return raf(fn);
                        };
                    }(), cancelFrame = function() {
                        var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
                        return function(id) {
                            return cancel(id);
                        };
                    }(), resetTriggers = function(element) {
                        var triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
                        contract.scrollLeft = contract.scrollWidth, contract.scrollTop = contract.scrollHeight, 
                        expandChild.style.width = expand.offsetWidth + 1 + "px", expandChild.style.height = expand.offsetHeight + 1 + "px", 
                        expand.scrollLeft = expand.scrollWidth, expand.scrollTop = expand.scrollHeight;
                    }, checkTriggers = function(element) {
                        return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
                    }, scrollListener = function(e) {
                        // Don't measure (which forces) reflow for scrolls that happen inside of children!
                        if (!(e.target.className && "function" == typeof e.target.className.indexOf && e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0)) {
                            var element = this;
                            resetTriggers(this), this.__resizeRAF__ && cancelFrame(this.__resizeRAF__), this.__resizeRAF__ = requestFrame(function() {
                                checkTriggers(element) && (element.__resizeLast__.width = element.offsetWidth, element.__resizeLast__.height = element.offsetHeight, 
                                element.__resizeListeners__.forEach(function(fn) {
                                    fn.call(element, e);
                                }));
                            });
                        }
                    }, animation = !1, keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), pfx = "", elm = _window.document.createElement("fakeelement");
                    if (void 0 !== elm.style.animationName && (animation = !0), animation === !1) for (var i = 0; i < domPrefixes.length; i++) if (void 0 !== elm.style[domPrefixes[i] + "AnimationName"]) {
                        pfx = domPrefixes[i], keyframeprefix = "-" + pfx.toLowerCase() + "-", animationstartevent = startEvents[i], 
                        animation = !0;
                        break;
                    }
                    var animationName = "resizeanim", animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ", animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
                }
                var createStyles = function(doc) {
                    if (!doc.getElementById("detectElementResize")) {
                        //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
                        var css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style = doc.createElement("style");
                        style.id = "detectElementResize", style.type = "text/css", null != nonce && style.setAttribute("nonce", nonce), 
                        style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(doc.createTextNode(css)), 
                        head.appendChild(style);
                    }
                }, addResizeListener = function(element, fn) {
                    if (attachEvent) element.attachEvent("onresize", fn); else {
                        if (!element.__resizeTriggers__) {
                            var doc = element.ownerDocument, elementStyle = _window.getComputedStyle(element);
                            elementStyle && "static" == elementStyle.position && (element.style.position = "relative"), 
                            createStyles(doc), element.__resizeLast__ = {}, element.__resizeListeners__ = [], 
                            (element.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers", 
                            element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', 
                            element.appendChild(element.__resizeTriggers__), resetTriggers(element), element.addEventListener("scroll", scrollListener, !0), 
                            /* Listen for a css animation to detect element display/re-attach */
                            animationstartevent && (element.__resizeTriggers__.__animationListener__ = function(e) {
                                e.animationName == animationName && resetTriggers(element);
                            }, element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__));
                        }
                        element.__resizeListeners__.push(fn);
                    }
                }, removeResizeListener = function(element, fn) {
                    if (attachEvent) element.detachEvent("onresize", fn); else if (element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1), 
                    !element.__resizeListeners__.length) {
                        element.removeEventListener("scroll", scrollListener, !0), element.__resizeTriggers__.__animationListener__ && (element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__), 
                        element.__resizeTriggers__.__animationListener__ = null);
                        try {
                            element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
                        } catch (e) {}
                    }
                };
                return {
                    addResizeListener: addResizeListener,
                    removeResizeListener: removeResizeListener
                };
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = createDetectElementResize;
        }).call(exports, function() {
            return this;
        }());
    }, /* 179 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequireDefault = __webpack_require__(166);
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _List.default;
            }
        }), Object.defineProperty(exports, "List", {
            enumerable: !0,
            get: function() {
                return _List.default;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_RowRendererParams", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_RowRendererParams;
            }
        });
        var _List = _interopRequireDefault(__webpack_require__(180)), _types = __webpack_require__(202);
    }, /* 180 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(166), _interopRequireWildcard = __webpack_require__(168);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _class, _temp, _extends2 = _interopRequireDefault(__webpack_require__(181)), _classCallCheck2 = _interopRequireDefault(__webpack_require__(170)), _createClass2 = _interopRequireDefault(__webpack_require__(171)), _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(172)), _getPrototypeOf3 = _interopRequireDefault(__webpack_require__(174)), _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(173)), _inherits2 = _interopRequireDefault(__webpack_require__(175)), _defineProperty2 = _interopRequireDefault(__webpack_require__(177)), _Grid = _interopRequireWildcard(__webpack_require__(182)), React = _interopRequireWildcard(__webpack_require__(108)), _clsx = _interopRequireDefault(__webpack_require__(184)), _types = __webpack_require__(202), _propTypes = _interopRequireDefault(__webpack_require__(109)), List = (_temp = _class = /*#__PURE__*/
            function(_React$PureComponent) {
                function List() {
                    var _getPrototypeOf2, _this;
                    (0, _classCallCheck2.default)(this, List);
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, 
                    _getPrototypeOf3.default)(List)).call.apply(_getPrototypeOf2, [ this ].concat(args))), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "Grid", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_cellRenderer", function(_ref) {
                        var parent = _ref.parent, rowIndex = _ref.rowIndex, style = _ref.style, isScrolling = _ref.isScrolling, isVisible = _ref.isVisible, key = _ref.key, rowRenderer = _this.props.rowRenderer, widthDescriptor = Object.getOwnPropertyDescriptor(style, "width");
                        // By default, List cells should be 100% width.
                        // This prevents them from flowing under a scrollbar (if present).
                        return widthDescriptor && widthDescriptor.writable && (style.width = "100%"), rowRenderer({
                            index: rowIndex,
                            style: style,
                            isScrolling: isScrolling,
                            isVisible: isVisible,
                            key: key,
                            parent: parent
                        });
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_setRef", function(ref) {
                        _this.Grid = ref;
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onScroll", function(_ref2) {
                        var clientHeight = _ref2.clientHeight, scrollHeight = _ref2.scrollHeight, scrollTop = _ref2.scrollTop, onScroll = _this.props.onScroll;
                        onScroll({
                            clientHeight: clientHeight,
                            scrollHeight: scrollHeight,
                            scrollTop: scrollTop
                        });
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onSectionRendered", function(_ref3) {
                        var rowOverscanStartIndex = _ref3.rowOverscanStartIndex, rowOverscanStopIndex = _ref3.rowOverscanStopIndex, rowStartIndex = _ref3.rowStartIndex, rowStopIndex = _ref3.rowStopIndex, onRowsRendered = _this.props.onRowsRendered;
                        onRowsRendered({
                            overscanStartIndex: rowOverscanStartIndex,
                            overscanStopIndex: rowOverscanStopIndex,
                            startIndex: rowStartIndex,
                            stopIndex: rowStopIndex
                        });
                    }), _this;
                }
                return (0, _inherits2.default)(List, _React$PureComponent), (0, _createClass2.default)(List, [ {
                    key: "forceUpdateGrid",
                    value: function() {
                        this.Grid && this.Grid.forceUpdate();
                    }
                }, {
                    key: "getOffsetForRow",
                    value: function(_ref4) {
                        var alignment = _ref4.alignment, index = _ref4.index;
                        if (this.Grid) {
                            var _this$Grid$getOffsetF = this.Grid.getOffsetForCell({
                                alignment: alignment,
                                rowIndex: index,
                                columnIndex: 0
                            }), scrollTop = _this$Grid$getOffsetF.scrollTop;
                            return scrollTop;
                        }
                        return 0;
                    }
                }, {
                    key: "invalidateCellSizeAfterRender",
                    value: function(_ref5) {
                        var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex;
                        this.Grid && this.Grid.invalidateCellSizeAfterRender({
                            rowIndex: rowIndex,
                            columnIndex: columnIndex
                        });
                    }
                }, {
                    key: "measureAllRows",
                    value: function() {
                        this.Grid && this.Grid.measureAllCells();
                    }
                }, {
                    key: "recomputeGridSize",
                    value: function() {
                        var _ref6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref6$columnIndex = _ref6.columnIndex, columnIndex = void 0 === _ref6$columnIndex ? 0 : _ref6$columnIndex, _ref6$rowIndex = _ref6.rowIndex, rowIndex = void 0 === _ref6$rowIndex ? 0 : _ref6$rowIndex;
                        this.Grid && this.Grid.recomputeGridSize({
                            rowIndex: rowIndex,
                            columnIndex: columnIndex
                        });
                    }
                }, {
                    key: "recomputeRowHeights",
                    value: function() {
                        var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        this.Grid && this.Grid.recomputeGridSize({
                            rowIndex: index,
                            columnIndex: 0
                        });
                    }
                }, {
                    key: "scrollToPosition",
                    value: function() {
                        var scrollTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        this.Grid && this.Grid.scrollToPosition({
                            scrollTop: scrollTop
                        });
                    }
                }, {
                    key: "scrollToRow",
                    value: function() {
                        var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        this.Grid && this.Grid.scrollToCell({
                            columnIndex: 0,
                            rowIndex: index
                        });
                    }
                }, {
                    key: "render",
                    value: function() {
                        var _this$props = this.props, className = _this$props.className, noRowsRenderer = _this$props.noRowsRenderer, scrollToIndex = _this$props.scrollToIndex, width = _this$props.width, classNames = (0, 
                        _clsx.default)("ReactVirtualized__List", className);
                        return React.createElement(_Grid.default, (0, _extends2.default)({}, this.props, {
                            autoContainerWidth: !0,
                            cellRenderer: this._cellRenderer,
                            className: classNames,
                            columnWidth: width,
                            columnCount: 1,
                            noContentRenderer: noRowsRenderer,
                            onScroll: this._onScroll,
                            onSectionRendered: this._onSectionRendered,
                            ref: this._setRef,
                            scrollToRow: scrollToIndex
                        }));
                    }
                } ]), List;
            }(React.PureComponent), (0, _defineProperty2.default)(_class, "propTypes", "production" === process.env.NODE_ENV ? null : {
                "aria-label": _propTypes.default.string,
                /**
	   * Removes fixed height from the scrollingContainer so that the total height
	   * of rows can stretch the window. Intended for use with WindowScroller
	   */
                autoHeight: _propTypes.default.bool.isRequired,
                /** Optional CSS class name */
                className: _propTypes.default.string,
                /**
	   * Used to estimate the total height of a List before all of its rows have actually been measured.
	   * The estimated total height is adjusted as rows are rendered.
	   */
                estimatedRowSize: _propTypes.default.number.isRequired,
                /** Height constraint for list (determines how many actual rows are rendered) */
                height: _propTypes.default.number.isRequired,
                /** Optional renderer to be used in place of rows when rowCount is 0 */
                noRowsRenderer: function() {
                    return ("function" == typeof _Grid.bpfrpt_proptype_NoContentRenderer ? _Grid.bpfrpt_proptype_NoContentRenderer.isRequired ? _Grid.bpfrpt_proptype_NoContentRenderer.isRequired : _Grid.bpfrpt_proptype_NoContentRenderer : _propTypes.default.shape(_Grid.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
                },
                /** Callback invoked with information about the slice of rows that were just rendered.  */
                onRowsRendered: _propTypes.default.func.isRequired,
                /**
	   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
	   * This callback can be used to sync scrolling between lists, tables, or grids.
	   */
                onScroll: _propTypes.default.func.isRequired,
                /** See Grid#overscanIndicesGetter */
                overscanIndicesGetter: function() {
                    return ("function" == typeof _Grid.bpfrpt_proptype_OverscanIndicesGetter ? _Grid.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _Grid.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _Grid.bpfrpt_proptype_OverscanIndicesGetter : _propTypes.default.shape(_Grid.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
                },
                /**
	   * Number of rows to render above/below the visible bounds of the list.
	   * These rows can help for smoother scrolling on touch devices.
	   */
                overscanRowCount: _propTypes.default.number.isRequired,
                /** Either a fixed row height (number) or a function that returns the height of a row given its index.  */
                rowHeight: function() {
                    return ("function" == typeof _Grid.bpfrpt_proptype_CellSize ? _Grid.bpfrpt_proptype_CellSize.isRequired ? _Grid.bpfrpt_proptype_CellSize.isRequired : _Grid.bpfrpt_proptype_CellSize : _propTypes.default.shape(_Grid.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
                },
                /** Responsible for rendering a row given an index; ({ index: number }): node */
                rowRenderer: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_RowRenderer ? _types.bpfrpt_proptype_RowRenderer.isRequired ? _types.bpfrpt_proptype_RowRenderer.isRequired : _types.bpfrpt_proptype_RowRenderer : _propTypes.default.shape(_types.bpfrpt_proptype_RowRenderer).isRequired).apply(this, arguments);
                },
                /** Number of rows in list. */
                rowCount: _propTypes.default.number.isRequired,
                /** See Grid#scrollToAlignment */
                scrollToAlignment: function() {
                    return ("function" == typeof _Grid.bpfrpt_proptype_Alignment ? _Grid.bpfrpt_proptype_Alignment.isRequired ? _Grid.bpfrpt_proptype_Alignment.isRequired : _Grid.bpfrpt_proptype_Alignment : _propTypes.default.shape(_Grid.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
                },
                /** Row index to ensure visible (by forcefully scrolling if necessary) */
                scrollToIndex: _propTypes.default.number.isRequired,
                /** Vertical offset. */
                scrollTop: _propTypes.default.number,
                /** Optional inline style */
                style: _propTypes.default.object.isRequired,
                /** Tab index for focus */
                tabIndex: _propTypes.default.number,
                /** Width of list */
                width: _propTypes.default.number.isRequired
            }), _temp);
            exports.default = List, (0, _defineProperty2.default)(List, "defaultProps", {
                autoHeight: !1,
                estimatedRowSize: 30,
                onScroll: function() {},
                noRowsRenderer: function() {
                    return null;
                },
                onRowsRendered: function() {},
                overscanIndicesGetter: _Grid.accessibilityOverscanIndicesGetter,
                overscanRowCount: 10,
                scrollToAlignment: "auto",
                scrollToIndex: -1,
                style: {}
            });
        }).call(exports, __webpack_require__(110));
    }, /* 181 */
    /***/
    function(module, exports) {
        function _extends() {
            return module.exports = _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _extends.apply(this, arguments);
        }
        module.exports = _extends;
    }, /* 182 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequireDefault = __webpack_require__(166);
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _Grid.default;
            }
        }), Object.defineProperty(exports, "Grid", {
            enumerable: !0,
            get: function() {
                return _Grid.default;
            }
        }), Object.defineProperty(exports, "accessibilityOverscanIndicesGetter", {
            enumerable: !0,
            get: function() {
                return _accessibilityOverscanIndicesGetter.default;
            }
        }), Object.defineProperty(exports, "defaultCellRangeRenderer", {
            enumerable: !0,
            get: function() {
                return _defaultCellRangeRenderer.default;
            }
        }), Object.defineProperty(exports, "defaultOverscanIndicesGetter", {
            enumerable: !0,
            get: function() {
                return _defaultOverscanIndicesGetter.default;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_NoContentRenderer", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_NoContentRenderer;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_Alignment", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_Alignment;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_CellPosition", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_CellPosition;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_CellSize", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_CellSize;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_OverscanIndicesGetter", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_OverscanIndicesGetter;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_RenderedSection", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_RenderedSection;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_CellRendererParams", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_CellRendererParams;
            }
        }), Object.defineProperty(exports, "bpfrpt_proptype_Scroll", {
            enumerable: !0,
            get: function() {
                return _types.bpfrpt_proptype_Scroll;
            }
        });
        var _Grid = _interopRequireDefault(__webpack_require__(183)), _accessibilityOverscanIndicesGetter = _interopRequireDefault(__webpack_require__(201)), _defaultCellRangeRenderer = _interopRequireDefault(__webpack_require__(195)), _defaultOverscanIndicesGetter = _interopRequireDefault(__webpack_require__(193)), _types = __webpack_require__(190);
    }, /* 183 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    enumerableOnly && (symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    })), keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    i % 2 ? ownKeys(source, !0).forEach(function(key) {
                        (0, _defineProperty2.default)(target, key, source[key]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                }
                return target;
            }
            var _interopRequireDefault = __webpack_require__(166), _interopRequireWildcard = __webpack_require__(168);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = void 0;
            var _class, _temp, _extends2 = _interopRequireDefault(__webpack_require__(181)), _classCallCheck2 = _interopRequireDefault(__webpack_require__(170)), _createClass2 = _interopRequireDefault(__webpack_require__(171)), _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(172)), _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(174)), _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(173)), _inherits2 = _interopRequireDefault(__webpack_require__(175)), _defineProperty2 = _interopRequireDefault(__webpack_require__(177)), React = _interopRequireWildcard(__webpack_require__(108)), _clsx = _interopRequireDefault(__webpack_require__(184)), _calculateSizeAndPositionDataAndUpdateScrollOffset = _interopRequireDefault(__webpack_require__(185)), _ScalingCellSizeAndPositionManager = _interopRequireDefault(__webpack_require__(186)), _createCallbackMemoizer = _interopRequireDefault(__webpack_require__(192)), _defaultOverscanIndicesGetter = _interopRequireWildcard(__webpack_require__(193)), _updateScrollIndexHelper = _interopRequireDefault(__webpack_require__(194)), _defaultCellRangeRenderer = _interopRequireDefault(__webpack_require__(195)), _scrollbarSize = _interopRequireDefault(__webpack_require__(196)), _reactLifecyclesCompat = __webpack_require__(198), _requestAnimationTimeout = __webpack_require__(199), _types = __webpack_require__(190), _propTypes = _interopRequireDefault(__webpack_require__(109)), DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;
            /**
	 * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.
	 * This prevents Grid from interrupting mouse-wheel animations (see issue #2).
	 */
            exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = DEFAULT_SCROLLING_RESET_TIME_INTERVAL;
            var SCROLL_POSITION_CHANGE_REASONS = {
                OBSERVED: "observed",
                REQUESTED: "requested"
            }, renderNull = function() {
                return null;
            }, Grid = (_temp = _class = /*#__PURE__*/
            function(_React$PureComponent) {
                // Invokes onSectionRendered callback only when start/stop row or column indices change
                function Grid(props) {
                    var _this;
                    (0, _classCallCheck2.default)(this, Grid), _this = (0, _possibleConstructorReturn2.default)(this, (0, 
                    _getPrototypeOf2.default)(Grid).call(this, props)), (0, _defineProperty2.default)((0, 
                    _assertThisInitialized2.default)(_this), "_onGridRenderedMemoizer", (0, _createCallbackMemoizer.default)()), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onScrollMemoizer", (0, 
                    _createCallbackMemoizer.default)(!1)), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_deferredInvalidateColumnIndex", null), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_deferredInvalidateRowIndex", null), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_recomputeScrollLeftFlag", !1), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_recomputeScrollTopFlag", !1), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_horizontalScrollBarSize", 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_verticalScrollBarSize", 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_scrollbarPresenceChanged", !1), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_scrollingContainer", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_childrenToDisplay", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_columnStartIndex", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_columnStopIndex", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_rowStartIndex", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_rowStopIndex", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_renderedColumnStartIndex", 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_renderedColumnStopIndex", 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_renderedRowStartIndex", 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_renderedRowStopIndex", 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_initialScrollTop", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_initialScrollLeft", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_disablePointerEventsTimeoutId", void 0), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_styleCache", {}), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_cellCache", {}), 
                    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_debounceScrollEndedCallback", function() {
                        _this._disablePointerEventsTimeoutId = null, // isScrolling is used to determine if we reset styleCache
                        _this.setState({
                            isScrolling: !1,
                            needToResetStyleCache: !1
                        });
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_invokeOnGridRenderedHelper", function() {
                        var onSectionRendered = _this.props.onSectionRendered;
                        _this._onGridRenderedMemoizer({
                            callback: onSectionRendered,
                            indices: {
                                columnOverscanStartIndex: _this._columnStartIndex,
                                columnOverscanStopIndex: _this._columnStopIndex,
                                columnStartIndex: _this._renderedColumnStartIndex,
                                columnStopIndex: _this._renderedColumnStopIndex,
                                rowOverscanStartIndex: _this._rowStartIndex,
                                rowOverscanStopIndex: _this._rowStopIndex,
                                rowStartIndex: _this._renderedRowStartIndex,
                                rowStopIndex: _this._renderedRowStopIndex
                            }
                        });
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_setScrollingContainerRef", function(ref) {
                        _this._scrollingContainer = ref;
                    }), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_onScroll", function(event) {
                        // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
                        // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
                        // See issue #404 for more information.
                        event.target === _this._scrollingContainer && _this.handleScrollEvent(event.target);
                    });
                    var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager.default({
                        cellCount: props.columnCount,
                        cellSizeGetter: function(params) {
                            return Grid._wrapSizeGetter(props.columnWidth)(params);
                        },
                        estimatedCellSize: Grid._getEstimatedColumnSize(props)
                    }), rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager.default({
                        cellCount: props.rowCount,
                        cellSizeGetter: function(params) {
                            return Grid._wrapSizeGetter(props.rowHeight)(params);
                        },
                        estimatedCellSize: Grid._getEstimatedRowSize(props)
                    });
                    return _this.state = {
                        instanceProps: {
                            columnSizeAndPositionManager: columnSizeAndPositionManager,
                            rowSizeAndPositionManager: rowSizeAndPositionManager,
                            prevColumnWidth: props.columnWidth,
                            prevRowHeight: props.rowHeight,
                            prevColumnCount: props.columnCount,
                            prevRowCount: props.rowCount,
                            prevIsScrolling: props.isScrolling === !0,
                            prevScrollToColumn: props.scrollToColumn,
                            prevScrollToRow: props.scrollToRow,
                            scrollbarSize: 0,
                            scrollbarSizeMeasured: !1
                        },
                        isScrolling: !1,
                        scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
                        scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
                        scrollLeft: 0,
                        scrollTop: 0,
                        scrollPositionChangeReason: null,
                        needToResetStyleCache: !1
                    }, props.scrollToRow > 0 && (_this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state)), 
                    props.scrollToColumn > 0 && (_this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state)), 
                    _this;
                }
                /**
	   * Gets offsets for a given cell and alignment.
	   */
                return (0, _inherits2.default)(Grid, _React$PureComponent), (0, _createClass2.default)(Grid, [ {
                    key: "getOffsetForCell",
                    value: function() {
                        var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref$alignment = _ref.alignment, alignment = void 0 === _ref$alignment ? this.props.scrollToAlignment : _ref$alignment, _ref$columnIndex = _ref.columnIndex, columnIndex = void 0 === _ref$columnIndex ? this.props.scrollToColumn : _ref$columnIndex, _ref$rowIndex = _ref.rowIndex, rowIndex = void 0 === _ref$rowIndex ? this.props.scrollToRow : _ref$rowIndex, offsetProps = _objectSpread({}, this.props, {
                            scrollToAlignment: alignment,
                            scrollToColumn: columnIndex,
                            scrollToRow: rowIndex
                        });
                        return {
                            scrollLeft: this._getCalculatedScrollLeft(offsetProps),
                            scrollTop: this._getCalculatedScrollTop(offsetProps)
                        };
                    }
                }, {
                    key: "getTotalRowsHeight",
                    value: function() {
                        return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();
                    }
                }, {
                    key: "getTotalColumnsWidth",
                    value: function() {
                        return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();
                    }
                }, {
                    key: "handleScrollEvent",
                    value: function(_ref2) {
                        var _ref2$scrollLeft = _ref2.scrollLeft, scrollLeftParam = void 0 === _ref2$scrollLeft ? 0 : _ref2$scrollLeft, _ref2$scrollTop = _ref2.scrollTop, scrollTopParam = void 0 === _ref2$scrollTop ? 0 : _ref2$scrollTop;
                        // On iOS, we can arrive at negative offsets by swiping past the start.
                        // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.
                        if (!(scrollTopParam < 0)) {
                            // Prevent pointer events from interrupting a smooth scroll
                            this._debounceScrollEnded();
                            var _this$props = this.props, autoHeight = _this$props.autoHeight, autoWidth = _this$props.autoWidth, height = _this$props.height, width = _this$props.width, instanceProps = this.state.instanceProps, scrollbarSize = instanceProps.scrollbarSize, totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize(), scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam), scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);
                            // Certain devices (like Apple touchpad) rapid-fire duplicate events.
                            // Don't force a re-render if this is the case.
                            // The mouse may move faster then the animation frame does.
                            // Use requestAnimationFrame to avoid over-updating.
                            if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
                                // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.
                                // Don't change direction for an axis unless scroll offset has changed.
                                var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal, scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical, newState = {
                                    isScrolling: !0,
                                    scrollDirectionHorizontal: scrollDirectionHorizontal,
                                    scrollDirectionVertical: scrollDirectionVertical,
                                    scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
                                };
                                autoHeight || (newState.scrollTop = scrollTop), autoWidth || (newState.scrollLeft = scrollLeft), 
                                newState.needToResetStyleCache = !1, this.setState(newState);
                            }
                            this._invokeOnScrollMemoizer({
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop,
                                totalColumnsWidth: totalColumnsWidth,
                                totalRowsHeight: totalRowsHeight
                            });
                        }
                    }
                }, {
                    key: "invalidateCellSizeAfterRender",
                    value: function(_ref3) {
                        var columnIndex = _ref3.columnIndex, rowIndex = _ref3.rowIndex;
                        this._deferredInvalidateColumnIndex = "number" == typeof this._deferredInvalidateColumnIndex ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex, 
                        this._deferredInvalidateRowIndex = "number" == typeof this._deferredInvalidateRowIndex ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
                    }
                }, {
                    key: "measureAllCells",
                    value: function() {
                        var _this$props2 = this.props, columnCount = _this$props2.columnCount, rowCount = _this$props2.rowCount, instanceProps = this.state.instanceProps;
                        instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1), 
                        instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
                    }
                }, {
                    key: "recomputeGridSize",
                    value: function() {
                        var _ref4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref4$columnIndex = _ref4.columnIndex, columnIndex = void 0 === _ref4$columnIndex ? 0 : _ref4$columnIndex, _ref4$rowIndex = _ref4.rowIndex, rowIndex = void 0 === _ref4$rowIndex ? 0 : _ref4$rowIndex, _this$props3 = this.props, scrollToColumn = _this$props3.scrollToColumn, scrollToRow = _this$props3.scrollToRow, instanceProps = this.state.instanceProps;
                        instanceProps.columnSizeAndPositionManager.resetCell(columnIndex), instanceProps.rowSizeAndPositionManager.resetCell(rowIndex), 
                        // Cell sizes may be determined by a function property.
                        // In this case the cDU handler can't know if they changed.
                        // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.
                        this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn), 
                        this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow), 
                        // Clear cell cache in case we are scrolling;
                        // Invalid row heights likely mean invalid cached content as well.
                        this._styleCache = {}, this._cellCache = {}, this.forceUpdate();
                    }
                }, {
                    key: "scrollToCell",
                    value: function(_ref5) {
                        var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex, columnCount = this.props.columnCount, props = this.props;
                        // Don't adjust scroll offset for single-column grids (eg List, Table).
                        // This can cause a funky scroll offset because of the vertical scrollbar width.
                        columnCount > 1 && void 0 !== columnIndex && this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {
                            scrollToColumn: columnIndex
                        })), void 0 !== rowIndex && this._updateScrollTopForScrollToRow(_objectSpread({}, props, {
                            scrollToRow: rowIndex
                        }));
                    }
                }, {
                    key: "componentDidMount",
                    value: function() {
                        var _this$props4 = this.props, getScrollbarSize = _this$props4.getScrollbarSize, height = _this$props4.height, scrollLeft = _this$props4.scrollLeft, scrollToColumn = _this$props4.scrollToColumn, scrollTop = _this$props4.scrollTop, scrollToRow = _this$props4.scrollToRow, width = _this$props4.width, instanceProps = this.state.instanceProps;
                        if (// Reset initial offsets to be ignored in browser
                        this._initialScrollTop = 0, this._initialScrollLeft = 0, // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
                        // We must do this at the start of the method as we may calculate and update scroll position below.
                        this._handleInvalidatedGridSize(), // If this component was first rendered server-side, scrollbar size will be undefined.
                        // In that event we need to remeasure.
                        instanceProps.scrollbarSizeMeasured || this.setState(function(prevState) {
                            var stateUpdate = _objectSpread({}, prevState, {
                                needToResetStyleCache: !1
                            });
                            return stateUpdate.instanceProps.scrollbarSize = getScrollbarSize(), stateUpdate.instanceProps.scrollbarSizeMeasured = !0, 
                            stateUpdate;
                        }), "number" == typeof scrollLeft && scrollLeft >= 0 || "number" == typeof scrollTop && scrollTop >= 0) {
                            var stateUpdate = Grid._getScrollToPositionStateUpdate({
                                prevState: this.state,
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop
                            });
                            stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                        }
                        // refs don't work in `react-test-renderer`
                        this._scrollingContainer && (// setting the ref's scrollLeft and scrollTop.
                        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.
                        this._scrollingContainer.scrollLeft !== this.state.scrollLeft && (this._scrollingContainer.scrollLeft = this.state.scrollLeft), 
                        this._scrollingContainer.scrollTop !== this.state.scrollTop && (this._scrollingContainer.scrollTop = this.state.scrollTop));
                        // Don't update scroll offset if the size is 0; we don't render any cells in this case.
                        // Setting a state may cause us to later thing we've updated the offce when we haven't.
                        var sizeIsBiggerThanZero = height > 0 && width > 0;
                        scrollToColumn >= 0 && sizeIsBiggerThanZero && this._updateScrollLeftForScrollToColumn(), 
                        scrollToRow >= 0 && sizeIsBiggerThanZero && this._updateScrollTopForScrollToRow(), 
                        // Update onRowsRendered callback
                        this._invokeOnGridRenderedHelper(), // Initialize onScroll callback
                        this._invokeOnScrollMemoizer({
                            scrollLeft: scrollLeft || 0,
                            scrollTop: scrollTop || 0,
                            totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),
                            totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()
                        }), this._maybeCallOnScrollbarPresenceChange();
                    }
                }, {
                    key: "componentDidUpdate",
                    value: function(prevProps, prevState) {
                        var _this2 = this, _this$props5 = this.props, autoHeight = _this$props5.autoHeight, autoWidth = _this$props5.autoWidth, columnCount = _this$props5.columnCount, height = _this$props5.height, rowCount = _this$props5.rowCount, scrollToAlignment = _this$props5.scrollToAlignment, scrollToColumn = _this$props5.scrollToColumn, scrollToRow = _this$props5.scrollToRow, width = _this$props5.width, _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollPositionChangeReason = _this$state.scrollPositionChangeReason, scrollTop = _this$state.scrollTop, instanceProps = _this$state.instanceProps;
                        // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
                        // We must do this at the start of the method as we may calculate and update scroll position below.
                        this._handleInvalidatedGridSize();
                        // Handle edge case where column or row count has only just increased over 0.
                        // In this case we may have to restore a previously-specified scroll offset.
                        // For more info see bvaughn/react-virtualized/issues/218
                        var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && 0 === prevProps.columnCount || rowCount > 0 && 0 === prevProps.rowCount;
                        // Make sure requested changes to :scrollLeft or :scrollTop get applied.
                        // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
                        // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
                        // So we only set these when we require an adjustment of the scroll position.
                        // See issue #2 for more information.
                        scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED && (// @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).
                        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.
                        !autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollLeft = scrollLeft), 
                        !autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollTop = scrollTop));
                        // Special case where the previous size was 0:
                        // In this case we don't show any windowed cells at all.
                        // So we should always recalculate offset afterwards.
                        var sizeJustIncreasedFromZero = (0 === prevProps.width || 0 === prevProps.height) && height > 0 && width > 0;
                        // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners
                        if (// Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it
                        // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?
                        this._recomputeScrollLeftFlag ? (this._recomputeScrollLeftFlag = !1, this._updateScrollLeftForScrollToColumn(this.props)) : (0, 
                        _updateScrollIndexHelper.default)({
                            cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
                            previousCellsCount: prevProps.columnCount,
                            previousCellSize: prevProps.columnWidth,
                            previousScrollToAlignment: prevProps.scrollToAlignment,
                            previousScrollToIndex: prevProps.scrollToColumn,
                            previousSize: prevProps.width,
                            scrollOffset: scrollLeft,
                            scrollToAlignment: scrollToAlignment,
                            scrollToIndex: scrollToColumn,
                            size: width,
                            sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
                            updateScrollIndexCallback: function() {
                                return _this2._updateScrollLeftForScrollToColumn(_this2.props);
                            }
                        }), this._recomputeScrollTopFlag ? (this._recomputeScrollTopFlag = !1, this._updateScrollTopForScrollToRow(this.props)) : (0, 
                        _updateScrollIndexHelper.default)({
                            cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
                            previousCellsCount: prevProps.rowCount,
                            previousCellSize: prevProps.rowHeight,
                            previousScrollToAlignment: prevProps.scrollToAlignment,
                            previousScrollToIndex: prevProps.scrollToRow,
                            previousSize: prevProps.height,
                            scrollOffset: scrollTop,
                            scrollToAlignment: scrollToAlignment,
                            scrollToIndex: scrollToRow,
                            size: height,
                            sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
                            updateScrollIndexCallback: function() {
                                return _this2._updateScrollTopForScrollToRow(_this2.props);
                            }
                        }), // Update onRowsRendered callback if start/stop indices have changed
                        this._invokeOnGridRenderedHelper(), scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
                            var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
                            this._invokeOnScrollMemoizer({
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop,
                                totalColumnsWidth: totalColumnsWidth,
                                totalRowsHeight: totalRowsHeight
                            });
                        }
                        this._maybeCallOnScrollbarPresenceChange();
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function() {
                        this._disablePointerEventsTimeoutId && (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
                    }
                }, {
                    key: "render",
                    value: function() {
                        var _this$props6 = this.props, autoContainerWidth = _this$props6.autoContainerWidth, autoHeight = _this$props6.autoHeight, autoWidth = _this$props6.autoWidth, className = _this$props6.className, containerProps = _this$props6.containerProps, containerRole = _this$props6.containerRole, containerStyle = _this$props6.containerStyle, height = _this$props6.height, id = _this$props6.id, noContentRenderer = _this$props6.noContentRenderer, role = _this$props6.role, style = _this$props6.style, tabIndex = _this$props6.tabIndex, width = _this$props6.width, _this$state2 = this.state, instanceProps = _this$state2.instanceProps, needToResetStyleCache = _this$state2.needToResetStyleCache, isScrolling = this._isScrolling(), gridStyle = {
                            boxSizing: "border-box",
                            direction: "ltr",
                            height: autoHeight ? "auto" : height,
                            position: "relative",
                            width: autoWidth ? "auto" : width,
                            WebkitOverflowScrolling: "touch",
                            willChange: "transform"
                        };
                        needToResetStyleCache && (this._styleCache = {}), // calculate _styleCache here
                        // if state.isScrolling (not from _isScrolling) then reset
                        this.state.isScrolling || this._resetStyleCache(), // calculate children to render here
                        this._calculateChildrenToRender(this.props, this.state);
                        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize(), totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0, horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
                        horizontalScrollBarSize === this._horizontalScrollBarSize && verticalScrollBarSize === this._verticalScrollBarSize || (this._horizontalScrollBarSize = horizontalScrollBarSize, 
                        this._verticalScrollBarSize = verticalScrollBarSize, this._scrollbarPresenceChanged = !0), 
                        // Also explicitly init styles to 'auto' if scrollbars are required.
                        // This works around an obscure edge case where external CSS styles have not yet been loaded,
                        // But an initial scroll index of offset is set as an external prop.
                        // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
                        // This was originally reported via clauderic/react-infinite-calendar/issues/23
                        gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? "hidden" : "auto", 
                        gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? "hidden" : "auto";
                        var childrenToDisplay = this._childrenToDisplay, showNoContentRenderer = 0 === childrenToDisplay.length && height > 0 && width > 0;
                        return React.createElement("div", (0, _extends2.default)({
                            ref: this._setScrollingContainerRef
                        }, containerProps, {
                            "aria-label": this.props["aria-label"],
                            "aria-readonly": this.props["aria-readonly"],
                            className: (0, _clsx.default)("ReactVirtualized__Grid", className),
                            id: id,
                            onScroll: this._onScroll,
                            role: role,
                            style: _objectSpread({}, gridStyle, {}, style),
                            tabIndex: tabIndex
                        }), childrenToDisplay.length > 0 && React.createElement("div", {
                            className: "ReactVirtualized__Grid__innerScrollContainer",
                            role: containerRole,
                            style: _objectSpread({
                                width: autoContainerWidth ? "auto" : totalColumnsWidth,
                                height: totalRowsHeight,
                                maxWidth: totalColumnsWidth,
                                maxHeight: totalRowsHeight,
                                overflow: "hidden",
                                pointerEvents: isScrolling ? "none" : "",
                                position: "relative"
                            }, containerStyle)
                        }, childrenToDisplay), showNoContentRenderer && noContentRenderer());
                    }
                }, {
                    key: "_calculateChildrenToRender",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, cellRenderer = props.cellRenderer, cellRangeRenderer = props.cellRangeRenderer, columnCount = props.columnCount, deferredMeasurementCache = props.deferredMeasurementCache, height = props.height, overscanColumnCount = props.overscanColumnCount, overscanIndicesGetter = props.overscanIndicesGetter, overscanRowCount = props.overscanRowCount, rowCount = props.rowCount, width = props.width, isScrollingOptOut = props.isScrollingOptOut, scrollDirectionHorizontal = state.scrollDirectionHorizontal, scrollDirectionVertical = state.scrollDirectionVertical, instanceProps = state.instanceProps, scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop, scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft, isScrolling = this._isScrolling(props, state);
                        // Render only enough columns and rows to cover the visible area of the grid.
                        if (this._childrenToDisplay = [], height > 0 && width > 0) {
                            var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({
                                containerSize: width,
                                offset: scrollLeft
                            }), visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({
                                containerSize: height,
                                offset: scrollTop
                            }), horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({
                                containerSize: width,
                                offset: scrollLeft
                            }), verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({
                                containerSize: height,
                                offset: scrollTop
                            });
                            // Store for _invokeOnGridRenderedHelper()
                            this._renderedColumnStartIndex = visibleColumnIndices.start, this._renderedColumnStopIndex = visibleColumnIndices.stop, 
                            this._renderedRowStartIndex = visibleRowIndices.start, this._renderedRowStopIndex = visibleRowIndices.stop;
                            var overscanColumnIndices = overscanIndicesGetter({
                                direction: "horizontal",
                                cellCount: columnCount,
                                overscanCellsCount: overscanColumnCount,
                                scrollDirection: scrollDirectionHorizontal,
                                startIndex: "number" == typeof visibleColumnIndices.start ? visibleColumnIndices.start : 0,
                                stopIndex: "number" == typeof visibleColumnIndices.stop ? visibleColumnIndices.stop : -1
                            }), overscanRowIndices = overscanIndicesGetter({
                                direction: "vertical",
                                cellCount: rowCount,
                                overscanCellsCount: overscanRowCount,
                                scrollDirection: scrollDirectionVertical,
                                startIndex: "number" == typeof visibleRowIndices.start ? visibleRowIndices.start : 0,
                                stopIndex: "number" == typeof visibleRowIndices.stop ? visibleRowIndices.stop : -1
                            }), columnStartIndex = overscanColumnIndices.overscanStartIndex, columnStopIndex = overscanColumnIndices.overscanStopIndex, rowStartIndex = overscanRowIndices.overscanStartIndex, rowStopIndex = overscanRowIndices.overscanStopIndex;
                            // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.
                            if (deferredMeasurementCache) {
                                // If rows have a dynamic height, scan the rows we are about to render.
                                // If any have not yet been measured, then we need to render all columns initially,
                                // Because the height of the row is equal to the tallest cell within that row,
                                // (And so we can't know the height without measuring all column-cells first).
                                if (!deferredMeasurementCache.hasFixedHeight()) for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) if (!deferredMeasurementCache.has(rowIndex, 0)) {
                                    columnStartIndex = 0, columnStopIndex = columnCount - 1;
                                    break;
                                }
                                // If columns have a dynamic width, scan the columns we are about to render.
                                // If any have not yet been measured, then we need to render all rows initially,
                                // Because the width of the column is equal to the widest cell within that column,
                                // (And so we can't know the width without measuring all row-cells first).
                                if (!deferredMeasurementCache.hasFixedWidth()) for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) if (!deferredMeasurementCache.has(0, columnIndex)) {
                                    rowStartIndex = 0, rowStopIndex = rowCount - 1;
                                    break;
                                }
                            }
                            this._childrenToDisplay = cellRangeRenderer({
                                cellCache: this._cellCache,
                                cellRenderer: cellRenderer,
                                columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
                                columnStartIndex: columnStartIndex,
                                columnStopIndex: columnStopIndex,
                                deferredMeasurementCache: deferredMeasurementCache,
                                horizontalOffsetAdjustment: horizontalOffsetAdjustment,
                                isScrolling: isScrolling,
                                isScrollingOptOut: isScrollingOptOut,
                                parent: this,
                                rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
                                rowStartIndex: rowStartIndex,
                                rowStopIndex: rowStopIndex,
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop,
                                styleCache: this._styleCache,
                                verticalOffsetAdjustment: verticalOffsetAdjustment,
                                visibleColumnIndices: visibleColumnIndices,
                                visibleRowIndices: visibleRowIndices
                            }), // update the indices
                            this._columnStartIndex = columnStartIndex, this._columnStopIndex = columnStopIndex, 
                            this._rowStartIndex = rowStartIndex, this._rowStopIndex = rowStopIndex;
                        }
                    }
                }, {
                    key: "_debounceScrollEnded",
                    value: function() {
                        var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
                        this._disablePointerEventsTimeoutId && (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId), 
                        this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
                    }
                }, {
                    key: "_handleInvalidatedGridSize",
                    /**
	     * Check for batched CellMeasurer size invalidations.
	     * This will occur the first time one or more previously unmeasured cells are rendered.
	     */
                    value: function() {
                        if ("number" == typeof this._deferredInvalidateColumnIndex && "number" == typeof this._deferredInvalidateRowIndex) {
                            var columnIndex = this._deferredInvalidateColumnIndex, rowIndex = this._deferredInvalidateRowIndex;
                            this._deferredInvalidateColumnIndex = null, this._deferredInvalidateRowIndex = null, 
                            this.recomputeGridSize({
                                columnIndex: columnIndex,
                                rowIndex: rowIndex
                            });
                        }
                    }
                }, {
                    key: "_invokeOnScrollMemoizer",
                    value: function(_ref6) {
                        var _this3 = this, scrollLeft = _ref6.scrollLeft, scrollTop = _ref6.scrollTop, totalColumnsWidth = _ref6.totalColumnsWidth, totalRowsHeight = _ref6.totalRowsHeight;
                        this._onScrollMemoizer({
                            callback: function(_ref7) {
                                var scrollLeft = _ref7.scrollLeft, scrollTop = _ref7.scrollTop, _this3$props = _this3.props, height = _this3$props.height, onScroll = _this3$props.onScroll, width = _this3$props.width;
                                onScroll({
                                    clientHeight: height,
                                    clientWidth: width,
                                    scrollHeight: totalRowsHeight,
                                    scrollLeft: scrollLeft,
                                    scrollTop: scrollTop,
                                    scrollWidth: totalColumnsWidth
                                });
                            },
                            indices: {
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop
                            }
                        });
                    }
                }, {
                    key: "_isScrolling",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
                        // If isScrolling is defined in props, use it to override the value in state
                        // This is a performance optimization for WindowScroller + Grid
                        return Object.hasOwnProperty.call(props, "isScrolling") ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
                    }
                }, {
                    key: "_maybeCallOnScrollbarPresenceChange",
                    value: function() {
                        if (this._scrollbarPresenceChanged) {
                            var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;
                            this._scrollbarPresenceChanged = !1, onScrollbarPresenceChange({
                                horizontal: this._horizontalScrollBarSize > 0,
                                size: this.state.instanceProps.scrollbarSize,
                                vertical: this._verticalScrollBarSize > 0
                            });
                        }
                    }
                }, {
                    key: "scrollToPosition",
                    /**
	     * Scroll to the specified offset(s).
	     * Useful for animating position changes.
	     */
                    value: function(_ref8) {
                        var scrollLeft = _ref8.scrollLeft, scrollTop = _ref8.scrollTop, stateUpdate = Grid._getScrollToPositionStateUpdate({
                            prevState: this.state,
                            scrollLeft: scrollLeft,
                            scrollTop: scrollTop
                        });
                        stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                    }
                }, {
                    key: "_getCalculatedScrollLeft",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
                        return Grid._getCalculatedScrollLeft(props, state);
                    }
                }, {
                    key: "_updateScrollLeftForScrollToColumn",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);
                        stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                    }
                }, {
                    key: "_getCalculatedScrollTop",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
                        return Grid._getCalculatedScrollTop(props, state);
                    }
                }, {
                    key: "_resetStyleCache",
                    value: function() {
                        var styleCache = this._styleCache, cellCache = this._cellCache, isScrollingOptOut = this.props.isScrollingOptOut;
                        // Reset cell and style caches once scrolling stops.
                        // This makes Grid simpler to use (since cells commonly change).
                        // And it keeps the caches from growing too large.
                        // Performance is most sensitive when a user is scrolling.
                        // Don't clear visible cells from cellCache if isScrollingOptOut is specified.
                        // This keeps the cellCache to a resonable size.
                        this._cellCache = {}, this._styleCache = {};
                        // Copy over the visible cell styles so avoid unnecessary re-render.
                        for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
                            var key = "".concat(rowIndex, "-").concat(columnIndex);
                            this._styleCache[key] = styleCache[key], isScrollingOptOut && (this._cellCache[key] = cellCache[key]);
                        }
                    }
                }, {
                    key: "_updateScrollTopForScrollToRow",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);
                        stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                    }
                } ], [ {
                    key: "getDerivedStateFromProps",
                    value: function(nextProps, prevState) {
                        var newState = {};
                        0 === nextProps.columnCount && 0 !== prevState.scrollLeft || 0 === nextProps.rowCount && 0 !== prevState.scrollTop ? (newState.scrollLeft = 0, 
                        newState.scrollTop = 0) : (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) && Object.assign(newState, Grid._getScrollToPositionStateUpdate({
                            prevState: prevState,
                            scrollLeft: nextProps.scrollLeft,
                            scrollTop: nextProps.scrollTop
                        }));
                        var instanceProps = prevState.instanceProps;
                        // Initially we should not clearStyleCache
                        newState.needToResetStyleCache = !1, nextProps.columnWidth === instanceProps.prevColumnWidth && nextProps.rowHeight === instanceProps.prevRowHeight || (// Reset cache. set it to {} in render
                        newState.needToResetStyleCache = !0), instanceProps.columnSizeAndPositionManager.configure({
                            cellCount: nextProps.columnCount,
                            estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),
                            cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)
                        }), instanceProps.rowSizeAndPositionManager.configure({
                            cellCount: nextProps.rowCount,
                            estimatedCellSize: Grid._getEstimatedRowSize(nextProps),
                            cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)
                        }), 0 !== instanceProps.prevColumnCount && 0 !== instanceProps.prevRowCount || (instanceProps.prevColumnCount = 0, 
                        instanceProps.prevRowCount = 0), // If scrolling is controlled outside this component, clear cache when scrolling stops
                        nextProps.autoHeight && nextProps.isScrolling === !1 && instanceProps.prevIsScrolling === !0 && Object.assign(newState, {
                            isScrolling: !1
                        });
                        var maybeStateA, maybeStateB;
                        // getting scrollBarSize (moved from componentWillMount)
                        return (0, _calculateSizeAndPositionDataAndUpdateScrollOffset.default)({
                            cellCount: instanceProps.prevColumnCount,
                            cellSize: "number" == typeof instanceProps.prevColumnWidth ? instanceProps.prevColumnWidth : null,
                            computeMetadataCallback: function() {
                                return instanceProps.columnSizeAndPositionManager.resetCell(0);
                            },
                            computeMetadataCallbackProps: nextProps,
                            nextCellsCount: nextProps.columnCount,
                            nextCellSize: "number" == typeof nextProps.columnWidth ? nextProps.columnWidth : null,
                            nextScrollToIndex: nextProps.scrollToColumn,
                            scrollToIndex: instanceProps.prevScrollToColumn,
                            updateScrollOffsetForScrollToIndex: function() {
                                maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);
                            }
                        }), (0, _calculateSizeAndPositionDataAndUpdateScrollOffset.default)({
                            cellCount: instanceProps.prevRowCount,
                            cellSize: "number" == typeof instanceProps.prevRowHeight ? instanceProps.prevRowHeight : null,
                            computeMetadataCallback: function() {
                                return instanceProps.rowSizeAndPositionManager.resetCell(0);
                            },
                            computeMetadataCallbackProps: nextProps,
                            nextCellsCount: nextProps.rowCount,
                            nextCellSize: "number" == typeof nextProps.rowHeight ? nextProps.rowHeight : null,
                            nextScrollToIndex: nextProps.scrollToRow,
                            scrollToIndex: instanceProps.prevScrollToRow,
                            updateScrollOffsetForScrollToIndex: function() {
                                maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);
                            }
                        }), instanceProps.prevColumnCount = nextProps.columnCount, instanceProps.prevColumnWidth = nextProps.columnWidth, 
                        instanceProps.prevIsScrolling = nextProps.isScrolling === !0, instanceProps.prevRowCount = nextProps.rowCount, 
                        instanceProps.prevRowHeight = nextProps.rowHeight, instanceProps.prevScrollToColumn = nextProps.scrollToColumn, 
                        instanceProps.prevScrollToRow = nextProps.scrollToRow, instanceProps.scrollbarSize = nextProps.getScrollbarSize(), 
                        void 0 === instanceProps.scrollbarSize ? (instanceProps.scrollbarSizeMeasured = !1, 
                        instanceProps.scrollbarSize = 0) : instanceProps.scrollbarSizeMeasured = !0, newState.instanceProps = instanceProps, 
                        _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);
                    }
                }, {
                    key: "_getEstimatedColumnSize",
                    value: function(props) {
                        return "number" == typeof props.columnWidth ? props.columnWidth : props.estimatedColumnSize;
                    }
                }, {
                    key: "_getEstimatedRowSize",
                    value: function(props) {
                        return "number" == typeof props.rowHeight ? props.rowHeight : props.estimatedRowSize;
                    }
                }, {
                    key: "_getScrollToPositionStateUpdate",
                    /**
	     * Get the updated state after scrolling to
	     * scrollLeft and scrollTop
	     */
                    value: function(_ref9) {
                        var prevState = _ref9.prevState, scrollLeft = _ref9.scrollLeft, scrollTop = _ref9.scrollTop, newState = {
                            scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
                        };
                        return "number" == typeof scrollLeft && scrollLeft >= 0 && (newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD, 
                        newState.scrollLeft = scrollLeft), "number" == typeof scrollTop && scrollTop >= 0 && (newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD, 
                        newState.scrollTop = scrollTop), "number" == typeof scrollLeft && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || "number" == typeof scrollTop && scrollTop >= 0 && scrollTop !== prevState.scrollTop ? newState : {};
                    }
                }, {
                    key: "_wrapSizeGetter",
                    value: function(value) {
                        return "function" == typeof value ? value : function() {
                            return value;
                        };
                    }
                }, {
                    key: "_getCalculatedScrollLeft",
                    value: function(nextProps, prevState) {
                        var columnCount = nextProps.columnCount, height = nextProps.height, scrollToAlignment = nextProps.scrollToAlignment, scrollToColumn = nextProps.scrollToColumn, width = nextProps.width, scrollLeft = prevState.scrollLeft, instanceProps = prevState.instanceProps;
                        if (columnCount > 0) {
                            var finalColumn = columnCount - 1, targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn), totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
                            return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({
                                align: scrollToAlignment,
                                containerSize: width - scrollBarSize,
                                currentOffset: scrollLeft,
                                targetIndex: targetIndex
                            });
                        }
                        return 0;
                    }
                }, {
                    key: "_getScrollLeftForScrollToColumnStateUpdate",
                    value: function(nextProps, prevState) {
                        var scrollLeft = prevState.scrollLeft, calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);
                        return "number" == typeof calculatedScrollLeft && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft ? Grid._getScrollToPositionStateUpdate({
                            prevState: prevState,
                            scrollLeft: calculatedScrollLeft,
                            scrollTop: -1
                        }) : {};
                    }
                }, {
                    key: "_getCalculatedScrollTop",
                    value: function(nextProps, prevState) {
                        var height = nextProps.height, rowCount = nextProps.rowCount, scrollToAlignment = nextProps.scrollToAlignment, scrollToRow = nextProps.scrollToRow, width = nextProps.width, scrollTop = prevState.scrollTop, instanceProps = prevState.instanceProps;
                        if (rowCount > 0) {
                            var finalRow = rowCount - 1, targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow), totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize(), scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
                            return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({
                                align: scrollToAlignment,
                                containerSize: height - scrollBarSize,
                                currentOffset: scrollTop,
                                targetIndex: targetIndex
                            });
                        }
                        return 0;
                    }
                }, {
                    key: "_getScrollTopForScrollToRowStateUpdate",
                    value: function(nextProps, prevState) {
                        var scrollTop = prevState.scrollTop, calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);
                        return "number" == typeof calculatedScrollTop && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop ? Grid._getScrollToPositionStateUpdate({
                            prevState: prevState,
                            scrollLeft: -1,
                            scrollTop: calculatedScrollTop
                        }) : {};
                    }
                } ]), Grid;
            }(React.PureComponent), (0, _defineProperty2.default)(_class, "propTypes", "production" === process.env.NODE_ENV ? null : {
                "aria-label": _propTypes.default.string.isRequired,
                "aria-readonly": _propTypes.default.bool,
                /**
	   * Set the width of the inner scrollable container to 'auto'.
	   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.
	   */
                autoContainerWidth: _propTypes.default.bool.isRequired,
                /**
	   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.
	   * Intended for use with WindowScroller
	   */
                autoHeight: _propTypes.default.bool.isRequired,
                /**
	   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.
	   * Intended for use with WindowScroller
	   */
                autoWidth: _propTypes.default.bool.isRequired,
                /** Responsible for rendering a cell given an row and column index.  */
                cellRenderer: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_CellRenderer ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes.default.shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);
                },
                /** Responsible for rendering a group of cells given their index ranges.  */
                cellRangeRenderer: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_CellRangeRenderer ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes.default.shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);
                },
                /** Optional custom CSS class name to attach to root Grid element.  */
                className: _propTypes.default.string,
                /** Number of columns in grid.  */
                columnCount: _propTypes.default.number.isRequired,
                /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */
                columnWidth: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_CellSize ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
                },
                /** Unfiltered props for the Grid container. */
                containerProps: _propTypes.default.object,
                /** ARIA role for the cell-container.  */
                containerRole: _propTypes.default.string.isRequired,
                /** Optional inline style applied to inner cell-container */
                containerStyle: _propTypes.default.object.isRequired,
                /**
	   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.
	   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.
	   */
                deferredMeasurementCache: _propTypes.default.object,
                /**
	   * Used to estimate the total width of a Grid before all of its columns have actually been measured.
	   * The estimated total width is adjusted as columns are rendered.
	   */
                estimatedColumnSize: _propTypes.default.number.isRequired,
                /**
	   * Used to estimate the total height of a Grid before all of its rows have actually been measured.
	   * The estimated total height is adjusted as rows are rendered.
	   */
                estimatedRowSize: _propTypes.default.number.isRequired,
                /** Exposed for testing purposes only.  */
                getScrollbarSize: _propTypes.default.func.isRequired,
                /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */
                height: _propTypes.default.number.isRequired,
                /** Optional custom id to attach to root Grid element.  */
                id: _propTypes.default.string,
                /**
	   * Override internal is-scrolling state tracking.
	   * This property is primarily intended for use with the WindowScroller component.
	   */
                isScrolling: _propTypes.default.bool,
                /**
	   * Opt-out of isScrolling param passed to cellRangeRenderer.
	   * To avoid the extra render when scroll stops.
	   */
                isScrollingOptOut: _propTypes.default.bool.isRequired,
                /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */
                noContentRenderer: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_NoContentRenderer ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes.default.shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
                },
                /**
	   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
	   * This callback can be used to sync scrolling between lists, tables, or grids.
	   */
                onScroll: _propTypes.default.func.isRequired,
                /**
	   * Called whenever a horizontal or vertical scrollbar is added or removed.
	   * This prop is not intended for end-user use;
	   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.
	   */
                onScrollbarPresenceChange: _propTypes.default.func.isRequired,
                /** Callback invoked with information about the section of the Grid that was just rendered.  */
                onSectionRendered: _propTypes.default.func.isRequired,
                /**
	   * Number of columns to render before/after the visible section of the grid.
	   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
	   */
                overscanColumnCount: _propTypes.default.number.isRequired,
                /**
	   * Calculates the number of cells to overscan before and after a specified range.
	   * This function ensures that overscanning doesn't exceed the available cells.
	   */
                overscanIndicesGetter: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_OverscanIndicesGetter ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes.default.shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
                },
                /**
	   * Number of rows to render above/below the visible section of the grid.
	   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
	   */
                overscanRowCount: _propTypes.default.number.isRequired,
                /** ARIA role for the grid element.  */
                role: _propTypes.default.string.isRequired,
                /**
	   * Either a fixed row height (number) or a function that returns the height of a row given its index.
	   * Should implement the following interface: ({ index: number }): number
	   */
                rowHeight: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_CellSize ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
                },
                /** Number of rows in grid.  */
                rowCount: _propTypes.default.number.isRequired,
                /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */
                scrollingResetTimeInterval: _propTypes.default.number.isRequired,
                /** Horizontal offset. */
                scrollLeft: _propTypes.default.number,
                /**
	   * Controls scroll-to-cell behavior of the Grid.
	   * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
	   * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
	   */
                scrollToAlignment: function() {
                    return ("function" == typeof _types.bpfrpt_proptype_Alignment ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes.default.shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
                },
                /** Column index to ensure visible (by forcefully scrolling if necessary) */
                scrollToColumn: _propTypes.default.number.isRequired,
                /** Vertical offset. */
                scrollTop: _propTypes.default.number,
                /** Row index to ensure visible (by forcefully scrolling if necessary) */
                scrollToRow: _propTypes.default.number.isRequired,
                /** Optional inline style */
                style: _propTypes.default.object.isRequired,
                /** Tab index for focus */
                tabIndex: _propTypes.default.number,
                /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */
                width: _propTypes.default.number.isRequired
            }), _temp);
            (0, _defineProperty2.default)(Grid, "defaultProps", {
                "aria-label": "grid",
                "aria-readonly": !0,
                autoContainerWidth: !1,
                autoHeight: !1,
                autoWidth: !1,
                cellRangeRenderer: _defaultCellRangeRenderer.default,
                containerRole: "rowgroup",
                containerStyle: {},
                estimatedColumnSize: 100,
                estimatedRowSize: 30,
                getScrollbarSize: _scrollbarSize.default,
                noContentRenderer: renderNull,
                onScroll: function() {},
                onScrollbarPresenceChange: function() {},
                onSectionRendered: function() {},
                overscanColumnCount: 0,
                overscanIndicesGetter: _defaultOverscanIndicesGetter.default,
                overscanRowCount: 10,
                role: "grid",
                scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
                scrollToAlignment: "auto",
                scrollToColumn: -1,
                scrollToRow: -1,
                style: {},
                tabIndex: 0,
                isScrollingOptOut: !1
            }), (0, _reactLifecyclesCompat.polyfill)(Grid);
            var _default = Grid;
            exports.default = _default;
        }).call(exports, __webpack_require__(110));
    }, /* 184 */
    /***/
    function(module, exports) {
        function toVal(mix) {
            var k, y, str = "";
            if ("string" == typeof mix || "number" == typeof mix) str += mix; else if ("object" == typeof mix) if (Array.isArray(mix)) for (k = 0; k < mix.length; k++) mix[k] && (y = toVal(mix[k])) && (str && (str += " "), 
            str += y); else for (k in mix) mix[k] && (str && (str += " "), str += k);
            return str;
        }
        module.exports = function() {
            for (var tmp, x, i = 0, str = ""; i < arguments.length; ) (tmp = arguments[i++]) && (x = toVal(tmp)) && (str && (str += " "), 
            str += x);
            return str;
        };
    }, /* 185 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Helper method that determines when to recalculate row or column metadata.
	 */
        function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
            var cellCount = _ref.cellCount, cellSize = _ref.cellSize, computeMetadataCallback = _ref.computeMetadataCallback, computeMetadataCallbackProps = _ref.computeMetadataCallbackProps, nextCellsCount = _ref.nextCellsCount, nextCellSize = _ref.nextCellSize, nextScrollToIndex = _ref.nextScrollToIndex, scrollToIndex = _ref.scrollToIndex, updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;
            // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.
            // In that event users should use the manual recompute methods to inform of changes.
            cellCount === nextCellsCount && ("number" != typeof cellSize && "number" != typeof nextCellSize || cellSize === nextCellSize) || (computeMetadataCallback(computeMetadataCallbackProps), 
            // Updated cell metadata may have hidden the previous scrolled-to item.
            // In this case we should also update the scrollTop to ensure it stays visible.
            scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex && updateScrollOffsetForScrollToIndex());
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;
    }, /* 186 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequireDefault = __webpack_require__(166);
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _objectWithoutProperties2 = _interopRequireDefault(__webpack_require__(187)), _classCallCheck2 = _interopRequireDefault(__webpack_require__(170)), _createClass2 = _interopRequireDefault(__webpack_require__(171)), _defineProperty2 = _interopRequireDefault(__webpack_require__(177)), _CellSizeAndPositionManager = _interopRequireDefault(__webpack_require__(189)), _maxElementSize = __webpack_require__(191), ScalingCellSizeAndPositionManager = (__webpack_require__(190), 
        /*#__PURE__*/
        function() {
            function ScalingCellSizeAndPositionManager(_ref) {
                var _ref$maxScrollSize = _ref.maxScrollSize, maxScrollSize = void 0 === _ref$maxScrollSize ? (0, 
                _maxElementSize.getMaxElementSize)() : _ref$maxScrollSize, params = (0, _objectWithoutProperties2.default)(_ref, [ "maxScrollSize" ]);
                (0, _classCallCheck2.default)(this, ScalingCellSizeAndPositionManager), (0, _defineProperty2.default)(this, "_cellSizeAndPositionManager", void 0), 
                (0, _defineProperty2.default)(this, "_maxScrollSize", void 0), // Favor composition over inheritance to simplify IE10 support
                this._cellSizeAndPositionManager = new _CellSizeAndPositionManager.default(params), 
                this._maxScrollSize = maxScrollSize;
            }
            return (0, _createClass2.default)(ScalingCellSizeAndPositionManager, [ {
                key: "areOffsetsAdjusted",
                value: function() {
                    return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
                }
            }, {
                key: "configure",
                value: function(params) {
                    this._cellSizeAndPositionManager.configure(params);
                }
            }, {
                key: "getCellCount",
                value: function() {
                    return this._cellSizeAndPositionManager.getCellCount();
                }
            }, {
                key: "getEstimatedCellSize",
                value: function() {
                    return this._cellSizeAndPositionManager.getEstimatedCellSize();
                }
            }, {
                key: "getLastMeasuredIndex",
                value: function() {
                    return this._cellSizeAndPositionManager.getLastMeasuredIndex();
                }
            }, {
                key: "getOffsetAdjustment",
                value: function(_ref2) {
                    var containerSize = _ref2.containerSize, offset = _ref2.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize(), offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: safeTotalSize
                    });
                    return Math.round(offsetPercentage * (safeTotalSize - totalSize));
                }
            }, {
                key: "getSizeAndPositionOfCell",
                value: function(index) {
                    return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
                }
            }, {
                key: "getSizeAndPositionOfLastMeasuredCell",
                value: function() {
                    return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
                }
            }, {
                key: "getTotalSize",
                value: function() {
                    return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
                }
            }, {
                key: "getUpdatedOffsetForIndex",
                value: function(_ref3) {
                    var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
                    currentOffset = this._safeOffsetToOffset({
                        containerSize: containerSize,
                        offset: currentOffset
                    });
                    var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
                        align: align,
                        containerSize: containerSize,
                        currentOffset: currentOffset,
                        targetIndex: targetIndex
                    });
                    return this._offsetToSafeOffset({
                        containerSize: containerSize,
                        offset: offset
                    });
                }
            }, {
                key: "getVisibleCellRange",
                value: function(_ref4) {
                    var containerSize = _ref4.containerSize, offset = _ref4.offset;
                    return offset = this._safeOffsetToOffset({
                        containerSize: containerSize,
                        offset: offset
                    }), this._cellSizeAndPositionManager.getVisibleCellRange({
                        containerSize: containerSize,
                        offset: offset
                    });
                }
            }, {
                key: "resetCell",
                value: function(index) {
                    this._cellSizeAndPositionManager.resetCell(index);
                }
            }, {
                key: "_getOffsetPercentage",
                value: function(_ref5) {
                    var containerSize = _ref5.containerSize, offset = _ref5.offset, totalSize = _ref5.totalSize;
                    return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
                }
            }, {
                key: "_offsetToSafeOffset",
                value: function(_ref6) {
                    var containerSize = _ref6.containerSize, offset = _ref6.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                    if (totalSize === safeTotalSize) return offset;
                    var offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: totalSize
                    });
                    return Math.round(offsetPercentage * (safeTotalSize - containerSize));
                }
            }, {
                key: "_safeOffsetToOffset",
                value: function(_ref7) {
                    var containerSize = _ref7.containerSize, offset = _ref7.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                    if (totalSize === safeTotalSize) return offset;
                    var offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: safeTotalSize
                    });
                    return Math.round(offsetPercentage * (totalSize - containerSize));
                }
            } ]), ScalingCellSizeAndPositionManager;
        }());
        exports.default = ScalingCellSizeAndPositionManager;
    }, /* 187 */
    /***/
    function(module, exports, __webpack_require__) {
        function _objectWithoutProperties(source, excluded) {
            if (null == source) return {};
            var key, i, target = objectWithoutPropertiesLoose(source, excluded);
            if (Object.getOwnPropertySymbols) {
                var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                for (i = 0; i < sourceSymbolKeys.length; i++) key = sourceSymbolKeys[i], excluded.indexOf(key) >= 0 || Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }
        var objectWithoutPropertiesLoose = __webpack_require__(188);
        module.exports = _objectWithoutProperties;
    }, /* 188 */
    /***/
    function(module, exports) {
        function _objectWithoutPropertiesLoose(source, excluded) {
            if (null == source) return {};
            var key, i, target = {}, sourceKeys = Object.keys(source);
            for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
            return target;
        }
        module.exports = _objectWithoutPropertiesLoose;
    }, /* 189 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var _interopRequireDefault = __webpack_require__(166);
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _classCallCheck2 = _interopRequireDefault(__webpack_require__(170)), _createClass2 = _interopRequireDefault(__webpack_require__(171)), _defineProperty2 = _interopRequireDefault(__webpack_require__(177)), CellSizeAndPositionManager = (__webpack_require__(190), 
        /*#__PURE__*/
        function() {
            // Cache of size and position data for cells, mapped by cell index.
            // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex
            // Measurements for cells up to this index can be trusted; cells afterward should be estimated.
            // Used in deferred mode to track which cells have been queued for measurement.
            function CellSizeAndPositionManager(_ref) {
                var cellCount = _ref.cellCount, cellSizeGetter = _ref.cellSizeGetter, estimatedCellSize = _ref.estimatedCellSize;
                (0, _classCallCheck2.default)(this, CellSizeAndPositionManager), (0, _defineProperty2.default)(this, "_cellSizeAndPositionData", {}), 
                (0, _defineProperty2.default)(this, "_lastMeasuredIndex", -1), (0, _defineProperty2.default)(this, "_lastBatchedIndex", -1), 
                (0, _defineProperty2.default)(this, "_cellCount", void 0), (0, _defineProperty2.default)(this, "_cellSizeGetter", void 0), 
                (0, _defineProperty2.default)(this, "_estimatedCellSize", void 0), this._cellSizeGetter = cellSizeGetter, 
                this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize;
            }
            return (0, _createClass2.default)(CellSizeAndPositionManager, [ {
                key: "areOffsetsAdjusted",
                value: function() {
                    return !1;
                }
            }, {
                key: "configure",
                value: function(_ref2) {
                    var cellCount = _ref2.cellCount, estimatedCellSize = _ref2.estimatedCellSize, cellSizeGetter = _ref2.cellSizeGetter;
                    this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize, this._cellSizeGetter = cellSizeGetter;
                }
            }, {
                key: "getCellCount",
                value: function() {
                    return this._cellCount;
                }
            }, {
                key: "getEstimatedCellSize",
                value: function() {
                    return this._estimatedCellSize;
                }
            }, {
                key: "getLastMeasuredIndex",
                value: function() {
                    return this._lastMeasuredIndex;
                }
            }, {
                key: "getOffsetAdjustment",
                value: function() {
                    return 0;
                }
            }, {
                key: "getSizeAndPositionOfCell",
                value: function(index) {
                    if (index < 0 || index >= this._cellCount) throw Error("Requested index ".concat(index, " is outside of range 0..").concat(this._cellCount));
                    if (index > this._lastMeasuredIndex) for (var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size, i = this._lastMeasuredIndex + 1; i <= index; i++) {
                        var size = this._cellSizeGetter({
                            index: i
                        });
                        // undefined or NaN probably means a logic error in the size getter.
                        // null means we're using CellMeasurer and haven't yet measured a given index.
                        if (void 0 === size || isNaN(size)) throw Error("Invalid size returned for cell ".concat(i, " of value ").concat(size));
                        null === size ? (this._cellSizeAndPositionData[i] = {
                            offset: offset,
                            size: 0
                        }, this._lastBatchedIndex = index) : (this._cellSizeAndPositionData[i] = {
                            offset: offset,
                            size: size
                        }, offset += size, this._lastMeasuredIndex = index);
                    }
                    return this._cellSizeAndPositionData[index];
                }
            }, {
                key: "getSizeAndPositionOfLastMeasuredCell",
                value: function() {
                    return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
                        offset: 0,
                        size: 0
                    };
                }
            }, {
                key: "getTotalSize",
                value: function() {
                    var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size, numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1, totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
                    return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
                }
            }, {
                key: "getUpdatedOffsetForIndex",
                value: function(_ref3) {
                    var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
                    if (containerSize <= 0) return 0;
                    var idealOffset, datum = this.getSizeAndPositionOfCell(targetIndex), maxOffset = datum.offset, minOffset = maxOffset - containerSize + datum.size;
                    switch (align) {
                      case "start":
                        idealOffset = maxOffset;
                        break;

                      case "end":
                        idealOffset = minOffset;
                        break;

                      case "center":
                        idealOffset = maxOffset - (containerSize - datum.size) / 2;
                        break;

                      default:
                        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
                    }
                    var totalSize = this.getTotalSize();
                    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
                }
            }, {
                key: "getVisibleCellRange",
                value: function(params) {
                    var containerSize = params.containerSize, offset = params.offset, totalSize = this.getTotalSize();
                    if (0 === totalSize) return {};
                    var maxOffset = offset + containerSize, start = this._findNearestCell(offset), datum = this.getSizeAndPositionOfCell(start);
                    offset = datum.offset + datum.size;
                    for (var stop = start; offset < maxOffset && stop < this._cellCount - 1; ) stop++, 
                    offset += this.getSizeAndPositionOfCell(stop).size;
                    return {
                        start: start,
                        stop: stop
                    };
                }
            }, {
                key: "resetCell",
                value: function(index) {
                    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
                }
            }, {
                key: "_binarySearch",
                value: function(high, low, offset) {
                    for (;low <= high; ) {
                        var middle = low + Math.floor((high - low) / 2), currentOffset = this.getSizeAndPositionOfCell(middle).offset;
                        if (currentOffset === offset) return middle;
                        currentOffset < offset ? low = middle + 1 : currentOffset > offset && (high = middle - 1);
                    }
                    return low > 0 ? low - 1 : 0;
                }
            }, {
                key: "_exponentialSearch",
                value: function(index, offset) {
                    for (var interval = 1; index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset; ) index += interval, 
                    interval *= 2;
                    return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
                }
            }, {
                key: "_findNearestCell",
                value: function(offset) {
                    if (isNaN(offset)) throw Error("Invalid offset ".concat(offset, " specified"));
                    // Our search algorithms find the nearest match at or below the specified offset.
                    // So make sure the offset is at least 0 or no match will be found.
                    offset = Math.max(0, offset);
                    var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
                    return lastMeasuredCellSizeAndPosition.offset >= offset ? this._binarySearch(lastMeasuredIndex, 0, offset) : this._exponentialSearch(lastMeasuredIndex, offset);
                }
            } ]), CellSizeAndPositionManager;
        }());
        exports.default = CellSizeAndPositionManager;
    }, /* 190 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(166), _interopRequireWildcard = __webpack_require__(168);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.bpfrpt_proptype_VisibleCellRange = exports.bpfrpt_proptype_Alignment = exports.bpfrpt_proptype_OverscanIndicesGetter = exports.bpfrpt_proptype_OverscanIndices = exports.bpfrpt_proptype_OverscanIndicesGetterParams = exports.bpfrpt_proptype_RenderedSection = exports.bpfrpt_proptype_ScrollbarPresenceChange = exports.bpfrpt_proptype_Scroll = exports.bpfrpt_proptype_NoContentRenderer = exports.bpfrpt_proptype_CellSize = exports.bpfrpt_proptype_CellSizeGetter = exports.bpfrpt_proptype_CellRangeRenderer = exports.bpfrpt_proptype_CellRangeRendererParams = exports.bpfrpt_proptype_StyleCache = exports.bpfrpt_proptype_CellCache = exports.bpfrpt_proptype_CellRenderer = exports.bpfrpt_proptype_CellRendererParams = exports.bpfrpt_proptype_CellPosition = void 0;
            var _ScalingCellSizeAndPositionManager = (_interopRequireWildcard(__webpack_require__(108)), 
            _interopRequireDefault(__webpack_require__(186))), _propTypes = _interopRequireDefault(__webpack_require__(109)), bpfrpt_proptype_CellPosition = "production" === process.env.NODE_ENV ? null : {
                columnIndex: _propTypes.default.number.isRequired,
                rowIndex: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_CellPosition = bpfrpt_proptype_CellPosition;
            var bpfrpt_proptype_CellRendererParams = "production" === process.env.NODE_ENV ? null : {
                columnIndex: _propTypes.default.number.isRequired,
                isScrolling: _propTypes.default.bool.isRequired,
                isVisible: _propTypes.default.bool.isRequired,
                key: _propTypes.default.string.isRequired,
                parent: _propTypes.default.object.isRequired,
                rowIndex: _propTypes.default.number.isRequired,
                style: _propTypes.default.object.isRequired
            };
            exports.bpfrpt_proptype_CellRendererParams = bpfrpt_proptype_CellRendererParams;
            var bpfrpt_proptype_CellRenderer = "production" === process.env.NODE_ENV ? null : _propTypes.default.func;
            exports.bpfrpt_proptype_CellRenderer = bpfrpt_proptype_CellRenderer;
            var bpfrpt_proptype_CellCache = "production" === process.env.NODE_ENV ? null : _propTypes.default.objectOf(_propTypes.default.node.isRequired);
            exports.bpfrpt_proptype_CellCache = bpfrpt_proptype_CellCache;
            var bpfrpt_proptype_StyleCache = "production" === process.env.NODE_ENV ? null : _propTypes.default.objectOf(_propTypes.default.object.isRequired);
            exports.bpfrpt_proptype_StyleCache = bpfrpt_proptype_StyleCache;
            var bpfrpt_proptype_CellRangeRendererParams = "production" === process.env.NODE_ENV ? null : {
                cellCache: _propTypes.default.objectOf(_propTypes.default.node.isRequired).isRequired,
                cellRenderer: _propTypes.default.func.isRequired,
                columnSizeAndPositionManager: function() {
                    return ("function" == typeof _ScalingCellSizeAndPositionManager.default ? _propTypes.default.instanceOf(_ScalingCellSizeAndPositionManager.default).isRequired : _propTypes.default.any.isRequired).apply(this, arguments);
                },
                columnStartIndex: _propTypes.default.number.isRequired,
                columnStopIndex: _propTypes.default.number.isRequired,
                deferredMeasurementCache: _propTypes.default.object,
                horizontalOffsetAdjustment: _propTypes.default.number.isRequired,
                isScrolling: _propTypes.default.bool.isRequired,
                isScrollingOptOut: _propTypes.default.bool.isRequired,
                parent: _propTypes.default.object.isRequired,
                rowSizeAndPositionManager: function() {
                    return ("function" == typeof _ScalingCellSizeAndPositionManager.default ? _propTypes.default.instanceOf(_ScalingCellSizeAndPositionManager.default).isRequired : _propTypes.default.any.isRequired).apply(this, arguments);
                },
                rowStartIndex: _propTypes.default.number.isRequired,
                rowStopIndex: _propTypes.default.number.isRequired,
                scrollLeft: _propTypes.default.number.isRequired,
                scrollTop: _propTypes.default.number.isRequired,
                styleCache: _propTypes.default.objectOf(_propTypes.default.object.isRequired).isRequired,
                verticalOffsetAdjustment: _propTypes.default.number.isRequired,
                visibleColumnIndices: _propTypes.default.object.isRequired,
                visibleRowIndices: _propTypes.default.object.isRequired
            };
            exports.bpfrpt_proptype_CellRangeRendererParams = bpfrpt_proptype_CellRangeRendererParams;
            var bpfrpt_proptype_CellRangeRenderer = "production" === process.env.NODE_ENV ? null : _propTypes.default.func;
            exports.bpfrpt_proptype_CellRangeRenderer = bpfrpt_proptype_CellRangeRenderer;
            var bpfrpt_proptype_CellSizeGetter = "production" === process.env.NODE_ENV ? null : _propTypes.default.func;
            exports.bpfrpt_proptype_CellSizeGetter = bpfrpt_proptype_CellSizeGetter;
            var bpfrpt_proptype_CellSize = "production" === process.env.NODE_ENV ? null : _propTypes.default.oneOfType([ _propTypes.default.func, _propTypes.default.number ]);
            exports.bpfrpt_proptype_CellSize = bpfrpt_proptype_CellSize;
            var bpfrpt_proptype_NoContentRenderer = "production" === process.env.NODE_ENV ? null : _propTypes.default.func;
            exports.bpfrpt_proptype_NoContentRenderer = bpfrpt_proptype_NoContentRenderer;
            var bpfrpt_proptype_Scroll = "production" === process.env.NODE_ENV ? null : {
                clientHeight: _propTypes.default.number.isRequired,
                clientWidth: _propTypes.default.number.isRequired,
                scrollHeight: _propTypes.default.number.isRequired,
                scrollLeft: _propTypes.default.number.isRequired,
                scrollTop: _propTypes.default.number.isRequired,
                scrollWidth: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_Scroll = bpfrpt_proptype_Scroll;
            var bpfrpt_proptype_ScrollbarPresenceChange = "production" === process.env.NODE_ENV ? null : {
                horizontal: _propTypes.default.bool.isRequired,
                vertical: _propTypes.default.bool.isRequired,
                size: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_ScrollbarPresenceChange = bpfrpt_proptype_ScrollbarPresenceChange;
            var bpfrpt_proptype_RenderedSection = "production" === process.env.NODE_ENV ? null : {
                columnOverscanStartIndex: _propTypes.default.number.isRequired,
                columnOverscanStopIndex: _propTypes.default.number.isRequired,
                columnStartIndex: _propTypes.default.number.isRequired,
                columnStopIndex: _propTypes.default.number.isRequired,
                rowOverscanStartIndex: _propTypes.default.number.isRequired,
                rowOverscanStopIndex: _propTypes.default.number.isRequired,
                rowStartIndex: _propTypes.default.number.isRequired,
                rowStopIndex: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_RenderedSection = bpfrpt_proptype_RenderedSection;
            var bpfrpt_proptype_OverscanIndicesGetterParams = "production" === process.env.NODE_ENV ? null : {
                // One of SCROLL_DIRECTION_HORIZONTAL or SCROLL_DIRECTION_VERTICAL
                direction: _propTypes.default.oneOf([ "horizontal", "vertical" ]).isRequired,
                // One of SCROLL_DIRECTION_BACKWARD or SCROLL_DIRECTION_FORWARD
                scrollDirection: _propTypes.default.oneOf([ -1, 1 ]).isRequired,
                // Number of rows or columns in the current axis
                cellCount: _propTypes.default.number.isRequired,
                // Maximum number of cells to over-render in either direction
                overscanCellsCount: _propTypes.default.number.isRequired,
                // Begin of range of visible cells
                startIndex: _propTypes.default.number.isRequired,
                // End of range of visible cells
                stopIndex: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_OverscanIndicesGetterParams = bpfrpt_proptype_OverscanIndicesGetterParams;
            var bpfrpt_proptype_OverscanIndices = "production" === process.env.NODE_ENV ? null : {
                overscanStartIndex: _propTypes.default.number.isRequired,
                overscanStopIndex: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_OverscanIndices = bpfrpt_proptype_OverscanIndices;
            var bpfrpt_proptype_OverscanIndicesGetter = "production" === process.env.NODE_ENV ? null : _propTypes.default.func;
            exports.bpfrpt_proptype_OverscanIndicesGetter = bpfrpt_proptype_OverscanIndicesGetter;
            var bpfrpt_proptype_Alignment = "production" === process.env.NODE_ENV ? null : _propTypes.default.oneOf([ "auto", "end", "start", "center" ]);
            exports.bpfrpt_proptype_Alignment = bpfrpt_proptype_Alignment;
            var bpfrpt_proptype_VisibleCellRange = "production" === process.env.NODE_ENV ? null : {
                start: _propTypes.default.number,
                stop: _propTypes.default.number
            };
            exports.bpfrpt_proptype_VisibleCellRange = bpfrpt_proptype_VisibleCellRange;
        }).call(exports, __webpack_require__(110));
    }, /* 191 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getMaxElementSize = void 0;
        var DEFAULT_MAX_ELEMENT_SIZE = 15e5, CHROME_MAX_ELEMENT_SIZE = 16777100, isBrowser = function() {
            return "undefined" != typeof window;
        }, isChrome = function() {
            return !!window.chrome;
        }, getMaxElementSize = function() {
            return isBrowser() && isChrome() ? CHROME_MAX_ELEMENT_SIZE : DEFAULT_MAX_ELEMENT_SIZE;
        };
        exports.getMaxElementSize = getMaxElementSize;
    }, /* 192 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Helper utility that updates the specified callback whenever any of the specified indices have changed.
	 */
        function createCallbackMemoizer() {
            var requireAllKeys = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], cachedIndices = {};
            return function(_ref) {
                var callback = _ref.callback, indices = _ref.indices, keys = Object.keys(indices), allInitialized = !requireAllKeys || keys.every(function(key) {
                    var value = indices[key];
                    return Array.isArray(value) ? value.length > 0 : value >= 0;
                }), indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some(function(key) {
                    var cachedValue = cachedIndices[key], value = indices[key];
                    return Array.isArray(value) ? cachedValue.join(",") !== value.join(",") : cachedValue !== value;
                });
                cachedIndices = indices, allInitialized && indexChanged && callback(indices);
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = createCallbackMemoizer;
    }, /* 193 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function defaultOverscanIndicesGetter(_ref) {
            var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
            return scrollDirection === SCROLL_DIRECTION_FORWARD ? {
                overscanStartIndex: Math.max(0, startIndex),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
            } : {
                overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex)
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = defaultOverscanIndicesGetter, exports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;
        var SCROLL_DIRECTION_BACKWARD = (__webpack_require__(190), -1);
        exports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;
        var SCROLL_DIRECTION_FORWARD = 1;
        exports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;
        var SCROLL_DIRECTION_HORIZONTAL = "horizontal";
        exports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;
        var SCROLL_DIRECTION_VERTICAL = "vertical";
        /**
	 * Calculates the number of cells to overscan before and after a specified range.
	 * This function ensures that overscanning doesn't exceed the available cells.
	 */
        exports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;
    }, /* 194 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function updateScrollIndexHelper(_ref) {
            var cellSize = _ref.cellSize, cellSizeAndPositionManager = _ref.cellSizeAndPositionManager, previousCellsCount = _ref.previousCellsCount, previousCellSize = _ref.previousCellSize, previousScrollToAlignment = _ref.previousScrollToAlignment, previousScrollToIndex = _ref.previousScrollToIndex, previousSize = _ref.previousSize, scrollOffset = _ref.scrollOffset, scrollToAlignment = _ref.scrollToAlignment, scrollToIndex = _ref.scrollToIndex, size = _ref.size, sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero, updateScrollIndexCallback = _ref.updateScrollIndexCallback, cellCount = cellSizeAndPositionManager.getCellCount(), hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount, sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || "number" == typeof cellSize && cellSize !== previousCellSize;
            // If we have a new scroll target OR if height/row-height has changed,
            // We should ensure that the scroll target is visible.
            hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex) ? updateScrollIndexCallback(scrollToIndex) : !hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount) && scrollOffset > cellSizeAndPositionManager.getTotalSize() - size && updateScrollIndexCallback(cellCount - 1);
        }
        var _interopRequireDefault = __webpack_require__(166);
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = updateScrollIndexHelper;
        _interopRequireDefault(__webpack_require__(186)), __webpack_require__(190);
    }, /* 195 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            /**
	 * Default implementation of cellRangeRenderer used by Grid.
	 * This renderer supports cell-caching while the user is scrolling.
	 */
            function defaultCellRangeRenderer(_ref) {
                for (var cellCache = _ref.cellCache, cellRenderer = _ref.cellRenderer, columnSizeAndPositionManager = _ref.columnSizeAndPositionManager, columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, deferredMeasurementCache = _ref.deferredMeasurementCache, horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment, isScrolling = _ref.isScrolling, isScrollingOptOut = _ref.isScrollingOptOut, parent = _ref.parent, rowSizeAndPositionManager = _ref.rowSizeAndPositionManager, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex, styleCache = _ref.styleCache, verticalOffsetAdjustment = _ref.verticalOffsetAdjustment, visibleColumnIndices = _ref.visibleColumnIndices, visibleRowIndices = _ref.visibleRowIndices, renderedCells = [], areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted(), canCacheStyle = !isScrolling && !areOffsetsAdjusted, rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) for (var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex), columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
                    var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex), isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop, key = "".concat(rowIndex, "-").concat(columnIndex), style = void 0;
                    // Cache style objects so shallow-compare doesn't re-render unnecessarily.
                    canCacheStyle && styleCache[key] ? style = styleCache[key] : // In deferred mode, cells will be initially rendered before we know their size.
                    // Don't interfere with CellMeasurer's measurements by setting an invalid size.
                    deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex) ? // Position not-yet-measured cells at top/left 0,0,
                    // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.
                    // Positioning them further to the right/bottom influences their measured size.
                    style = {
                        height: "auto",
                        left: 0,
                        position: "absolute",
                        top: 0,
                        width: "auto"
                    } : (style = {
                        height: rowDatum.size,
                        left: columnDatum.offset + horizontalOffsetAdjustment,
                        position: "absolute",
                        top: rowDatum.offset + verticalOffsetAdjustment,
                        width: columnDatum.size
                    }, styleCache[key] = style);
                    var cellRendererParams = {
                        columnIndex: columnIndex,
                        isScrolling: isScrolling,
                        isVisible: isVisible,
                        key: key,
                        parent: parent,
                        rowIndex: rowIndex,
                        style: style
                    }, renderedCell = void 0;
                    // Avoid re-creating cells while scrolling.
                    // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
                    // If a scroll is in progress- cache and reuse cells.
                    // This cache will be thrown away once scrolling completes.
                    // However if we are scaling scroll positions and sizes, we should also avoid caching.
                    // This is because the offset changes slightly as scroll position changes and caching leads to stale values.
                    // For more info refer to issue #395
                    //
                    // If isScrollingOptOut is specified, we always cache cells.
                    // For more info refer to issue #1028
                    !isScrollingOptOut && !isScrolling || horizontalOffsetAdjustment || verticalOffsetAdjustment ? renderedCell = cellRenderer(cellRendererParams) : (cellCache[key] || (cellCache[key] = cellRenderer(cellRendererParams)), 
                    renderedCell = cellCache[key]), null != renderedCell && renderedCell !== !1 && ("production" !== process.env.NODE_ENV && warnAboutMissingStyle(parent, renderedCell), 
                    renderedCells.push(renderedCell));
                }
                return renderedCells;
            }
            function warnAboutMissingStyle(parent, renderedCell) {
                "production" !== process.env.NODE_ENV && renderedCell && (// If the direct child is a CellMeasurer, then we should check its child
                // See issue #611
                renderedCell.type && renderedCell.type.__internalCellMeasurerFlag && (renderedCell = renderedCell.props.children), 
                renderedCell && renderedCell.props && void 0 === renderedCell.props.style && parent.__warnedAboutMissingStyle !== !0 && (parent.__warnedAboutMissingStyle = !0, 
                console.warn("Rendered cell should include style property for positioning.")));
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = defaultCellRangeRenderer;
            __webpack_require__(190);
        }).call(exports, __webpack_require__(110));
    }, /* 196 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function scrollbarSize(recalc) {
            if ((!size && 0 !== size || recalc) && _canUseDOM.default) {
                var scrollDiv = document.createElement("div");
                scrollDiv.style.position = "absolute", scrollDiv.style.top = "-9999px", scrollDiv.style.width = "50px", 
                scrollDiv.style.height = "50px", scrollDiv.style.overflow = "scroll", document.body.appendChild(scrollDiv), 
                size = scrollDiv.offsetWidth - scrollDiv.clientWidth, document.body.removeChild(scrollDiv);
            }
            return size;
        }
        var _interopRequireDefault = __webpack_require__(166);
        exports.__esModule = !0, exports.default = scrollbarSize;
        var size, _canUseDOM = _interopRequireDefault(__webpack_require__(197));
        module.exports = exports.default;
    }, /* 197 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0, exports.default = void 0;
        var _default = !("undefined" == typeof window || !window.document || !window.document.createElement);
        exports.default = _default, module.exports = exports.default;
    }, /* 198 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
        function componentWillMount() {
            // Call this.constructor.gDSFP to support sub-classes.
            var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
            null !== state && void 0 !== state && this.setState(state);
        }
        function componentWillReceiveProps(nextProps) {
            // Call this.constructor.gDSFP to support sub-classes.
            // Use the setState() updater to ensure state isn't stale in certain edge cases.
            function updater(prevState) {
                var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
                return null !== state && void 0 !== state ? state : null;
            }
            // Binding "this" is important for shallow renderer support.
            this.setState(updater.bind(this));
        }
        function componentWillUpdate(nextProps, nextState) {
            try {
                var prevProps = this.props, prevState = this.state;
                this.props = nextProps, this.state = nextState, this.__reactInternalSnapshotFlag = !0, 
                this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
            } finally {
                this.props = prevProps, this.state = prevState;
            }
        }
        function polyfill(Component) {
            var prototype = Component.prototype;
            if (!prototype || !prototype.isReactComponent) throw new Error("Can only polyfill class components");
            if ("function" != typeof Component.getDerivedStateFromProps && "function" != typeof prototype.getSnapshotBeforeUpdate) return Component;
            // If new component APIs are defined, "unsafe" lifecycles won't be called.
            // Error if any of these lifecycles are present,
            // Because they would work differently between older and newer (16.3+) versions of React.
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            if ("function" == typeof prototype.componentWillMount ? foundWillMountName = "componentWillMount" : "function" == typeof prototype.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount"), 
            "function" == typeof prototype.componentWillReceiveProps ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" == typeof prototype.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), 
            "function" == typeof prototype.componentWillUpdate ? foundWillUpdateName = "componentWillUpdate" : "function" == typeof prototype.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), 
            null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                var componentName = Component.displayName || Component.name, newApiName = "function" == typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (null !== foundWillMountName ? "\n  " + foundWillMountName : "") + (null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "") + (null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks");
            }
            // React <= 16.2 does not support getSnapshotBeforeUpdate.
            // As a workaround, use cWU to invoke the new lifecycle.
            // Newer versions of React will ignore that lifecycle if gSBU exists.
            if (// React <= 16.2 does not support static getDerivedStateFromProps.
            // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
            // Newer versions of React will ignore these lifecycles if gDSFP exists.
            "function" == typeof Component.getDerivedStateFromProps && (prototype.componentWillMount = componentWillMount, 
            prototype.componentWillReceiveProps = componentWillReceiveProps), "function" == typeof prototype.getSnapshotBeforeUpdate) {
                if ("function" != typeof prototype.componentDidUpdate) throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
                prototype.componentWillUpdate = componentWillUpdate;
                var componentDidUpdate = prototype.componentDidUpdate;
                prototype.componentDidUpdate = function(prevProps, prevState, maybeSnapshot) {
                    // 16.3+ will not execute our will-update method;
                    // It will pass a snapshot value to did-update though.
                    // Older versions will require our polyfilled will-update value.
                    // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
                    // Because for <= 15.x versions this might be a "prevContext" object.
                    // We also can't just check "__reactInternalSnapshot",
                    // Because get-snapshot might return a falsy value.
                    // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
                    var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
                    componentDidUpdate.call(this, prevProps, prevState, snapshot);
                };
            }
            return Component;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), // React may warn about cWM/cWRP/cWU methods being deprecated.
        // Add a flag to suppress these warnings for this special case.
        componentWillMount.__suppressDeprecationWarning = !0, componentWillReceiveProps.__suppressDeprecationWarning = !0, 
        componentWillUpdate.__suppressDeprecationWarning = !0, exports.polyfill = polyfill;
    }, /* 199 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(166);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.bpfrpt_proptype_AnimationTimeoutId = exports.requestAnimationTimeout = exports.cancelAnimationTimeout = void 0;
            var _animationFrame = __webpack_require__(200), _propTypes = _interopRequireDefault(__webpack_require__(109)), bpfrpt_proptype_AnimationTimeoutId = "production" === process.env.NODE_ENV ? null : {
                id: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_AnimationTimeoutId = bpfrpt_proptype_AnimationTimeoutId;
            var cancelAnimationTimeout = function(frame) {
                return (0, _animationFrame.caf)(frame.id);
            };
            /**
	 * Recursively calls requestAnimationFrame until a specified delay has been met or exceeded.
	 * When the delay time has been reached the function you're timing out will be called.
	 *
	 * Credit: Joe Lambert (https://gist.github.com/joelambert/1002116#file-requesttimeout-js)
	 */
            exports.cancelAnimationTimeout = cancelAnimationTimeout;
            var requestAnimationTimeout = function(callback, delay) {
                var start;
                // wait for end of processing current event handler, because event handler may be long
                Promise.resolve().then(function() {
                    start = Date.now();
                });
                var timeout = function timeout() {
                    Date.now() - start >= delay ? callback.call() : frame.id = (0, _animationFrame.raf)(timeout);
                }, frame = {
                    id: (0, _animationFrame.raf)(timeout)
                };
                return frame;
            };
            exports.requestAnimationTimeout = requestAnimationTimeout;
        }).call(exports, __webpack_require__(110));
    }, /* 200 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.caf = exports.raf = void 0;
        // Properly handle server-side rendering.
        var win;
        win = "undefined" != typeof window ? window : "undefined" != typeof self ? self : {};
        // requestAnimationFrame() shim by Paul Irish
        // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        var request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function(callback) {
            return win.setTimeout(callback, 1e3 / 60);
        }, cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function(id) {
            win.clearTimeout(id);
        }, raf = request;
        exports.raf = raf;
        var caf = cancel;
        exports.caf = caf;
    }, /* 201 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function defaultOverscanIndicesGetter(_ref) {
            var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
            // Make sure we render at least 1 cell extra before and after (except near boundaries)
            // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases
            // For more info see issues #625
            return overscanCellsCount = Math.max(1, overscanCellsCount), scrollDirection === SCROLL_DIRECTION_FORWARD ? {
                overscanStartIndex: Math.max(0, startIndex - 1),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
            } : {
                overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
                overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = defaultOverscanIndicesGetter, exports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;
        var SCROLL_DIRECTION_BACKWARD = (__webpack_require__(190), -1);
        exports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;
        var SCROLL_DIRECTION_FORWARD = 1;
        exports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;
        var SCROLL_DIRECTION_HORIZONTAL = "horizontal";
        exports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;
        var SCROLL_DIRECTION_VERTICAL = "vertical";
        /**
	 * Calculates the number of cells to overscan before and after a specified range.
	 * This function ensures that overscanning doesn't exceed the available cells.
	 */
        exports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;
    }, /* 202 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            var _interopRequireDefault = __webpack_require__(166), _interopRequireWildcard = __webpack_require__(168);
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.bpfrpt_proptype_Scroll = exports.bpfrpt_proptype_RenderedRows = exports.bpfrpt_proptype_RowRenderer = exports.bpfrpt_proptype_RowRendererParams = void 0;
            var _propTypes = (_interopRequireWildcard(__webpack_require__(108)), _interopRequireDefault(__webpack_require__(109))), bpfrpt_proptype_RowRendererParams = "production" === process.env.NODE_ENV ? null : {
                index: _propTypes.default.number.isRequired,
                isScrolling: _propTypes.default.bool.isRequired,
                isVisible: _propTypes.default.bool.isRequired,
                key: _propTypes.default.string.isRequired,
                parent: _propTypes.default.object.isRequired,
                style: _propTypes.default.object.isRequired
            };
            exports.bpfrpt_proptype_RowRendererParams = bpfrpt_proptype_RowRendererParams;
            var bpfrpt_proptype_RowRenderer = "production" === process.env.NODE_ENV ? null : _propTypes.default.func;
            exports.bpfrpt_proptype_RowRenderer = bpfrpt_proptype_RowRenderer;
            var bpfrpt_proptype_RenderedRows = "production" === process.env.NODE_ENV ? null : {
                overscanStartIndex: _propTypes.default.number.isRequired,
                overscanStopIndex: _propTypes.default.number.isRequired,
                startIndex: _propTypes.default.number.isRequired,
                stopIndex: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_RenderedRows = bpfrpt_proptype_RenderedRows;
            var bpfrpt_proptype_Scroll = "production" === process.env.NODE_ENV ? null : {
                clientHeight: _propTypes.default.number.isRequired,
                scrollHeight: _propTypes.default.number.isRequired,
                scrollTop: _propTypes.default.number.isRequired
            };
            exports.bpfrpt_proptype_Scroll = bpfrpt_proptype_Scroll;
        }).call(exports, __webpack_require__(110));
    }, /* 203 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  width: 2.5rem;\n  height: 2.5rem;\n  display: inline-flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  margin-left: 0.5rem;\n  padding: 0;\n  color: #fff;\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.25);\n  transition: 250ms all ease;\n" ], [ "\n  width: 2.5rem;\n  height: 2.5rem;\n  display: inline-flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  margin-left: 0.5rem;\n  padding: 0;\n  color: #fff;\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.25);\n  transition: 250ms all ease;\n" ]), _styledComponents = __webpack_require__(132), _styledComponents2 = _interopRequireDefault(_styledComponents);
        exports.default = _styledComponents2.default.button(_templateObject);
    }, /* 204 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function SvgIconWrapper(_ref) {
            var children = _ref.children, rest = (0, _objectWithoutProperties3.default)(_ref, [ "children" ]);
            return _react2.default.createElement("svg", (0, _extends3.default)({
                height: 24,
                preserveAspectRatio: "xMinYMax meet",
                viewBox: "0 0 24 24",
                width: 24
            }, rest), _react2.default.createElement("path", {
                d: "M0-.5h24v24H0z",
                fill: "none"
            }), children);
        }
        function IconLeft() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
            }));
        }
        function IconMore() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
            }));
        }
        function IconRight() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
            }));
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _objectWithoutProperties2 = __webpack_require__(205), _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  fill: currentColor;\n" ], [ "\n  fill: currentColor;\n" ]);
        exports.SvgIconWrapper = SvgIconWrapper, exports.IconLeft = IconLeft, exports.IconMore = IconMore, 
        exports.IconRight = IconRight;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(132), _styledComponents2 = _interopRequireDefault(_styledComponents), Path = _styledComponents2.default.path(_templateObject);
    }, /* 205 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0, exports.default = function(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        };
    }, /* 206 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slideContext = exports.presentationContext = void 0;
        var _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes);
        exports.presentationContext = _propTypes2.default.shape({
            getSlideIndex: _propTypes2.default.func.isRequired,
            getSlideMetadata: _propTypes2.default.func.isRequired,
            getStepIndex: _propTypes2.default.func.isRequired,
            goBack: _propTypes2.default.func.isRequired,
            goForward: _propTypes2.default.func.isRequired,
            goToSlide: _propTypes2.default.func.isRequired,
            isAtBeginning: _propTypes2.default.func.isRequired,
            isAtEnd: _propTypes2.default.func.isRequired,
            setPluginProps: _propTypes2.default.func.isRequired
        }), exports.slideContext = _propTypes2.default.shape({
            getNumSteps: _propTypes2.default.func.isRequired,
            registerStep: _propTypes2.default.func.isRequired,
            setNumSteps: _propTypes2.default.func.isRequired
        });
    }, /* 207 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  .Select {\n    position: relative;\n  }\n  .Select,\n  .Select div,\n  .Select input,\n  .Select span {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n  .Select.is-disabled > .Select-control {\n    background-color: #f9f9f9;\n  }\n  .Select.is-disabled > .Select-control:hover {\n    box-shadow: none;\n  }\n  .Select.is-disabled .Select-arrow-zone {\n    cursor: default;\n    pointer-events: none;\n    opacity: 0.35;\n  }\n  .Select-control {\n    background-color: #fff;\n    border-color: #d9d9d9 #ccc #b3b3b3;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    color: #333;\n    cursor: default;\n    display: table;\n    border-spacing: 0;\n    border-collapse: separate;\n    height: 36px;\n    outline: none;\n    overflow: hidden;\n    position: relative;\n    width: 100%;\n  }\n  .Select-control:hover {\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n  }\n  .Select-control .Select-input:focus {\n    outline: none;\n  }\n  .is-searchable.is-open > .Select-control {\n    cursor: text;\n  }\n  .is-open > .Select-control {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n    background: #fff;\n    border-color: #b3b3b3 #ccc #d9d9d9;\n  }\n  .is-open > .Select-control > .Select-arrow {\n    border-color: transparent transparent #999;\n    border-width: 0 5px 5px;\n  }\n  .is-searchable.is-focused:not(.is-open) > .Select-control {\n    cursor: text;\n  }\n  .is-focused:not(.is-open) > .Select-control {\n    border-color: #007eff;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 0 3px rgba(0, 126, 255, 0.1);\n  }\n  .Select-placeholder,\n  .Select--single > .Select-control .Select-value {\n    bottom: 0;\n    color: #aaa;\n    left: 0;\n    line-height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n  .has-value.Select--single > .Select-control .Select-value .Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value .Select-value-label {\n    color: #333;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label {\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:focus,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:focus {\n    color: #007eff;\n    outline: none;\n    text-decoration: underline;\n  }\n  .Select-input {\n    height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    vertical-align: middle;\n  }\n  .Select-input > input {\n    width: 100%;\n    background: none transparent;\n    border: 0 none;\n    box-shadow: none;\n    cursor: default;\n    display: inline-block;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    outline: none;\n    line-height: 14px;\n    /* For IE 8 compatibility */\n    padding: 8px 0 12px;\n    /* For IE 8 compatibility */\n    -webkit-appearance: none;\n  }\n  .is-focused .Select-input > input {\n    cursor: text;\n  }\n  .has-value.is-pseudo-focused .Select-input {\n    opacity: 0;\n  }\n  .Select-control:not(.is-searchable) > .Select-input {\n    outline: none;\n  }\n  .Select-loading-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 16px;\n  }\n  .Select-loading {\n    -webkit-animation: Select-animation-spin 400ms infinite linear;\n    -o-animation: Select-animation-spin 400ms infinite linear;\n    animation: Select-animation-spin 400ms infinite linear;\n    width: 16px;\n    height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    border: 2px solid #ccc;\n    border-right-color: #333;\n    display: inline-block;\n    position: relative;\n    vertical-align: middle;\n  }\n  .Select-clear-zone {\n    -webkit-animation: Select-animation-fadeIn 200ms;\n    -o-animation: Select-animation-fadeIn 200ms;\n    animation: Select-animation-fadeIn 200ms;\n    color: #999;\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 17px;\n  }\n  .Select-clear-zone:hover {\n    color: #D0021B;\n  }\n  .Select-clear {\n    display: inline-block;\n    font-size: 18px;\n    line-height: 1;\n  }\n  .Select--multi .Select-clear-zone {\n    width: 17px;\n  }\n  .Select-arrow-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 25px;\n    padding-right: 5px;\n  }\n  .Select-arrow {\n    border-color: #999 transparent transparent;\n    border-style: solid;\n    border-width: 5px 5px 2.5px;\n    display: inline-block;\n    height: 0;\n    width: 0;\n  }\n  .is-open .Select-arrow,\n  .Select-arrow-zone:hover > .Select-arrow {\n    border-top-color: #666;\n  }\n  .Select--multi .Select-multi-value-wrapper {\n    display: inline-block;\n  }\n  .Select .Select-aria-only {\n    display: inline-block;\n    height: 1px;\n    width: 1px;\n    margin: -1px;\n    clip: rect(0, 0, 0, 0);\n    overflow: hidden;\n  }\n  @-webkit-keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  @keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  .Select-menu-outer {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n    background-color: #fff;\n    border: 1px solid #ccc;\n    border-top-color: #e6e6e6;\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n    box-sizing: border-box;\n    margin-top: -1px;\n    max-height: 200px;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 1;\n    -webkit-overflow-scrolling: touch;\n  }\n  .Select-menu {\n    max-height: 198px;\n    overflow-y: auto;\n  }\n  .Select-option {\n    box-sizing: border-box;\n    background-color: #fff;\n    color: #666666;\n    cursor: pointer;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select-option:last-child {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n  .Select-option.is-selected {\n    background-color: #f5faff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.04);\n    color: #333;\n  }\n  .Select-option.is-focused {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    color: #333;\n  }\n  .Select-option.is-disabled {\n    color: #cccccc;\n    cursor: default;\n  }\n  .Select-noresults {\n    box-sizing: border-box;\n    color: #999999;\n    cursor: default;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select--multi .Select-input {\n    vertical-align: middle;\n    margin-left: 10px;\n    padding: 0;\n  }\n  .Select--multi.has-value .Select-input {\n    margin-left: 5px;\n  }\n  .Select--multi .Select-value {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    border-radius: 2px;\n    border: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border: 1px solid rgba(0, 126, 255, 0.24);\n    color: #007eff;\n    display: inline-block;\n    font-size: 0.9em;\n    line-height: 1.4;\n    margin-left: 5px;\n    margin-top: 5px;\n    vertical-align: top;\n  }\n  .Select--multi .Select-value-icon,\n  .Select--multi .Select-value-label {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  .Select--multi .Select-value-label {\n    border-bottom-right-radius: 2px;\n    border-top-right-radius: 2px;\n    cursor: default;\n    padding: 2px 5px;\n  }\n  .Select--multi a.Select-value-label {\n    color: #007eff;\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .Select--multi a.Select-value-label:hover {\n    text-decoration: underline;\n  }\n  .Select--multi .Select-value-icon {\n    cursor: pointer;\n    border-bottom-left-radius: 2px;\n    border-top-left-radius: 2px;\n    border-right: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border-right: 1px solid rgba(0, 126, 255, 0.24);\n    padding: 1px 5px 3px;\n  }\n  .Select--multi .Select-value-icon:hover,\n  .Select--multi .Select-value-icon:focus {\n    background-color: #d8eafd;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 113, 230, 0.08);\n    color: #0071e6;\n  }\n  .Select--multi .Select-value-icon:active {\n    background-color: #c2e0ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.24);\n  }\n  .Select--multi.is-disabled .Select-value {\n    background-color: #fcfcfc;\n    border: 1px solid #e3e3e3;\n    color: #333;\n  }\n  .Select--multi.is-disabled .Select-value-icon {\n    cursor: not-allowed;\n    border-right: 1px solid #e3e3e3;\n  }\n  .Select--multi.is-disabled .Select-value-icon:hover,\n  .Select--multi.is-disabled .Select-value-icon:focus,\n  .Select--multi.is-disabled .Select-value-icon:active {\n    background-color: #fcfcfc;\n  }\n  @keyframes Select-animation-spin {\n    to {\n      transform: rotate(1turn);\n    }\n  }\n  @-webkit-keyframes Select-animation-spin {\n    to {\n      -webkit-transform: rotate(1turn);\n    }\n  }\n\n  .VirtualSelectGrid {\n    z-index: 1;\n  }\n\n  .VirtualizedSelectOption {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    padding: 0 .5rem;\n  }\n  .VirtualizedSelectFocusedOption {\n    background-color: rgba(0, 126, 255, 0.1);\n  }\n  .VirtualizedSelectDisabledOption {\n    opacity: 0.5;\n  }\n" ], [ "\n  .Select {\n    position: relative;\n  }\n  .Select,\n  .Select div,\n  .Select input,\n  .Select span {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n  .Select.is-disabled > .Select-control {\n    background-color: #f9f9f9;\n  }\n  .Select.is-disabled > .Select-control:hover {\n    box-shadow: none;\n  }\n  .Select.is-disabled .Select-arrow-zone {\n    cursor: default;\n    pointer-events: none;\n    opacity: 0.35;\n  }\n  .Select-control {\n    background-color: #fff;\n    border-color: #d9d9d9 #ccc #b3b3b3;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    color: #333;\n    cursor: default;\n    display: table;\n    border-spacing: 0;\n    border-collapse: separate;\n    height: 36px;\n    outline: none;\n    overflow: hidden;\n    position: relative;\n    width: 100%;\n  }\n  .Select-control:hover {\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n  }\n  .Select-control .Select-input:focus {\n    outline: none;\n  }\n  .is-searchable.is-open > .Select-control {\n    cursor: text;\n  }\n  .is-open > .Select-control {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n    background: #fff;\n    border-color: #b3b3b3 #ccc #d9d9d9;\n  }\n  .is-open > .Select-control > .Select-arrow {\n    border-color: transparent transparent #999;\n    border-width: 0 5px 5px;\n  }\n  .is-searchable.is-focused:not(.is-open) > .Select-control {\n    cursor: text;\n  }\n  .is-focused:not(.is-open) > .Select-control {\n    border-color: #007eff;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 0 3px rgba(0, 126, 255, 0.1);\n  }\n  .Select-placeholder,\n  .Select--single > .Select-control .Select-value {\n    bottom: 0;\n    color: #aaa;\n    left: 0;\n    line-height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n  .has-value.Select--single > .Select-control .Select-value .Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value .Select-value-label {\n    color: #333;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label {\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:focus,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:focus {\n    color: #007eff;\n    outline: none;\n    text-decoration: underline;\n  }\n  .Select-input {\n    height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    vertical-align: middle;\n  }\n  .Select-input > input {\n    width: 100%;\n    background: none transparent;\n    border: 0 none;\n    box-shadow: none;\n    cursor: default;\n    display: inline-block;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    outline: none;\n    line-height: 14px;\n    /* For IE 8 compatibility */\n    padding: 8px 0 12px;\n    /* For IE 8 compatibility */\n    -webkit-appearance: none;\n  }\n  .is-focused .Select-input > input {\n    cursor: text;\n  }\n  .has-value.is-pseudo-focused .Select-input {\n    opacity: 0;\n  }\n  .Select-control:not(.is-searchable) > .Select-input {\n    outline: none;\n  }\n  .Select-loading-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 16px;\n  }\n  .Select-loading {\n    -webkit-animation: Select-animation-spin 400ms infinite linear;\n    -o-animation: Select-animation-spin 400ms infinite linear;\n    animation: Select-animation-spin 400ms infinite linear;\n    width: 16px;\n    height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    border: 2px solid #ccc;\n    border-right-color: #333;\n    display: inline-block;\n    position: relative;\n    vertical-align: middle;\n  }\n  .Select-clear-zone {\n    -webkit-animation: Select-animation-fadeIn 200ms;\n    -o-animation: Select-animation-fadeIn 200ms;\n    animation: Select-animation-fadeIn 200ms;\n    color: #999;\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 17px;\n  }\n  .Select-clear-zone:hover {\n    color: #D0021B;\n  }\n  .Select-clear {\n    display: inline-block;\n    font-size: 18px;\n    line-height: 1;\n  }\n  .Select--multi .Select-clear-zone {\n    width: 17px;\n  }\n  .Select-arrow-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 25px;\n    padding-right: 5px;\n  }\n  .Select-arrow {\n    border-color: #999 transparent transparent;\n    border-style: solid;\n    border-width: 5px 5px 2.5px;\n    display: inline-block;\n    height: 0;\n    width: 0;\n  }\n  .is-open .Select-arrow,\n  .Select-arrow-zone:hover > .Select-arrow {\n    border-top-color: #666;\n  }\n  .Select--multi .Select-multi-value-wrapper {\n    display: inline-block;\n  }\n  .Select .Select-aria-only {\n    display: inline-block;\n    height: 1px;\n    width: 1px;\n    margin: -1px;\n    clip: rect(0, 0, 0, 0);\n    overflow: hidden;\n  }\n  @-webkit-keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  @keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  .Select-menu-outer {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n    background-color: #fff;\n    border: 1px solid #ccc;\n    border-top-color: #e6e6e6;\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n    box-sizing: border-box;\n    margin-top: -1px;\n    max-height: 200px;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 1;\n    -webkit-overflow-scrolling: touch;\n  }\n  .Select-menu {\n    max-height: 198px;\n    overflow-y: auto;\n  }\n  .Select-option {\n    box-sizing: border-box;\n    background-color: #fff;\n    color: #666666;\n    cursor: pointer;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select-option:last-child {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n  .Select-option.is-selected {\n    background-color: #f5faff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.04);\n    color: #333;\n  }\n  .Select-option.is-focused {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    color: #333;\n  }\n  .Select-option.is-disabled {\n    color: #cccccc;\n    cursor: default;\n  }\n  .Select-noresults {\n    box-sizing: border-box;\n    color: #999999;\n    cursor: default;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select--multi .Select-input {\n    vertical-align: middle;\n    margin-left: 10px;\n    padding: 0;\n  }\n  .Select--multi.has-value .Select-input {\n    margin-left: 5px;\n  }\n  .Select--multi .Select-value {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    border-radius: 2px;\n    border: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border: 1px solid rgba(0, 126, 255, 0.24);\n    color: #007eff;\n    display: inline-block;\n    font-size: 0.9em;\n    line-height: 1.4;\n    margin-left: 5px;\n    margin-top: 5px;\n    vertical-align: top;\n  }\n  .Select--multi .Select-value-icon,\n  .Select--multi .Select-value-label {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  .Select--multi .Select-value-label {\n    border-bottom-right-radius: 2px;\n    border-top-right-radius: 2px;\n    cursor: default;\n    padding: 2px 5px;\n  }\n  .Select--multi a.Select-value-label {\n    color: #007eff;\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .Select--multi a.Select-value-label:hover {\n    text-decoration: underline;\n  }\n  .Select--multi .Select-value-icon {\n    cursor: pointer;\n    border-bottom-left-radius: 2px;\n    border-top-left-radius: 2px;\n    border-right: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border-right: 1px solid rgba(0, 126, 255, 0.24);\n    padding: 1px 5px 3px;\n  }\n  .Select--multi .Select-value-icon:hover,\n  .Select--multi .Select-value-icon:focus {\n    background-color: #d8eafd;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 113, 230, 0.08);\n    color: #0071e6;\n  }\n  .Select--multi .Select-value-icon:active {\n    background-color: #c2e0ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.24);\n  }\n  .Select--multi.is-disabled .Select-value {\n    background-color: #fcfcfc;\n    border: 1px solid #e3e3e3;\n    color: #333;\n  }\n  .Select--multi.is-disabled .Select-value-icon {\n    cursor: not-allowed;\n    border-right: 1px solid #e3e3e3;\n  }\n  .Select--multi.is-disabled .Select-value-icon:hover,\n  .Select--multi.is-disabled .Select-value-icon:focus,\n  .Select--multi.is-disabled .Select-value-icon:active {\n    background-color: #fcfcfc;\n  }\n  @keyframes Select-animation-spin {\n    to {\n      transform: rotate(1turn);\n    }\n  }\n  @-webkit-keyframes Select-animation-spin {\n    to {\n      -webkit-transform: rotate(1turn);\n    }\n  }\n\n  .VirtualSelectGrid {\n    z-index: 1;\n  }\n\n  .VirtualizedSelectOption {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    padding: 0 .5rem;\n  }\n  .VirtualizedSelectFocusedOption {\n    background-color: rgba(0, 126, 255, 0.1);\n  }\n  .VirtualizedSelectDisabledOption {\n    opacity: 0.5;\n  }\n" ]), _styledComponents = __webpack_require__(132);
        exports.default = (0, _styledComponents.createGlobalStyle)(_templateObject);
    }, /* 208 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _keys = __webpack_require__(209), _keys2 = _interopRequireDefault(_keys), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _reactRouter = __webpack_require__(212), _reactRouterDom = __webpack_require__(239), _DefaultTheme = __webpack_require__(254), _DefaultTheme2 = _interopRequireDefault(_DefaultTheme), _PropTypes = __webpack_require__(206), _TouchNav = __webpack_require__(255), _TouchNav2 = _interopRequireDefault(_TouchNav), Presentation = function(_Component) {
            function Presentation() {
                return (0, _classCallCheck3.default)(this, Presentation), (0, _possibleConstructorReturn3.default)(this, (Presentation.__proto__ || (0, 
                _getPrototypeOf2.default)(Presentation)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Presentation, _Component), (0, _createClass3.default)(Presentation, [ {
                key: "render",
                value: function() {
                    var Router = this.props.router;
                    return _react2.default.createElement(Router, null, _react2.default.createElement(PresentationInner, this.props));
                }
            } ]), Presentation;
        }(_react.Component);
        Presentation.defaultProps = {
            disableTheme: !1,
            router: _reactRouterDom.HashRouter,
            disableTouch: !1
        }, exports.default = Presentation;
        var PresentationInner = function(_Component2) {
            function PresentationInner(props, context) {
                (0, _classCallCheck3.default)(this, PresentationInner);
                var _this2 = (0, _possibleConstructorReturn3.default)(this, (PresentationInner.__proto__ || (0, 
                _getPrototypeOf2.default)(PresentationInner)).call(this, props, context));
                return _this2.state = {
                    pluginProps: {}
                }, _this2._index = 0, _this2._slideIndex = 0, _this2._slideIndexMap = {}, _this2._stepIndex = 0, 
                _this2.getSlideIndex = _this2.getSlideIndex.bind(_this2), _this2.getSlideMetadata = _this2.getSlideMetadata.bind(_this2), 
                _this2.getStepIndex = _this2.getStepIndex.bind(_this2), _this2.goBack = _this2.goBack.bind(_this2), 
                _this2.goForward = _this2.goForward.bind(_this2), _this2.goToSlide = _this2.goToSlide.bind(_this2), 
                _this2.setPluginProps = _this2.setPluginProps.bind(_this2), _this2._onKeyDown = _this2._onKeyDown.bind(_this2), 
                _this2;
            }
            return (0, _inherits3.default)(PresentationInner, _Component2), (0, _createClass3.default)(PresentationInner, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillMount",
                value: function() {
                    this._parseLocation(window.location);
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    this._parseLocation(window.location);
                }
            }, {
                key: "getChildContext",
                value: function() {
                    var pluginProps = this.state.pluginProps;
                    return {
                        pluginProps: pluginProps,
                        presentation: this
                    };
                }
            }, {
                key: "getSlideIndex",
                value: function() {
                    return this._slideIndex;
                }
            }, {
                key: "getSlideMetadata",
                value: function(slide) {
                    var slideIndex = this._index;
                    this._slideIndexMap[slideIndex] = slide, this._index++;
                    var path = this._createPath({
                        slideIndex: slideIndex
                    });
                    return {
                        path: path,
                        slideIndex: slideIndex
                    };
                }
            }, {
                key: "getStepIndex",
                value: function() {
                    return this._stepIndex;
                }
            }, {
                key: "goBack",
                value: function() {
                    var slideIndex = this._slideIndex, stepIndex = this._stepIndex;
                    stepIndex > 0 ? this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex - 1
                    }) : slideIndex > 0 && (slideIndex--, this.goToSlide({
                        slideIndex: slideIndex
                    }), stepIndex = this._getNumStepsForSlide(slideIndex) - 1, this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }));
                }
            }, {
                key: "goForward",
                value: function() {
                    var slideIndex = this._slideIndex, stepIndex = this._stepIndex, numCurrentSlideSteps = this._getNumStepsForSlide(slideIndex), numSlides = (0, 
                    _keys2.default)(this._slideIndexMap).length;
                    stepIndex + 1 < numCurrentSlideSteps ? stepIndex++ : slideIndex + 1 < numSlides && (slideIndex++, 
                    stepIndex = 0), this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    });
                }
            }, {
                key: "goToSlide",
                value: function(_ref) {
                    var slideIndex = _ref.slideIndex, _ref$stepIndex = _ref.stepIndex, stepIndex = void 0 === _ref$stepIndex ? 0 : _ref$stepIndex;
                    if (slideIndex !== this._slideIndex || stepIndex !== this._stepIndex) {
                        var router = this.context.router, path = this._createPath({
                            slideIndex: slideIndex,
                            stepIndex: stepIndex
                        });
                        "function" == typeof router.replace ? router.replace(path) : router.history.replace(path), 
                        this.forceUpdate();
                    }
                }
            }, {
                key: "isAtBeginning",
                value: function() {
                    return 0 === this._slideIndex && 0 === this._stepIndex;
                }
            }, {
                key: "isAtEnd",
                value: function() {
                    var numSlides = (0, _keys2.default)(this._slideIndexMap).length, numLastSlideSteps = this._getNumStepsForSlide(numSlides - 1);
                    return this._slideIndex === numSlides - 1 && this._stepIndex === numLastSlideSteps - 1;
                }
            }, {
                key: "setPluginProps",
                value: function(props) {
                    var pluginProps = this.state.pluginProps;
                    this.setState({
                        pluginProps: (0, _extends3.default)({}, pluginProps, props)
                    });
                }
            }, {
                key: "render",
                value: function() {
                    var _props = this.props, children = _props.children, disableTheme = _props.disableTheme, disableTouch = _props.disableTouch;
                    return _react2.default.createElement("div", {
                        style: {
                            height: "100%",
                            width: "100%"
                        }
                    }, !disableTheme && _react2.default.createElement(_DefaultTheme2.default, null), _react2.default.createElement(_reactRouterDom.Route, {
                        exact: !0,
                        path: "/",
                        render: function() {
                            return _react2.default.createElement(_reactRouter.Redirect, {
                                to: "/0/0"
                            });
                        }
                    }), "function" == typeof children ? children({
                        presentation: this
                    }) : children, !disableTouch && _react2.default.createElement(_TouchNav2.default, null));
                }
            }, {
                key: "_createPath",
                value: function(_ref2) {
                    var slideIndex = _ref2.slideIndex, _ref2$stepIndex = _ref2.stepIndex, stepIndex = void 0 === _ref2$stepIndex ? ":step" : _ref2$stepIndex;
                    return "/" + slideIndex + "/" + stepIndex;
                }
            }, {
                key: "_getNumStepsForSlide",
                value: function(slideIndex) {
                    return this._slideIndexMap[slideIndex].getNumSteps() || 1;
                }
            }, {
                key: "_parseLocation",
                value: function(location) {
                    var parsed = (location.pathname + location.hash).match(/(\d+)\/(\d+)/);
                    parsed ? (this._slideIndex = parseInt(parsed[1], 10), this._stepIndex = parseInt(parsed[2], 10)) : (this._slideIndex = 0, 
                    this._stepIndex = 0);
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {}
            } ]), PresentationInner;
        }(_react.Component);
        PresentationInner.childContextTypes = {
            pluginProps: _propTypes2.default.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired
        }, PresentationInner.contextTypes = {
            router: _propTypes2.default.object.isRequired
        };
    }, /* 209 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(210),
            __esModule: !0
        };
    }, /* 210 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(211), module.exports = __webpack_require__(8).Object.keys;
    }, /* 211 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 Object.keys(O)
        var toObject = __webpack_require__(59), $keys = __webpack_require__(23);
        __webpack_require__(42)("keys", function() {
            return function(it) {
                return $keys(toObject(it));
            };
        });
    }, /* 212 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.withRouter = exports.matchPath = exports.generatePath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.MemoryRouter = void 0;
        var _MemoryRouter2 = __webpack_require__(213), _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2), _Prompt2 = __webpack_require__(228), _Prompt3 = _interopRequireDefault(_Prompt2), _Redirect2 = __webpack_require__(229), _Redirect3 = _interopRequireDefault(_Redirect2), _Route2 = __webpack_require__(233), _Route3 = _interopRequireDefault(_Route2), _Router2 = __webpack_require__(226), _Router3 = _interopRequireDefault(_Router2), _StaticRouter2 = __webpack_require__(235), _StaticRouter3 = _interopRequireDefault(_StaticRouter2), _Switch2 = __webpack_require__(236), _Switch3 = _interopRequireDefault(_Switch2), _generatePath2 = __webpack_require__(230), _generatePath3 = _interopRequireDefault(_generatePath2), _matchPath2 = __webpack_require__(234), _matchPath3 = _interopRequireDefault(_matchPath2), _withRouter2 = __webpack_require__(237), _withRouter3 = _interopRequireDefault(_withRouter2);
        exports.MemoryRouter = _MemoryRouter3.default, exports.Prompt = _Prompt3.default, 
        exports.Redirect = _Redirect3.default, exports.Route = _Route3.default, exports.Router = _Router3.default, 
        exports.StaticRouter = _StaticRouter3.default, exports.Switch = _Switch3.default, 
        exports.generatePath = _generatePath3.default, exports.matchPath = _matchPath3.default, 
        exports.withRouter = _withRouter3.default;
    }, /* 213 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _history = __webpack_require__(215), _Router = __webpack_require__(226), _Router2 = _interopRequireDefault(_Router), MemoryRouter = function(_React$Component) {
            function MemoryRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, MemoryRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _history.createMemoryHistory)(_this.props), _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(MemoryRouter, _React$Component), MemoryRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.");
            }, MemoryRouter.prototype.render = function() {
                return _react2.default.createElement(_Router2.default, {
                    history: this.history,
                    children: this.props.children
                });
            }, MemoryRouter;
        }(_react2.default.Component);
        MemoryRouter.propTypes = {
            initialEntries: _propTypes2.default.array,
            initialIndex: _propTypes2.default.number,
            getUserConfirmation: _propTypes2.default.func,
            keyLength: _propTypes2.default.number,
            children: _propTypes2.default.node
        }, exports.default = MemoryRouter;
    }, /* 214 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            /**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
            var __DEV__ = "production" !== process.env.NODE_ENV, warning = function() {};
            if (__DEV__) {
                var printWarning = function(format, args) {
                    var len = arguments.length;
                    args = new Array(len > 1 ? len - 1 : 0);
                    for (var key = 1; key < len; key++) args[key - 1] = arguments[key];
                    var argIndex = 0, message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    "undefined" != typeof console && console.error(message);
                    try {
                        // --- Welcome to debugging React ---
                        // This error was thrown as a convenience so that you can use this stack
                        // to find the callsite that caused this warning to fire.
                        throw new Error(message);
                    } catch (x) {}
                };
                warning = function(condition, format, args) {
                    var len = arguments.length;
                    args = new Array(len > 2 ? len - 2 : 0);
                    for (var key = 2; key < len; key++) args[key - 2] = arguments[key];
                    if (void 0 === format) throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
                    condition || printWarning.apply(null, [ format ].concat(args));
                };
            }
            module.exports = warning;
        }).call(exports, __webpack_require__(110));
    }, /* 215 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            "production" === process.env.NODE_ENV ? module.exports = __webpack_require__(216) : module.exports = __webpack_require__(225);
        }).call(exports, __webpack_require__(110));
    }, /* 216 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopDefault(t) {
            return t && "object" == typeof t && "default" in t ? t.default : t;
        }
        function _extends() {
            return (_extends = Object.assign || function(t) {
                for (var n = 1; n < arguments.length; n++) {
                    var e = arguments[n];
                    for (var a in e) Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
                }
                return t;
            }).apply(this, arguments);
        }
        function addLeadingSlash(t) {
            return "/" === t.charAt(0) ? t : "/" + t;
        }
        function stripLeadingSlash(t) {
            return "/" === t.charAt(0) ? t.substr(1) : t;
        }
        function hasBasename(t, n) {
            return 0 === t.toLowerCase().indexOf(n.toLowerCase()) && -1 !== "/?#".indexOf(t.charAt(n.length));
        }
        function stripBasename(t, n) {
            return hasBasename(t, n) ? t.substr(n.length) : t;
        }
        function stripTrailingSlash(t) {
            return "/" === t.charAt(t.length - 1) ? t.slice(0, -1) : t;
        }
        function parsePath(t) {
            var n = t || "/", e = "", a = "", r = n.indexOf("#");
            -1 !== r && (a = n.substr(r), n = n.substr(0, r));
            var o = n.indexOf("?");
            return -1 !== o && (e = n.substr(o), n = n.substr(0, o)), {
                pathname: n,
                search: "?" === e ? "" : e,
                hash: "#" === a ? "" : a
            };
        }
        function createPath(t) {
            var n = t.pathname, e = t.search, a = t.hash, r = n || "/";
            return e && "?" !== e && (r += "?" === e.charAt(0) ? e : "?" + e), a && "#" !== a && (r += "#" === a.charAt(0) ? a : "#" + a), 
            r;
        }
        function createLocation(t, n, e, a) {
            var r;
            "string" == typeof t ? (r = parsePath(t)).state = n : (void 0 === (r = _extends({}, t)).pathname && (r.pathname = ""), 
            r.search ? "?" !== r.search.charAt(0) && (r.search = "?" + r.search) : r.search = "", 
            r.hash ? "#" !== r.hash.charAt(0) && (r.hash = "#" + r.hash) : r.hash = "", void 0 !== n && void 0 === r.state && (r.state = n));
            try {
                r.pathname = decodeURI(r.pathname);
            } catch (t) {
                throw t instanceof URIError ? new URIError('Pathname "' + r.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.') : t;
            }
            return e && (r.key = e), a ? r.pathname ? "/" !== r.pathname.charAt(0) && (r.pathname = resolvePathname(r.pathname, a.pathname)) : r.pathname = a.pathname : r.pathname || (r.pathname = "/"), 
            r;
        }
        function locationsAreEqual(t, n) {
            return t.pathname === n.pathname && t.search === n.search && t.hash === n.hash && t.key === n.key && valueEqual(t.state, n.state);
        }
        function createTransitionManager() {
            var o = null, a = [];
            return {
                setPrompt: function(t) {
                    return o = t, function() {
                        o === t && (o = null);
                    };
                },
                confirmTransitionTo: function(t, n, e, a) {
                    if (null != o) {
                        var r = "function" == typeof o ? o(t, n) : o;
                        "string" == typeof r ? "function" == typeof e ? e(r, a) : a(!0) : a(!1 !== r);
                    } else a(!0);
                },
                appendListener: function(t) {
                    function e() {
                        n && t.apply(void 0, arguments);
                    }
                    var n = !0;
                    return a.push(e), function() {
                        n = !1, a = a.filter(function(t) {
                            return t !== e;
                        });
                    };
                },
                notifyListeners: function() {
                    for (var t = arguments.length, n = new Array(t), e = 0; e < t; e++) n[e] = arguments[e];
                    a.forEach(function(t) {
                        return t.apply(void 0, n);
                    });
                }
            };
        }
        function getConfirmation(t, n) {
            n(window.confirm(t));
        }
        function supportsHistory() {
            var t = window.navigator.userAgent;
            return (-1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone")) && window.history && "pushState" in window.history;
        }
        function supportsPopStateOnHashChange() {
            return -1 === window.navigator.userAgent.indexOf("Trident");
        }
        function supportsGoWithoutReloadUsingHash() {
            return -1 === window.navigator.userAgent.indexOf("Firefox");
        }
        function isExtraneousPopstateEvent(t) {
            return void 0 === t.state && -1 === navigator.userAgent.indexOf("CriOS");
        }
        function getHistoryState() {
            try {
                return window.history.state || {};
            } catch (t) {
                return {};
            }
        }
        function createBrowserHistory(t) {
            function l(t) {
                var n = t || {}, e = n.key, a = n.state, r = window.location, o = r.pathname + r.search + r.hash;
                return f && (o = stripBasename(o, f)), createLocation(o, a, e);
            }
            function d() {
                return Math.random().toString(36).substr(2, i);
            }
            function p(t) {
                _extends(T, t), T.length = s.length, v.notifyListeners(T.location, T.action);
            }
            function g(t) {
                isExtraneousPopstateEvent(t) || w(l(t.state));
            }
            function P() {
                w(l(getHistoryState()));
            }
            function w(n) {
                m ? (m = !1, p()) : v.confirmTransitionTo(n, "POP", u, function(t) {
                    t ? p({
                        action: "POP",
                        location: n
                    }) : function(t) {
                        var n = T.location, e = H.indexOf(n.key);
                        -1 === e && (e = 0);
                        var a = H.indexOf(t.key);
                        -1 === a && (a = 0);
                        var r = e - a;
                        r && (m = !0, L(r));
                    }(n);
                });
            }
            function x(t) {
                return f + createPath(t);
            }
            function L(t) {
                s.go(t);
            }
            function E(t) {
                1 === (O += t) && 1 === t ? (window.addEventListener(PopStateEvent, g), n && window.addEventListener(HashChangeEvent, P)) : 0 === O && (window.removeEventListener(PopStateEvent, g), 
                n && window.removeEventListener(HashChangeEvent, P));
            }
            void 0 === t && (t = {}), canUseDOM || invariant(!1);
            var s = window.history, c = supportsHistory(), n = !supportsPopStateOnHashChange(), e = t, a = e.forceRefresh, h = void 0 !== a && a, r = e.getUserConfirmation, u = void 0 === r ? getConfirmation : r, o = e.keyLength, i = void 0 === o ? 6 : o, f = t.basename ? stripTrailingSlash(addLeadingSlash(t.basename)) : "", v = createTransitionManager(), m = !1, y = l(getHistoryState()), H = [ y.key ], O = 0, S = !1, T = {
                length: s.length,
                action: "POP",
                location: y,
                createHref: x,
                push: function(t, n) {
                    var i = createLocation(t, n, d(), T.location);
                    v.confirmTransitionTo(i, "PUSH", u, function(t) {
                        if (t) {
                            var n = x(i), e = i.key, a = i.state;
                            if (c) if (s.pushState({
                                key: e,
                                state: a
                            }, null, n), h) window.location.href = n; else {
                                var r = H.indexOf(T.location.key), o = H.slice(0, r + 1);
                                o.push(i.key), H = o, p({
                                    action: "PUSH",
                                    location: i
                                });
                            } else window.location.href = n;
                        }
                    });
                },
                replace: function(t, n) {
                    var o = "REPLACE", i = createLocation(t, n, d(), T.location);
                    v.confirmTransitionTo(i, o, u, function(t) {
                        if (t) {
                            var n = x(i), e = i.key, a = i.state;
                            if (c) if (s.replaceState({
                                key: e,
                                state: a
                            }, null, n), h) window.location.replace(n); else {
                                var r = H.indexOf(T.location.key);
                                -1 !== r && (H[r] = i.key), p({
                                    action: o,
                                    location: i
                                });
                            } else window.location.replace(n);
                        }
                    });
                },
                go: L,
                goBack: function() {
                    L(-1);
                },
                goForward: function() {
                    L(1);
                },
                block: function(t) {
                    void 0 === t && (t = !1);
                    var n = v.setPrompt(t);
                    return S || (E(1), S = !0), function() {
                        return S && (S = !1, E(-1)), n();
                    };
                },
                listen: function(t) {
                    var n = v.appendListener(t);
                    return E(1), function() {
                        E(-1), n();
                    };
                }
            };
            return T;
        }
        function stripHash(t) {
            var n = t.indexOf("#");
            return -1 === n ? t : t.slice(0, n);
        }
        function getHashPath() {
            var t = window.location.href, n = t.indexOf("#");
            return -1 === n ? "" : t.substring(n + 1);
        }
        function pushHashPath(t) {
            window.location.hash = t;
        }
        function replaceHashPath(t) {
            window.location.replace(stripHash(window.location.href) + "#" + t);
        }
        function createHashHistory(t) {
            function f() {
                var t = u(getHashPath());
                return s && (t = stripBasename(t, s)), createLocation(t);
            }
            function d(t) {
                _extends(E, t), E.length = n.length, l.notifyListeners(E.location, E.action);
            }
            function g() {
                var t = getHashPath(), n = h(t);
                if (t !== n) replaceHashPath(n); else {
                    var e = f(), a = E.location;
                    if (!v && function(t, n) {
                        return t.pathname === n.pathname && t.search === n.search && t.hash === n.hash;
                    }(a, e)) return;
                    if (p === createPath(e)) return;
                    p = null, function(n) {
                        v ? (v = !1, d()) : l.confirmTransitionTo(n, "POP", i, function(t) {
                            t ? d({
                                action: "POP",
                                location: n
                            }) : function(t) {
                                var n = E.location, e = y.lastIndexOf(createPath(n));
                                -1 === e && (e = 0);
                                var a = y.lastIndexOf(createPath(t));
                                -1 === a && (a = 0);
                                var r = e - a;
                                r && (v = !0, H(r));
                            }(n);
                        });
                    }(e);
                }
            }
            function H(t) {
                n.go(t);
            }
            function L(t) {
                1 === (x += t) && 1 === t ? window.addEventListener(HashChangeEvent$1, g) : 0 === x && window.removeEventListener(HashChangeEvent$1, g);
            }
            void 0 === t && (t = {}), canUseDOM || invariant(!1);
            var n = window.history, e = (supportsGoWithoutReloadUsingHash(), t), a = e.getUserConfirmation, i = void 0 === a ? getConfirmation : a, r = e.hashType, o = void 0 === r ? "slash" : r, s = t.basename ? stripTrailingSlash(addLeadingSlash(t.basename)) : "", c = HashPathCoders[o], h = c.encodePath, u = c.decodePath, l = createTransitionManager(), v = !1, p = null, P = getHashPath(), m = h(P);
            P !== m && replaceHashPath(m);
            var w = f(), y = [ createPath(w) ], x = 0, O = !1, E = {
                length: n.length,
                action: "POP",
                location: w,
                createHref: function(t) {
                    var n = document.querySelector("base"), e = "";
                    return n && n.getAttribute("href") && (e = stripHash(window.location.href)), e + "#" + h(s + createPath(t));
                },
                push: function(t, n) {
                    var o = createLocation(t, void 0, void 0, E.location);
                    l.confirmTransitionTo(o, "PUSH", i, function(t) {
                        if (t) {
                            var n = createPath(o), e = h(s + n);
                            if (getHashPath() !== e) {
                                p = n, pushHashPath(e);
                                var a = y.lastIndexOf(createPath(E.location)), r = y.slice(0, a + 1);
                                r.push(n), y = r, d({
                                    action: "PUSH",
                                    location: o
                                });
                            } else d();
                        }
                    });
                },
                replace: function(t, n) {
                    var r = "REPLACE", o = createLocation(t, void 0, void 0, E.location);
                    l.confirmTransitionTo(o, r, i, function(t) {
                        if (t) {
                            var n = createPath(o), e = h(s + n);
                            getHashPath() !== e && (p = n, replaceHashPath(e));
                            var a = y.indexOf(createPath(E.location));
                            -1 !== a && (y[a] = n), d({
                                action: r,
                                location: o
                            });
                        }
                    });
                },
                go: H,
                goBack: function() {
                    H(-1);
                },
                goForward: function() {
                    H(1);
                },
                block: function(t) {
                    void 0 === t && (t = !1);
                    var n = l.setPrompt(t);
                    return O || (L(1), O = !0), function() {
                        return O && (O = !1, L(-1)), n();
                    };
                },
                listen: function(t) {
                    var n = l.appendListener(t);
                    return L(1), function() {
                        L(-1), n();
                    };
                }
            };
            return E;
        }
        function clamp(t, n, e) {
            return Math.min(Math.max(t, n), e);
        }
        function createMemoryHistory(t) {
            function u(t) {
                _extends(g, t), g.length = g.entries.length, h.notifyListeners(g.location, g.action);
            }
            function f() {
                return Math.random().toString(36).substr(2, c);
            }
            function p(t) {
                var n = clamp(g.index + t, 0, g.entries.length - 1), e = g.entries[n];
                h.confirmTransitionTo(e, "POP", r, function(t) {
                    t ? u({
                        action: "POP",
                        location: e,
                        index: n
                    }) : u();
                });
            }
            void 0 === t && (t = {});
            var n = t, r = n.getUserConfirmation, e = n.initialEntries, a = void 0 === e ? [ "/" ] : e, o = n.initialIndex, i = void 0 === o ? 0 : o, s = n.keyLength, c = void 0 === s ? 6 : s, h = createTransitionManager(), l = clamp(i, 0, a.length - 1), d = a.map(function(t) {
                return createLocation(t, void 0, "string" == typeof t ? f() : t.key || f());
            }), v = createPath, g = {
                length: d.length,
                action: "POP",
                location: d[l],
                index: l,
                entries: d,
                createHref: v,
                push: function(t, n) {
                    var a = createLocation(t, n, f(), g.location);
                    h.confirmTransitionTo(a, "PUSH", r, function(t) {
                        if (t) {
                            var n = g.index + 1, e = g.entries.slice(0);
                            e.length > n ? e.splice(n, e.length - n, a) : e.push(a), u({
                                action: "PUSH",
                                location: a,
                                index: n,
                                entries: e
                            });
                        }
                    });
                },
                replace: function(t, n) {
                    var e = "REPLACE", a = createLocation(t, n, f(), g.location);
                    h.confirmTransitionTo(a, e, r, function(t) {
                        t && (g.entries[g.index] = a, u({
                            action: e,
                            location: a
                        }));
                    });
                },
                go: p,
                goBack: function() {
                    p(-1);
                },
                goForward: function() {
                    p(1);
                },
                canGo: function(t) {
                    var n = g.index + t;
                    return 0 <= n && n < g.entries.length;
                },
                block: function(t) {
                    return void 0 === t && (t = !1), h.setPrompt(t);
                },
                listen: function(t) {
                    return h.appendListener(t);
                }
            };
            return g;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var resolvePathname = _interopDefault(__webpack_require__(217)), valueEqual = _interopDefault(__webpack_require__(220));
        __webpack_require__(223);
        var invariant = _interopDefault(__webpack_require__(224)), canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement), PopStateEvent = "popstate", HashChangeEvent = "hashchange", HashChangeEvent$1 = "hashchange", HashPathCoders = {
            hashbang: {
                encodePath: function(t) {
                    return "!" === t.charAt(0) ? t : "!/" + stripLeadingSlash(t);
                },
                decodePath: function(t) {
                    return "!" === t.charAt(0) ? t.substr(1) : t;
                }
            },
            noslash: {
                encodePath: stripLeadingSlash,
                decodePath: addLeadingSlash
            },
            slash: {
                encodePath: addLeadingSlash,
                decodePath: addLeadingSlash
            }
        };
        exports.createBrowserHistory = createBrowserHistory, exports.createHashHistory = createHashHistory, 
        exports.createMemoryHistory = createMemoryHistory, exports.createLocation = createLocation, 
        exports.locationsAreEqual = locationsAreEqual, exports.parsePath = parsePath, exports.createPath = createPath;
    }, /* 217 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            "production" === process.env.NODE_ENV ? module.exports = __webpack_require__(218) : module.exports = __webpack_require__(219);
        }).call(exports, __webpack_require__(110));
    }, /* 218 */
    /***/
    function(module, exports) {
        "use strict";
        function isAbsolute(e) {
            return "/" === e.charAt(0);
        }
        function spliceOne(e, t) {
            for (var s = t, n = s + 1, i = e.length; n < i; s += 1, n += 1) e[s] = e[n];
            e.pop();
        }
        function resolvePathname(e, t) {
            void 0 === t && (t = "");
            var s, n = e && e.split("/") || [], i = t && t.split("/") || [], l = e && isAbsolute(e), r = t && isAbsolute(t), o = l || r;
            if (e && isAbsolute(e) ? i = n : n.length && (i.pop(), i = i.concat(n)), !i.length) return "/";
            if (i.length) {
                var u = i[i.length - 1];
                s = "." === u || ".." === u || "" === u;
            } else s = !1;
            for (var a = 0, c = i.length; 0 <= c; c--) {
                var f = i[c];
                "." === f ? spliceOne(i, c) : ".." === f ? (spliceOne(i, c), a++) : a && (spliceOne(i, c), 
                a--);
            }
            if (!o) for (;a--; a) i.unshift("..");
            !o || "" === i[0] || i[0] && isAbsolute(i[0]) || i.unshift("");
            var h = i.join("/");
            return s && "/" !== h.substr(-1) && (h += "/"), h;
        }
        module.exports = resolvePathname;
    }, /* 219 */
    /***/
    function(module, exports) {
        "use strict";
        function isAbsolute(pathname) {
            return "/" === pathname.charAt(0);
        }
        // About 1.5x faster than the two-arg version of Array#splice()
        function spliceOne(list, index) {
            for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
            list.pop();
        }
        // This implementation is based heavily on node's url.parse
        function resolvePathname(to, from) {
            void 0 === from && (from = "");
            var toParts = to && to.split("/") || [], fromParts = from && from.split("/") || [], isToAbs = to && isAbsolute(to), isFromAbs = from && isAbsolute(from), mustEndAbs = isToAbs || isFromAbs;
            if (to && isAbsolute(to) ? // to is absolute
            fromParts = toParts : toParts.length && (// to is relative, drop the filename
            fromParts.pop(), fromParts = fromParts.concat(toParts)), !fromParts.length) return "/";
            var hasTrailingSlash;
            if (fromParts.length) {
                var last = fromParts[fromParts.length - 1];
                hasTrailingSlash = "." === last || ".." === last || "" === last;
            } else hasTrailingSlash = !1;
            for (var up = 0, i = fromParts.length; i >= 0; i--) {
                var part = fromParts[i];
                "." === part ? spliceOne(fromParts, i) : ".." === part ? (spliceOne(fromParts, i), 
                up++) : up && (spliceOne(fromParts, i), up--);
            }
            if (!mustEndAbs) for (;up--; up) fromParts.unshift("..");
            !mustEndAbs || "" === fromParts[0] || fromParts[0] && isAbsolute(fromParts[0]) || fromParts.unshift("");
            var result = fromParts.join("/");
            return hasTrailingSlash && "/" !== result.substr(-1) && (result += "/"), result;
        }
        module.exports = resolvePathname;
    }, /* 220 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            "production" === process.env.NODE_ENV ? module.exports = __webpack_require__(221) : module.exports = __webpack_require__(222);
        }).call(exports, __webpack_require__(110));
    }, /* 221 */
    /***/
    function(module, exports) {
        "use strict";
        function valueOf(e) {
            return e.valueOf ? e.valueOf() : Object.prototype.valueOf.call(e);
        }
        function valueEqual(u, r) {
            if (u === r) return !0;
            if (null == u || null == r) return !1;
            if (Array.isArray(u)) return Array.isArray(r) && u.length === r.length && u.every(function(e, u) {
                return valueEqual(e, r[u]);
            });
            if ("object" != typeof u && "object" != typeof r) return !1;
            var e = valueOf(u), t = valueOf(r);
            return e !== u || t !== r ? valueEqual(e, t) : Object.keys(Object.assign({}, u, r)).every(function(e) {
                return valueEqual(u[e], r[e]);
            });
        }
        module.exports = valueEqual;
    }, /* 222 */
    /***/
    function(module, exports) {
        "use strict";
        function valueOf(obj) {
            return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
        }
        function valueEqual(a, b) {
            // Test for strict equality first.
            if (a === b) return !0;
            // Otherwise, if either of them == null they are not equal.
            if (null == a || null == b) return !1;
            if (Array.isArray(a)) return Array.isArray(b) && a.length === b.length && a.every(function(item, index) {
                return valueEqual(item, b[index]);
            });
            if ("object" == typeof a || "object" == typeof b) {
                var aValue = valueOf(a), bValue = valueOf(b);
                return aValue !== a || bValue !== b ? valueEqual(aValue, bValue) : Object.keys(Object.assign({}, a, b)).every(function(key) {
                    return valueEqual(a[key], b[key]);
                });
            }
            return !1;
        }
        module.exports = valueEqual;
    }, /* 223 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function warning(condition, message) {
                if (!isProduction) {
                    if (condition) return;
                    var text = "Warning: " + message;
                    "undefined" != typeof console && console.warn(text);
                    try {
                        throw Error(text);
                    } catch (x) {}
                }
            }
            var isProduction = "production" === process.env.NODE_ENV;
            module.exports = warning;
        }).call(exports, __webpack_require__(110));
    }, /* 224 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function invariant(condition, message) {
                if (!condition) {
                    if (isProduction) throw new Error(prefix);
                    throw new Error(prefix + ": " + (message || ""));
                }
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var isProduction = "production" === process.env.NODE_ENV, prefix = "Invariant failed";
            exports.default = invariant;
        }).call(exports, __webpack_require__(110));
    }, /* 225 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopDefault(ex) {
            return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
        }
        function _extends() {
            return _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _extends.apply(this, arguments);
        }
        function addLeadingSlash(path) {
            return "/" === path.charAt(0) ? path : "/" + path;
        }
        function stripLeadingSlash(path) {
            return "/" === path.charAt(0) ? path.substr(1) : path;
        }
        function hasBasename(path, prefix) {
            return 0 === path.toLowerCase().indexOf(prefix.toLowerCase()) && "/?#".indexOf(path.charAt(prefix.length)) !== -1;
        }
        function stripBasename(path, prefix) {
            return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
        }
        function stripTrailingSlash(path) {
            return "/" === path.charAt(path.length - 1) ? path.slice(0, -1) : path;
        }
        function parsePath(path) {
            var pathname = path || "/", search = "", hash = "", hashIndex = pathname.indexOf("#");
            hashIndex !== -1 && (hash = pathname.substr(hashIndex), pathname = pathname.substr(0, hashIndex));
            var searchIndex = pathname.indexOf("?");
            return searchIndex !== -1 && (search = pathname.substr(searchIndex), pathname = pathname.substr(0, searchIndex)), 
            {
                pathname: pathname,
                search: "?" === search ? "" : search,
                hash: "#" === hash ? "" : hash
            };
        }
        function createPath(location) {
            var pathname = location.pathname, search = location.search, hash = location.hash, path = pathname || "/";
            return search && "?" !== search && (path += "?" === search.charAt(0) ? search : "?" + search), 
            hash && "#" !== hash && (path += "#" === hash.charAt(0) ? hash : "#" + hash), path;
        }
        function createLocation(path, state, key, currentLocation) {
            var location;
            "string" == typeof path ? (// Two-arg form: push(path, state)
            location = parsePath(path), location.state = state) : (// One-arg form: push(location)
            location = _extends({}, path), void 0 === location.pathname && (location.pathname = ""), 
            location.search ? "?" !== location.search.charAt(0) && (location.search = "?" + location.search) : location.search = "", 
            location.hash ? "#" !== location.hash.charAt(0) && (location.hash = "#" + location.hash) : location.hash = "", 
            void 0 !== state && void 0 === location.state && (location.state = state));
            try {
                location.pathname = decodeURI(location.pathname);
            } catch (e) {
                throw e instanceof URIError ? new URIError('Pathname "' + location.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.') : e;
            }
            // Resolve incomplete/relative pathname relative to current location.
            // When there is no prior location and pathname is empty, set it to /
            return key && (location.key = key), currentLocation ? location.pathname ? "/" !== location.pathname.charAt(0) && (location.pathname = resolvePathname(location.pathname, currentLocation.pathname)) : location.pathname = currentLocation.pathname : location.pathname || (location.pathname = "/"), 
            location;
        }
        function locationsAreEqual(a, b) {
            return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
        }
        function createTransitionManager() {
            function setPrompt(nextPrompt) {
                return warning(null == prompt, "A history supports only one prompt at a time"), 
                prompt = nextPrompt, function() {
                    prompt === nextPrompt && (prompt = null);
                };
            }
            function confirmTransitionTo(location, action, getUserConfirmation, callback) {
                // TODO: If another transition starts while we're still confirming
                // the previous one, we may end up in a weird state. Figure out the
                // best way to handle this.
                if (null != prompt) {
                    var result = "function" == typeof prompt ? prompt(location, action) : prompt;
                    "string" == typeof result ? "function" == typeof getUserConfirmation ? getUserConfirmation(result, callback) : (warning(!1, "A history needs a getUserConfirmation function in order to use a prompt message"), 
                    callback(!0)) : // Return false from a transition hook to cancel the transition.
                    callback(result !== !1);
                } else callback(!0);
            }
            function appendListener(fn) {
                function listener() {
                    isActive && fn.apply(void 0, arguments);
                }
                var isActive = !0;
                return listeners.push(listener), function() {
                    isActive = !1, listeners = listeners.filter(function(item) {
                        return item !== listener;
                    });
                };
            }
            function notifyListeners() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                listeners.forEach(function(listener) {
                    return listener.apply(void 0, args);
                });
            }
            var prompt = null, listeners = [];
            return {
                setPrompt: setPrompt,
                confirmTransitionTo: confirmTransitionTo,
                appendListener: appendListener,
                notifyListeners: notifyListeners
            };
        }
        function getConfirmation(message, callback) {
            callback(window.confirm(message));
        }
        /**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
	 */
        function supportsHistory() {
            var ua = window.navigator.userAgent;
            return (ua.indexOf("Android 2.") === -1 && ua.indexOf("Android 4.0") === -1 || ua.indexOf("Mobile Safari") === -1 || ua.indexOf("Chrome") !== -1 || ua.indexOf("Windows Phone") !== -1) && (window.history && "pushState" in window.history);
        }
        /**
	 * Returns true if browser fires popstate on hash change.
	 * IE10 and IE11 do not.
	 */
        function supportsPopStateOnHashChange() {
            return window.navigator.userAgent.indexOf("Trident") === -1;
        }
        /**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
        function supportsGoWithoutReloadUsingHash() {
            return window.navigator.userAgent.indexOf("Firefox") === -1;
        }
        /**
	 * Returns true if a given popstate event is an extraneous WebKit event.
	 * Accounts for the fact that Chrome on iOS fires real popstate events
	 * containing undefined state when pressing the back button.
	 */
        function isExtraneousPopstateEvent(event) {
            return void 0 === event.state && navigator.userAgent.indexOf("CriOS") === -1;
        }
        function getHistoryState() {
            try {
                return window.history.state || {};
            } catch (e) {
                // IE 11 sometimes throws when accessing window.history.state
                // See https://github.com/ReactTraining/history/pull/289
                return {};
            }
        }
        /**
	 * Creates a history object that uses the HTML5 history API including
	 * pushState, replaceState, and the popstate event.
	 */
        function createBrowserHistory(props) {
            function getDOMLocation(historyState) {
                var _ref = historyState || {}, key = _ref.key, state = _ref.state, _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash, path = pathname + search + hash;
                return warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path + '" to begin with "' + basename + '".'), 
                basename && (path = stripBasename(path, basename)), createLocation(path, state, key);
            }
            function createKey() {
                return Math.random().toString(36).substr(2, keyLength);
            }
            function setState(nextState) {
                _extends(history, nextState), history.length = globalHistory.length, transitionManager.notifyListeners(history.location, history.action);
            }
            function handlePopState(event) {
                // Ignore extraneous popstate events in WebKit.
                isExtraneousPopstateEvent(event) || handlePop(getDOMLocation(event.state));
            }
            function handleHashChange() {
                handlePop(getDOMLocation(getHistoryState()));
            }
            function handlePop(location) {
                if (forceNextPop) forceNextPop = !1, setState(); else {
                    var action = "POP";
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        ok ? setState({
                            action: action,
                            location: location
                        }) : revertPop(location);
                    });
                }
            }
            function revertPop(fromLocation) {
                var toLocation = history.location, toIndex = allKeys.indexOf(toLocation.key);
                toIndex === -1 && (toIndex = 0);
                var fromIndex = allKeys.indexOf(fromLocation.key);
                fromIndex === -1 && (fromIndex = 0);
                var delta = toIndex - fromIndex;
                delta && (forceNextPop = !0, go(delta));
            }
            // Public interface
            function createHref(location) {
                return basename + createPath(location);
            }
            function push(path, state) {
                warning(!("object" == typeof path && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "PUSH", location = createLocation(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var href = createHref(location), key = location.key, state = location.state;
                        if (canUseHistory) if (globalHistory.pushState({
                            key: key,
                            state: state
                        }, null, href), forceRefresh) window.location.href = href; else {
                            var prevIndex = allKeys.indexOf(history.location.key), nextKeys = allKeys.slice(0, prevIndex + 1);
                            nextKeys.push(location.key), allKeys = nextKeys, setState({
                                action: action,
                                location: location
                            });
                        } else warning(void 0 === state, "Browser history cannot push state in browsers that do not support HTML5 history"), 
                        window.location.href = href;
                    }
                });
            }
            function replace(path, state) {
                warning(!("object" == typeof path && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "REPLACE", location = createLocation(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var href = createHref(location), key = location.key, state = location.state;
                        if (canUseHistory) if (globalHistory.replaceState({
                            key: key,
                            state: state
                        }, null, href), forceRefresh) window.location.replace(href); else {
                            var prevIndex = allKeys.indexOf(history.location.key);
                            prevIndex !== -1 && (allKeys[prevIndex] = location.key), setState({
                                action: action,
                                location: location
                            });
                        } else warning(void 0 === state, "Browser history cannot replace state in browsers that do not support HTML5 history"), 
                        window.location.replace(href);
                    }
                });
            }
            function go(n) {
                globalHistory.go(n);
            }
            function goBack() {
                go(-1);
            }
            function goForward() {
                go(1);
            }
            function checkDOMListeners(delta) {
                listenerCount += delta, 1 === listenerCount && 1 === delta ? (window.addEventListener(PopStateEvent, handlePopState), 
                needsHashChangeListener && window.addEventListener(HashChangeEvent, handleHashChange)) : 0 === listenerCount && (window.removeEventListener(PopStateEvent, handlePopState), 
                needsHashChangeListener && window.removeEventListener(HashChangeEvent, handleHashChange));
            }
            function block(prompt) {
                void 0 === prompt && (prompt = !1);
                var unblock = transitionManager.setPrompt(prompt);
                return isBlocked || (checkDOMListeners(1), isBlocked = !0), function() {
                    return isBlocked && (isBlocked = !1, checkDOMListeners(-1)), unblock();
                };
            }
            function listen(listener) {
                var unlisten = transitionManager.appendListener(listener);
                return checkDOMListeners(1), function() {
                    checkDOMListeners(-1), unlisten();
                };
            }
            void 0 === props && (props = {}), canUseDOM ? void 0 : invariant(!1, "Browser history needs a DOM");
            var globalHistory = window.history, canUseHistory = supportsHistory(), needsHashChangeListener = !supportsPopStateOnHashChange(), _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = void 0 !== _props$forceRefresh && _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = void 0 === _props$getUserConfirm ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength, basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "", transitionManager = createTransitionManager(), forceNextPop = !1, initialLocation = getDOMLocation(getHistoryState()), allKeys = [ initialLocation.key ], listenerCount = 0, isBlocked = !1, history = {
                length: globalHistory.length,
                action: "POP",
                location: initialLocation,
                createHref: createHref,
                push: push,
                replace: replace,
                go: go,
                goBack: goBack,
                goForward: goForward,
                block: block,
                listen: listen
            };
            return history;
        }
        function stripHash(url) {
            var hashIndex = url.indexOf("#");
            return hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        function getHashPath() {
            // We can't use window.location.hash here because it's not
            // consistent across browsers - Firefox will pre-decode it!
            var href = window.location.href, hashIndex = href.indexOf("#");
            return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
        }
        function pushHashPath(path) {
            window.location.hash = path;
        }
        function replaceHashPath(path) {
            window.location.replace(stripHash(window.location.href) + "#" + path);
        }
        function createHashHistory(props) {
            function getDOMLocation() {
                var path = decodePath(getHashPath());
                return warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + path + '" to begin with "' + basename + '".'), 
                basename && (path = stripBasename(path, basename)), createLocation(path);
            }
            function setState(nextState) {
                _extends(history, nextState), history.length = globalHistory.length, transitionManager.notifyListeners(history.location, history.action);
            }
            function locationsAreEqual$$1(a, b) {
                return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
            }
            function handleHashChange() {
                var path = getHashPath(), encodedPath = encodePath(path);
                if (path !== encodedPath) // Ensure we always have a properly-encoded hash.
                replaceHashPath(encodedPath); else {
                    var location = getDOMLocation(), prevLocation = history.location;
                    if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return;
                    // A hashchange doesn't always == location change.
                    if (ignorePath === createPath(location)) return;
                    // Ignore this change; we already setState in push/replace.
                    ignorePath = null, handlePop(location);
                }
            }
            function handlePop(location) {
                if (forceNextPop) forceNextPop = !1, setState(); else {
                    var action = "POP";
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        ok ? setState({
                            action: action,
                            location: location
                        }) : revertPop(location);
                    });
                }
            }
            function revertPop(fromLocation) {
                var toLocation = history.location, toIndex = allPaths.lastIndexOf(createPath(toLocation));
                toIndex === -1 && (toIndex = 0);
                var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
                fromIndex === -1 && (fromIndex = 0);
                var delta = toIndex - fromIndex;
                delta && (forceNextPop = !0, go(delta));
            }
            // Public interface
            function createHref(location) {
                var baseTag = document.querySelector("base"), href = "";
                return baseTag && baseTag.getAttribute("href") && (href = stripHash(window.location.href)), 
                href + "#" + encodePath(basename + createPath(location));
            }
            function push(path, state) {
                warning(void 0 === state, "Hash history cannot push state; it is ignored");
                var action = "PUSH", location = createLocation(path, void 0, void 0, history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var path = createPath(location), encodedPath = encodePath(basename + path), hashChanged = getHashPath() !== encodedPath;
                        if (hashChanged) {
                            // We cannot tell if a hashchange was caused by a PUSH, so we'd
                            // rather setState here and ignore the hashchange. The caveat here
                            // is that other hash histories in the page will consider it a POP.
                            ignorePath = path, pushHashPath(encodedPath);
                            var prevIndex = allPaths.lastIndexOf(createPath(history.location)), nextPaths = allPaths.slice(0, prevIndex + 1);
                            nextPaths.push(path), allPaths = nextPaths, setState({
                                action: action,
                                location: location
                            });
                        } else warning(!1, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack"), 
                        setState();
                    }
                });
            }
            function replace(path, state) {
                warning(void 0 === state, "Hash history cannot replace state; it is ignored");
                var action = "REPLACE", location = createLocation(path, void 0, void 0, history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var path = createPath(location), encodedPath = encodePath(basename + path), hashChanged = getHashPath() !== encodedPath;
                        hashChanged && (// We cannot tell if a hashchange was caused by a REPLACE, so we'd
                        // rather setState here and ignore the hashchange. The caveat here
                        // is that other hash histories in the page will consider it a POP.
                        ignorePath = path, replaceHashPath(encodedPath));
                        var prevIndex = allPaths.indexOf(createPath(history.location));
                        prevIndex !== -1 && (allPaths[prevIndex] = path), setState({
                            action: action,
                            location: location
                        });
                    }
                });
            }
            function go(n) {
                warning(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser"), 
                globalHistory.go(n);
            }
            function goBack() {
                go(-1);
            }
            function goForward() {
                go(1);
            }
            function checkDOMListeners(delta) {
                listenerCount += delta, 1 === listenerCount && 1 === delta ? window.addEventListener(HashChangeEvent$1, handleHashChange) : 0 === listenerCount && window.removeEventListener(HashChangeEvent$1, handleHashChange);
            }
            function block(prompt) {
                void 0 === prompt && (prompt = !1);
                var unblock = transitionManager.setPrompt(prompt);
                return isBlocked || (checkDOMListeners(1), isBlocked = !0), function() {
                    return isBlocked && (isBlocked = !1, checkDOMListeners(-1)), unblock();
                };
            }
            function listen(listener) {
                var unlisten = transitionManager.appendListener(listener);
                return checkDOMListeners(1), function() {
                    checkDOMListeners(-1), unlisten();
                };
            }
            void 0 === props && (props = {}), canUseDOM ? void 0 : invariant(!1, "Hash history needs a DOM");
            var globalHistory = window.history, canGoWithoutReload = supportsGoWithoutReloadUsingHash(), _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = void 0 === _props$getUserConfirm ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = void 0 === _props$hashType ? "slash" : _props$hashType, basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : "", _HashPathCoders$hashT = HashPathCoders[hashType], encodePath = _HashPathCoders$hashT.encodePath, decodePath = _HashPathCoders$hashT.decodePath, transitionManager = createTransitionManager(), forceNextPop = !1, ignorePath = null, path = getHashPath(), encodedPath = encodePath(path);
            path !== encodedPath && replaceHashPath(encodedPath);
            var initialLocation = getDOMLocation(), allPaths = [ createPath(initialLocation) ], listenerCount = 0, isBlocked = !1, history = {
                length: globalHistory.length,
                action: "POP",
                location: initialLocation,
                createHref: createHref,
                push: push,
                replace: replace,
                go: go,
                goBack: goBack,
                goForward: goForward,
                block: block,
                listen: listen
            };
            return history;
        }
        function clamp(n, lowerBound, upperBound) {
            return Math.min(Math.max(n, lowerBound), upperBound);
        }
        /**
	 * Creates a history object that stores locations in memory.
	 */
        function createMemoryHistory(props) {
            function setState(nextState) {
                _extends(history, nextState), history.length = history.entries.length, transitionManager.notifyListeners(history.location, history.action);
            }
            function createKey() {
                return Math.random().toString(36).substr(2, keyLength);
            }
            function push(path, state) {
                warning(!("object" == typeof path && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "PUSH", location = createLocation(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    if (ok) {
                        var prevIndex = history.index, nextIndex = prevIndex + 1, nextEntries = history.entries.slice(0);
                        nextEntries.length > nextIndex ? nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location) : nextEntries.push(location), 
                        setState({
                            action: action,
                            location: location,
                            index: nextIndex,
                            entries: nextEntries
                        });
                    }
                });
            }
            function replace(path, state) {
                warning(!("object" == typeof path && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored");
                var action = "REPLACE", location = createLocation(path, state, createKey(), history.location);
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    ok && (history.entries[history.index] = location, setState({
                        action: action,
                        location: location
                    }));
                });
            }
            function go(n) {
                var nextIndex = clamp(history.index + n, 0, history.entries.length - 1), action = "POP", location = history.entries[nextIndex];
                transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                    ok ? setState({
                        action: action,
                        location: location,
                        index: nextIndex
                    }) : // Mimic the behavior of DOM histories by
                    // causing a render after a cancelled POP.
                    setState();
                });
            }
            function goBack() {
                go(-1);
            }
            function goForward() {
                go(1);
            }
            function canGo(n) {
                var nextIndex = history.index + n;
                return nextIndex >= 0 && nextIndex < history.entries.length;
            }
            function block(prompt) {
                return void 0 === prompt && (prompt = !1), transitionManager.setPrompt(prompt);
            }
            function listen(listener) {
                return transitionManager.appendListener(listener);
            }
            void 0 === props && (props = {});
            var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = void 0 === _props$initialEntries ? [ "/" ] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = void 0 === _props$initialIndex ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength, transitionManager = createTransitionManager(), index = clamp(initialIndex, 0, initialEntries.length - 1), entries = initialEntries.map(function(entry) {
                return "string" == typeof entry ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
            }), createHref = createPath, history = {
                length: entries.length,
                action: "POP",
                location: entries[index],
                index: index,
                entries: entries,
                createHref: createHref,
                push: push,
                replace: replace,
                go: go,
                goBack: goBack,
                goForward: goForward,
                canGo: canGo,
                block: block,
                listen: listen
            };
            return history;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var resolvePathname = _interopDefault(__webpack_require__(217)), valueEqual = _interopDefault(__webpack_require__(220)), warning = _interopDefault(__webpack_require__(223)), invariant = _interopDefault(__webpack_require__(224)), canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement), PopStateEvent = "popstate", HashChangeEvent = "hashchange", HashChangeEvent$1 = "hashchange", HashPathCoders = {
            hashbang: {
                encodePath: function(path) {
                    return "!" === path.charAt(0) ? path : "!/" + stripLeadingSlash(path);
                },
                decodePath: function(path) {
                    return "!" === path.charAt(0) ? path.substr(1) : path;
                }
            },
            noslash: {
                encodePath: stripLeadingSlash,
                decodePath: addLeadingSlash
            },
            slash: {
                encodePath: addLeadingSlash,
                decodePath: addLeadingSlash
            }
        };
        exports.createBrowserHistory = createBrowserHistory, exports.createHashHistory = createHashHistory, 
        exports.createMemoryHistory = createMemoryHistory, exports.createLocation = createLocation, 
        exports.locationsAreEqual = locationsAreEqual, exports.parsePath = parsePath, exports.createPath = createPath;
    }, /* 226 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(227), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), Router = function(_React$Component) {
            function Router() {
                var _temp, _this, _ret;
                _classCallCheck(this, Router);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.state = {
                    match: _this.computeMatch(_this.props.history.location.pathname)
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Router, _React$Component), Router.prototype.getChildContext = function() {
                return {
                    router: _extends({}, this.context.router, {
                        history: this.props.history,
                        route: {
                            location: this.props.history.location,
                            match: this.state.match
                        }
                    })
                };
            }, Router.prototype.computeMatch = function(pathname) {
                return {
                    path: "/",
                    url: "/",
                    params: {},
                    isExact: "/" === pathname
                };
            }, Router.prototype.componentWillMount = function() {
                var _this2 = this, _props = this.props, children = _props.children, history = _props.history;
                (0, _invariant2.default)(null == children || 1 === _react2.default.Children.count(children), "A <Router> may have only one child element"), 
                // Do this here so we can setState when a <Redirect> changes the
                // location in componentWillMount. This happens e.g. when doing
                // server rendering using a <StaticRouter>.
                this.unlisten = history.listen(function() {
                    _this2.setState({
                        match: _this2.computeMatch(history.location.pathname)
                    });
                });
            }, Router.prototype.componentWillReceiveProps = function(nextProps) {
                (0, _warning2.default)(this.props.history === nextProps.history, "You cannot change <Router history>");
            }, Router.prototype.componentWillUnmount = function() {
                this.unlisten();
            }, Router.prototype.render = function() {
                var children = this.props.children;
                return children ? _react2.default.Children.only(children) : null;
            }, Router;
        }(_react2.default.Component);
        Router.propTypes = {
            history: _propTypes2.default.object.isRequired,
            children: _propTypes2.default.node
        }, Router.contextTypes = {
            router: _propTypes2.default.object
        }, Router.childContextTypes = {
            router: _propTypes2.default.object.isRequired
        }, exports.default = Router;
    }, /* 227 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
            "use strict";
            /**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
            var invariant = function(condition, format, a, b, c, d, e, f) {
                if ("production" !== process.env.NODE_ENV && void 0 === format) throw new Error("invariant requires an error message argument");
                if (!condition) {
                    var error;
                    if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
                        var args = [ a, b, c, d, e, f ], argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        })), error.name = "Invariant Violation";
                    }
                    // we don't care about invariant's own frame
                    throw error.framesToPop = 1, error;
                }
            };
            module.exports = invariant;
        }).call(exports, __webpack_require__(110));
    }, /* 228 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _invariant = __webpack_require__(227), _invariant2 = _interopRequireDefault(_invariant), Prompt = function(_React$Component) {
            function Prompt() {
                return _classCallCheck(this, Prompt), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Prompt, _React$Component), Prompt.prototype.enable = function(message) {
                this.unblock && this.unblock(), this.unblock = this.context.router.history.block(message);
            }, Prompt.prototype.disable = function() {
                this.unblock && (this.unblock(), this.unblock = null);
            }, Prompt.prototype.componentWillMount = function() {
                (0, _invariant2.default)(this.context.router, "You should not use <Prompt> outside a <Router>"), 
                this.props.when && this.enable(this.props.message);
            }, Prompt.prototype.componentWillReceiveProps = function(nextProps) {
                nextProps.when ? this.props.when && this.props.message === nextProps.message || this.enable(nextProps.message) : this.disable();
            }, Prompt.prototype.componentWillUnmount = function() {
                this.disable();
            }, Prompt.prototype.render = function() {
                return null;
            }, Prompt;
        }(_react2.default.Component);
        Prompt.propTypes = {
            when: _propTypes2.default.bool,
            message: _propTypes2.default.oneOfType([ _propTypes2.default.func, _propTypes2.default.string ]).isRequired
        }, Prompt.defaultProps = {
            when: !0
        }, Prompt.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.shape({
                    block: _propTypes2.default.func.isRequired
                }).isRequired
            }).isRequired
        }, exports.default = Prompt;
    }, /* 229 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(227), _invariant2 = _interopRequireDefault(_invariant), _history = __webpack_require__(215), _generatePath = __webpack_require__(230), _generatePath2 = _interopRequireDefault(_generatePath), Redirect = function(_React$Component) {
            function Redirect() {
                return _classCallCheck(this, Redirect), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Redirect, _React$Component), Redirect.prototype.isStatic = function() {
                return this.context.router && this.context.router.staticContext;
            }, Redirect.prototype.componentWillMount = function() {
                (0, _invariant2.default)(this.context.router, "You should not use <Redirect> outside a <Router>"), 
                this.isStatic() && this.perform();
            }, Redirect.prototype.componentDidMount = function() {
                this.isStatic() || this.perform();
            }, Redirect.prototype.componentDidUpdate = function(prevProps) {
                var prevTo = (0, _history.createLocation)(prevProps.to), nextTo = (0, _history.createLocation)(this.props.to);
                return (0, _history.locationsAreEqual)(prevTo, nextTo) ? void (0, _warning2.default)(!1, "You tried to redirect to the same route you're currently on: " + ('"' + nextTo.pathname + nextTo.search + '"')) : void this.perform();
            }, Redirect.prototype.computeTo = function(_ref) {
                var computedMatch = _ref.computedMatch, to = _ref.to;
                return computedMatch ? "string" == typeof to ? (0, _generatePath2.default)(to, computedMatch.params) : _extends({}, to, {
                    pathname: (0, _generatePath2.default)(to.pathname, computedMatch.params)
                }) : to;
            }, Redirect.prototype.perform = function() {
                var history = this.context.router.history, push = this.props.push, to = this.computeTo(this.props);
                push ? history.push(to) : history.replace(to);
            }, Redirect.prototype.render = function() {
                return null;
            }, Redirect;
        }(_react2.default.Component);
        Redirect.propTypes = {
            computedMatch: _propTypes2.default.object,
            // private, from <Switch>
            push: _propTypes2.default.bool,
            from: _propTypes2.default.string,
            to: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.object ]).isRequired
        }, Redirect.defaultProps = {
            push: !1
        }, Redirect.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.shape({
                    push: _propTypes2.default.func.isRequired,
                    replace: _propTypes2.default.func.isRequired
                }).isRequired,
                staticContext: _propTypes2.default.object
            }).isRequired
        }, exports.default = Redirect;
    }, /* 230 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _pathToRegexp = __webpack_require__(231), _pathToRegexp2 = _interopRequireDefault(_pathToRegexp), patternCache = {}, cacheLimit = 1e4, cacheCount = 0, compileGenerator = function(pattern) {
            var cacheKey = pattern, cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});
            if (cache[pattern]) return cache[pattern];
            var compiledGenerator = _pathToRegexp2.default.compile(pattern);
            return cacheCount < cacheLimit && (cache[pattern] = compiledGenerator, cacheCount++), 
            compiledGenerator;
        }, generatePath = function() {
            var pattern = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "/", params = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if ("/" === pattern) return pattern;
            var generator = compileGenerator(pattern);
            return generator(params, {
                pretty: !0
            });
        };
        exports.default = generatePath;
    }, /* 231 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
        function parse(str, options) {
            for (var res, tokens = [], key = 0, index = 0, path = "", defaultDelimiter = options && options.delimiter || "/"; null != (res = PATH_REGEXP.exec(str)); ) {
                var m = res[0], escaped = res[1], offset = res.index;
                // Ignore already escaped sequences.
                if (path += str.slice(index, offset), index = offset + m.length, escaped) path += escaped[1]; else {
                    var next = str[index], prefix = res[2], name = res[3], capture = res[4], group = res[5], modifier = res[6], asterisk = res[7];
                    // Push the current path onto the tokens.
                    path && (tokens.push(path), path = "");
                    var partial = null != prefix && null != next && next !== prefix, repeat = "+" === modifier || "*" === modifier, optional = "?" === modifier || "*" === modifier, delimiter = res[2] || defaultDelimiter, pattern = capture || group;
                    tokens.push({
                        name: name || key++,
                        prefix: prefix || "",
                        delimiter: delimiter,
                        optional: optional,
                        repeat: repeat,
                        partial: partial,
                        asterisk: !!asterisk,
                        pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
                    });
                }
            }
            // Match any characters still remaining.
            // If the path exists, push it onto the end.
            return index < str.length && (path += str.substr(index)), path && tokens.push(path), 
            tokens;
        }
        /**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
        function compile(str, options) {
            return tokensToFunction(parse(str, options), options);
        }
        /**
	 * Prettier encoding of URI path segments.
	 *
	 * @param  {string}
	 * @return {string}
	 */
        function encodeURIComponentPretty(str) {
            return encodeURI(str).replace(/[\/?#]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        /**
	 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
	 *
	 * @param  {string}
	 * @return {string}
	 */
        function encodeAsterisk(str) {
            return encodeURI(str).replace(/[?#]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        /**
	 * Expose a method for transforming tokens into the path function.
	 */
        function tokensToFunction(tokens, options) {
            // Compile all the patterns before compilation.
            for (var matches = new Array(tokens.length), i = 0; i < tokens.length; i++) "object" == typeof tokens[i] && (matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$", flags(options)));
            return function(obj, opts) {
                for (var path = "", data = obj || {}, options = opts || {}, encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent, i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if ("string" != typeof token) {
                        var segment, value = data[token.name];
                        if (null == value) {
                            if (token.optional) {
                                // Prepend partial segment prefixes.
                                token.partial && (path += token.prefix);
                                continue;
                            }
                            throw new TypeError('Expected "' + token.name + '" to be defined');
                        }
                        if (isarray(value)) {
                            if (!token.repeat) throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
                            if (0 === value.length) {
                                if (token.optional) continue;
                                throw new TypeError('Expected "' + token.name + '" to not be empty');
                            }
                            for (var j = 0; j < value.length; j++) {
                                if (segment = encode(value[j]), !matches[i].test(segment)) throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
                                path += (0 === j ? token.prefix : token.delimiter) + segment;
                            }
                        } else {
                            if (segment = token.asterisk ? encodeAsterisk(value) : encode(value), !matches[i].test(segment)) throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
                            path += token.prefix + segment;
                        }
                    } else path += token;
                }
                return path;
            };
        }
        /**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
        function escapeString(str) {
            return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
        }
        /**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
        function escapeGroup(group) {
            return group.replace(/([=!:$\/()])/g, "\\$1");
        }
        /**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {!RegExp} re
	 * @param  {Array}   keys
	 * @return {!RegExp}
	 */
        function attachKeys(re, keys) {
            return re.keys = keys, re;
        }
        /**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
        function flags(options) {
            return options && options.sensitive ? "" : "i";
        }
        /**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {!Array}  keys
	 * @return {!RegExp}
	 */
        function regexpToRegexp(path, keys) {
            // Use a negative lookahead to match only capturing groups.
            var groups = path.source.match(/\((?!\?)/g);
            if (groups) for (var i = 0; i < groups.length; i++) keys.push({
                name: i,
                prefix: null,
                delimiter: null,
                optional: !1,
                repeat: !1,
                partial: !1,
                asterisk: !1,
                pattern: null
            });
            return attachKeys(path, keys);
        }
        /**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array}   keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
        function arrayToRegexp(path, keys, options) {
            for (var parts = [], i = 0; i < path.length; i++) parts.push(pathToRegexp(path[i], keys, options).source);
            var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
            return attachKeys(regexp, keys);
        }
        /**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {!Array}  keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
        function stringToRegexp(path, keys, options) {
            return tokensToRegExp(parse(path, options), keys, options);
        }
        /**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}          tokens
	 * @param  {(Array|Object)=} keys
	 * @param  {Object=}         options
	 * @return {!RegExp}
	 */
        function tokensToRegExp(tokens, keys, options) {
            isarray(keys) || (options = /** @type {!Object} */ keys || options, keys = []), 
            options = options || {};
            // Iterate over the tokens and create our regexp string.
            for (var strict = options.strict, end = options.end !== !1, route = "", i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if ("string" == typeof token) route += escapeString(token); else {
                    var prefix = escapeString(token.prefix), capture = "(?:" + token.pattern + ")";
                    keys.push(token), token.repeat && (capture += "(?:" + prefix + capture + ")*"), 
                    capture = token.optional ? token.partial ? prefix + "(" + capture + ")?" : "(?:" + prefix + "(" + capture + "))?" : prefix + "(" + capture + ")", 
                    route += capture;
                }
            }
            var delimiter = escapeString(options.delimiter || "/"), endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
            // In non-strict mode we allow a slash at the end of match. If the path to
            // match already ends with a slash, we remove it for consistency. The slash
            // is valid at the end of a path match, not in the middle. This is important
            // in non-ending mode, where "/test/" shouldn't match "/test//route".
            return strict || (route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?"), 
            route += end ? "$" : strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)", 
            attachKeys(new RegExp("^" + route, flags(options)), keys);
        }
        /**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {(Array|Object)=}       keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
        function pathToRegexp(path, keys, options) {
            /** @type {!Object} */
            /** @type {!Array} */
            /** @type {!Array} */
            /** @type {!Array} */
            /** @type {string} */
            /** @type {!Array} */
            return isarray(keys) || (options = keys || options, keys = []), options = options || {}, 
            path instanceof RegExp ? regexpToRegexp(path, keys) : isarray(path) ? arrayToRegexp(path, keys, options) : stringToRegexp(path, keys, options);
        }
        var isarray = __webpack_require__(232);
        /**
	 * Expose `pathToRegexp`.
	 */
        module.exports = pathToRegexp, module.exports.parse = parse, module.exports.compile = compile, 
        module.exports.tokensToFunction = tokensToFunction, module.exports.tokensToRegExp = tokensToRegExp;
        /**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
        var PATH_REGEXP = new RegExp([ // Match escaped characters that would otherwise appear in future matches.
        // This allows the user to escape special characters that won't transform.
        "(\\\\.)", // Match Express-style parameters and un-named parameters with a prefix
        // and optional suffixes. Matches appear as:
        //
        // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
        // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
        // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))" ].join("|"), "g");
    }, /* 232 */
    /***/
    function(module, exports) {
        module.exports = Array.isArray || function(arr) {
            return "[object Array]" == Object.prototype.toString.call(arr);
        };
    }, /* 233 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(227), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _matchPath = __webpack_require__(234), _matchPath2 = _interopRequireDefault(_matchPath), isEmptyChildren = function(children) {
            return 0 === _react2.default.Children.count(children);
        }, Route = function(_React$Component) {
            function Route() {
                var _temp, _this, _ret;
                _classCallCheck(this, Route);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.state = {
                    match: _this.computeMatch(_this.props, _this.context.router)
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Route, _React$Component), Route.prototype.getChildContext = function() {
                return {
                    router: _extends({}, this.context.router, {
                        route: {
                            location: this.props.location || this.context.router.route.location,
                            match: this.state.match
                        }
                    })
                };
            }, Route.prototype.computeMatch = function(_ref, router) {
                var computedMatch = _ref.computedMatch, location = _ref.location, path = _ref.path, strict = _ref.strict, exact = _ref.exact, sensitive = _ref.sensitive;
                if (computedMatch) return computedMatch;
                // <Switch> already computed the match for us
                (0, _invariant2.default)(router, "You should not use <Route> or withRouter() outside a <Router>");
                var route = router.route, pathname = (location || route.location).pathname;
                return (0, _matchPath2.default)(pathname, {
                    path: path,
                    strict: strict,
                    exact: exact,
                    sensitive: sensitive
                }, route.match);
            }, Route.prototype.componentWillMount = function() {
                (0, _warning2.default)(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored"), 
                (0, _warning2.default)(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored"), 
                (0, _warning2.default)(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), "You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored");
            }, Route.prototype.componentWillReceiveProps = function(nextProps, nextContext) {
                (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'), 
                (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'), 
                this.setState({
                    match: this.computeMatch(nextProps, nextContext.router)
                });
            }, Route.prototype.render = function render() {
                var match = this.state.match, _props = this.props, children = _props.children, component = _props.component, render = _props.render, _context$router = this.context.router, history = _context$router.history, route = _context$router.route, staticContext = _context$router.staticContext, location = this.props.location || route.location, props = {
                    match: match,
                    location: location,
                    history: history,
                    staticContext: staticContext
                };
                return component ? match ? _react2.default.createElement(component, props) : null : render ? match ? render(props) : null : "function" == typeof children ? children(props) : children && !isEmptyChildren(children) ? _react2.default.Children.only(children) : null;
            }, Route;
        }(_react2.default.Component);
        Route.propTypes = {
            computedMatch: _propTypes2.default.object,
            // private, from <Switch>
            path: _propTypes2.default.string,
            exact: _propTypes2.default.bool,
            strict: _propTypes2.default.bool,
            sensitive: _propTypes2.default.bool,
            component: _propTypes2.default.func,
            render: _propTypes2.default.func,
            children: _propTypes2.default.oneOfType([ _propTypes2.default.func, _propTypes2.default.node ]),
            location: _propTypes2.default.object
        }, Route.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.object.isRequired,
                route: _propTypes2.default.object.isRequired,
                staticContext: _propTypes2.default.object
            })
        }, Route.childContextTypes = {
            router: _propTypes2.default.object.isRequired
        }, exports.default = Route;
    }, /* 234 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _pathToRegexp = __webpack_require__(231), _pathToRegexp2 = _interopRequireDefault(_pathToRegexp), patternCache = {}, cacheLimit = 1e4, cacheCount = 0, compilePath = function(pattern, options) {
            var cacheKey = "" + options.end + options.strict + options.sensitive, cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});
            if (cache[pattern]) return cache[pattern];
            var keys = [], re = (0, _pathToRegexp2.default)(pattern, keys, options), compiledPattern = {
                re: re,
                keys: keys
            };
            return cacheCount < cacheLimit && (cache[pattern] = compiledPattern, cacheCount++), 
            compiledPattern;
        }, matchPath = function(pathname) {
            var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, parent = arguments[2];
            "string" == typeof options && (options = {
                path: options
            });
            var _options = options, path = _options.path, _options$exact = _options.exact, exact = void 0 !== _options$exact && _options$exact, _options$strict = _options.strict, strict = void 0 !== _options$strict && _options$strict, _options$sensitive = _options.sensitive, sensitive = void 0 !== _options$sensitive && _options$sensitive;
            if (null == path) return parent;
            var _compilePath = compilePath(path, {
                end: exact,
                strict: strict,
                sensitive: sensitive
            }), re = _compilePath.re, keys = _compilePath.keys, match = re.exec(pathname);
            if (!match) return null;
            var url = match[0], values = match.slice(1), isExact = pathname === url;
            return exact && !isExact ? null : {
                path: path,
                // the path pattern used to match
                url: "/" === path && "" === url ? "/" : url,
                // the matched portion of the URL
                isExact: isExact,
                // whether or not we matched exactly
                params: keys.reduce(function(memo, key, index) {
                    return memo[key.name] = values[index], memo;
                }, {})
            };
        };
        exports.default = matchPath;
    }, /* 235 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(227), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _history = __webpack_require__(215), _Router = __webpack_require__(226), _Router2 = _interopRequireDefault(_Router), addLeadingSlash = function(path) {
            return "/" === path.charAt(0) ? path : "/" + path;
        }, addBasename = function(basename, location) {
            return basename ? _extends({}, location, {
                pathname: addLeadingSlash(basename) + location.pathname
            }) : location;
        }, stripBasename = function(basename, location) {
            if (!basename) return location;
            var base = addLeadingSlash(basename);
            return 0 !== location.pathname.indexOf(base) ? location : _extends({}, location, {
                pathname: location.pathname.substr(base.length)
            });
        }, createURL = function(location) {
            return "string" == typeof location ? location : (0, _history.createPath)(location);
        }, staticHandler = function(methodName) {
            return function() {
                (0, _invariant2.default)(!1, "You cannot %s with <StaticRouter>", methodName);
            };
        }, noop = function() {}, StaticRouter = function(_React$Component) {
            function StaticRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, StaticRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.createHref = function(path) {
                    return addLeadingSlash(_this.props.basename + createURL(path));
                }, _this.handlePush = function(location) {
                    var _this$props = _this.props, basename = _this$props.basename, context = _this$props.context;
                    context.action = "PUSH", context.location = addBasename(basename, (0, _history.createLocation)(location)), 
                    context.url = createURL(context.location);
                }, _this.handleReplace = function(location) {
                    var _this$props2 = _this.props, basename = _this$props2.basename, context = _this$props2.context;
                    context.action = "REPLACE", context.location = addBasename(basename, (0, _history.createLocation)(location)), 
                    context.url = createURL(context.location);
                }, _this.handleListen = function() {
                    return noop;
                }, _this.handleBlock = function() {
                    return noop;
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(StaticRouter, _React$Component), StaticRouter.prototype.getChildContext = function() {
                return {
                    router: {
                        staticContext: this.props.context
                    }
                };
            }, StaticRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.");
            }, StaticRouter.prototype.render = function() {
                var _props = this.props, basename = _props.basename, location = (_props.context, 
                _props.location), props = _objectWithoutProperties(_props, [ "basename", "context", "location" ]), history = {
                    createHref: this.createHref,
                    action: "POP",
                    location: stripBasename(basename, (0, _history.createLocation)(location)),
                    push: this.handlePush,
                    replace: this.handleReplace,
                    go: staticHandler("go"),
                    goBack: staticHandler("goBack"),
                    goForward: staticHandler("goForward"),
                    listen: this.handleListen,
                    block: this.handleBlock
                };
                return _react2.default.createElement(_Router2.default, _extends({}, props, {
                    history: history
                }));
            }, StaticRouter;
        }(_react2.default.Component);
        StaticRouter.propTypes = {
            basename: _propTypes2.default.string,
            context: _propTypes2.default.object.isRequired,
            location: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.object ])
        }, StaticRouter.defaultProps = {
            basename: "",
            location: "/"
        }, StaticRouter.childContextTypes = {
            router: _propTypes2.default.object.isRequired
        }, exports.default = StaticRouter;
    }, /* 236 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(227), _invariant2 = _interopRequireDefault(_invariant), _matchPath = __webpack_require__(234), _matchPath2 = _interopRequireDefault(_matchPath), Switch = function(_React$Component) {
            function Switch() {
                return _classCallCheck(this, Switch), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Switch, _React$Component), Switch.prototype.componentWillMount = function() {
                (0, _invariant2.default)(this.context.router, "You should not use <Switch> outside a <Router>");
            }, Switch.prototype.componentWillReceiveProps = function(nextProps) {
                (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'), 
                (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
            }, Switch.prototype.render = function() {
                var route = this.context.router.route, children = this.props.children, location = this.props.location || route.location, match = void 0, child = void 0;
                return _react2.default.Children.forEach(children, function(element) {
                    if (null == match && _react2.default.isValidElement(element)) {
                        var _element$props = element.props, pathProp = _element$props.path, exact = _element$props.exact, strict = _element$props.strict, sensitive = _element$props.sensitive, from = _element$props.from, path = pathProp || from;
                        child = element, match = (0, _matchPath2.default)(location.pathname, {
                            path: path,
                            exact: exact,
                            strict: strict,
                            sensitive: sensitive
                        }, route.match);
                    }
                }), match ? _react2.default.cloneElement(child, {
                    location: location,
                    computedMatch: match
                }) : null;
            }, Switch;
        }(_react2.default.Component);
        Switch.contextTypes = {
            router: _propTypes2.default.shape({
                route: _propTypes2.default.object.isRequired
            }).isRequired
        }, Switch.propTypes = {
            children: _propTypes2.default.node,
            location: _propTypes2.default.object
        }, exports.default = Switch;
    }, /* 237 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _hoistNonReactStatics = __webpack_require__(238), _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics), _Route = __webpack_require__(233), _Route2 = _interopRequireDefault(_Route), withRouter = function(Component) {
            var C = function(props) {
                var wrappedComponentRef = props.wrappedComponentRef, remainingProps = _objectWithoutProperties(props, [ "wrappedComponentRef" ]);
                return _react2.default.createElement(_Route2.default, {
                    children: function(routeComponentProps) {
                        return _react2.default.createElement(Component, _extends({}, remainingProps, routeComponentProps, {
                            ref: wrappedComponentRef
                        }));
                    }
                });
            };
            return C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")", 
            C.WrappedComponent = Component, C.propTypes = {
                wrappedComponentRef: _propTypes2.default.func
            }, (0, _hoistNonReactStatics2.default)(C, Component);
        };
        exports.default = withRouter;
    }, /* 238 */
    /***/
    function(module, exports) {
        "use strict";
        function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
            if ("string" != typeof sourceComponent) {
                // don't hoist over string (html) components
                if (objectPrototype) {
                    var inheritedComponent = getPrototypeOf(sourceComponent);
                    inheritedComponent && inheritedComponent !== objectPrototype && hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                }
                var keys = getOwnPropertyNames(sourceComponent);
                getOwnPropertySymbols && (keys = keys.concat(getOwnPropertySymbols(sourceComponent)));
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (!(REACT_STATICS[key] || KNOWN_STATICS[key] || blacklist && blacklist[key])) {
                        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                        try {
                            // Avoid failures from read-only properties
                            defineProperty(targetComponent, key, descriptor);
                        } catch (e) {}
                    }
                }
                return targetComponent;
            }
            return targetComponent;
        }
        /**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
        var REACT_STATICS = {
            childContextTypes: !0,
            contextTypes: !0,
            defaultProps: !0,
            displayName: !0,
            getDefaultProps: !0,
            getDerivedStateFromProps: !0,
            mixins: !0,
            propTypes: !0,
            type: !0
        }, KNOWN_STATICS = {
            name: !0,
            length: !0,
            prototype: !0,
            caller: !0,
            callee: !0,
            arguments: !0,
            arity: !0
        }, defineProperty = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = getPrototypeOf && getPrototypeOf(Object);
        module.exports = hoistNonReactStatics;
    }, /* 239 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.withRouter = exports.matchPath = exports.generatePath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.NavLink = exports.MemoryRouter = exports.Link = exports.HashRouter = exports.BrowserRouter = void 0;
        var _BrowserRouter2 = __webpack_require__(240), _BrowserRouter3 = _interopRequireDefault(_BrowserRouter2), _HashRouter2 = __webpack_require__(242), _HashRouter3 = _interopRequireDefault(_HashRouter2), _Link2 = __webpack_require__(243), _Link3 = _interopRequireDefault(_Link2), _MemoryRouter2 = __webpack_require__(244), _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2), _NavLink2 = __webpack_require__(245), _NavLink3 = _interopRequireDefault(_NavLink2), _Prompt2 = __webpack_require__(247), _Prompt3 = _interopRequireDefault(_Prompt2), _Redirect2 = __webpack_require__(248), _Redirect3 = _interopRequireDefault(_Redirect2), _Route2 = __webpack_require__(246), _Route3 = _interopRequireDefault(_Route2), _Router2 = __webpack_require__(241), _Router3 = _interopRequireDefault(_Router2), _StaticRouter2 = __webpack_require__(249), _StaticRouter3 = _interopRequireDefault(_StaticRouter2), _Switch2 = __webpack_require__(250), _Switch3 = _interopRequireDefault(_Switch2), _generatePath2 = __webpack_require__(251), _generatePath3 = _interopRequireDefault(_generatePath2), _matchPath2 = __webpack_require__(252), _matchPath3 = _interopRequireDefault(_matchPath2), _withRouter2 = __webpack_require__(253), _withRouter3 = _interopRequireDefault(_withRouter2);
        exports.BrowserRouter = _BrowserRouter3.default, exports.HashRouter = _HashRouter3.default, 
        exports.Link = _Link3.default, exports.MemoryRouter = _MemoryRouter3.default, exports.NavLink = _NavLink3.default, 
        exports.Prompt = _Prompt3.default, exports.Redirect = _Redirect3.default, exports.Route = _Route3.default, 
        exports.Router = _Router3.default, exports.StaticRouter = _StaticRouter3.default, 
        exports.Switch = _Switch3.default, exports.generatePath = _generatePath3.default, 
        exports.matchPath = _matchPath3.default, exports.withRouter = _withRouter3.default;
    }, /* 240 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _history = __webpack_require__(215), _Router = __webpack_require__(241), _Router2 = _interopRequireDefault(_Router), BrowserRouter = function(_React$Component) {
            function BrowserRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, BrowserRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _history.createBrowserHistory)(_this.props), _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(BrowserRouter, _React$Component), BrowserRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.");
            }, BrowserRouter.prototype.render = function() {
                return _react2.default.createElement(_Router2.default, {
                    history: this.history,
                    children: this.props.children
                });
            }, BrowserRouter;
        }(_react2.default.Component);
        BrowserRouter.propTypes = {
            basename: _propTypes2.default.string,
            forceRefresh: _propTypes2.default.bool,
            getUserConfirmation: _propTypes2.default.func,
            keyLength: _propTypes2.default.number,
            children: _propTypes2.default.node
        }, exports.default = BrowserRouter;
    }, /* 241 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Router = __webpack_require__(226), _Router2 = _interopRequireDefault(_Router);
        exports.default = _Router2.default;
    }, /* 242 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _warning = __webpack_require__(214), _warning2 = _interopRequireDefault(_warning), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _history = __webpack_require__(215), _Router = __webpack_require__(241), _Router2 = _interopRequireDefault(_Router), HashRouter = function(_React$Component) {
            function HashRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, HashRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _history.createHashHistory)(_this.props), _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(HashRouter, _React$Component), HashRouter.prototype.componentWillMount = function() {
                (0, _warning2.default)(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.");
            }, HashRouter.prototype.render = function() {
                return _react2.default.createElement(_Router2.default, {
                    history: this.history,
                    children: this.props.children
                });
            }, HashRouter;
        }(_react2.default.Component);
        HashRouter.propTypes = {
            basename: _propTypes2.default.string,
            getUserConfirmation: _propTypes2.default.func,
            hashType: _propTypes2.default.oneOf([ "hashbang", "noslash", "slash" ]),
            children: _propTypes2.default.node
        }, exports.default = HashRouter;
    }, /* 243 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _invariant = __webpack_require__(227), _invariant2 = _interopRequireDefault(_invariant), _history = __webpack_require__(215), isModifiedEvent = function(event) {
            return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
        }, Link = function(_React$Component) {
            function Link() {
                var _temp, _this, _ret;
                _classCallCheck(this, Link);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.handleClick = function(event) {
                    if (_this.props.onClick && _this.props.onClick(event), !event.defaultPrevented && // onClick prevented default
                    0 === event.button && // ignore everything but left clicks
                    !_this.props.target && // let browser handle "target=_blank" etc.
                    !isModifiedEvent(event)) {
                        event.preventDefault();
                        var history = _this.context.router.history, _this$props = _this.props, replace = _this$props.replace, to = _this$props.to;
                        replace ? history.replace(to) : history.push(to);
                    }
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Link, _React$Component), Link.prototype.render = function() {
                var _props = this.props, to = (_props.replace, _props.to), innerRef = _props.innerRef, props = _objectWithoutProperties(_props, [ "replace", "to", "innerRef" ]);
                // eslint-disable-line no-unused-vars
                (0, _invariant2.default)(this.context.router, "You should not use <Link> outside a <Router>"), 
                (0, _invariant2.default)(void 0 !== to, 'You must specify the "to" property');
                var history = this.context.router.history, location = "string" == typeof to ? (0, 
                _history.createLocation)(to, null, null, history.location) : to, href = history.createHref(location);
                return _react2.default.createElement("a", _extends({}, props, {
                    onClick: this.handleClick,
                    href: href,
                    ref: innerRef
                }));
            }, Link;
        }(_react2.default.Component);
        Link.propTypes = {
            onClick: _propTypes2.default.func,
            target: _propTypes2.default.string,
            replace: _propTypes2.default.bool,
            to: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.object ]).isRequired,
            innerRef: _propTypes2.default.oneOfType([ _propTypes2.default.string, _propTypes2.default.func ])
        }, Link.defaultProps = {
            replace: !1
        }, Link.contextTypes = {
            router: _propTypes2.default.shape({
                history: _propTypes2.default.shape({
                    push: _propTypes2.default.func.isRequired,
                    replace: _propTypes2.default.func.isRequired,
                    createHref: _propTypes2.default.func.isRequired
                }).isRequired
            }).isRequired
        }, exports.default = Link;
    }, /* 244 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _MemoryRouter = __webpack_require__(213), _MemoryRouter2 = _interopRequireDefault(_MemoryRouter);
        exports.default = _MemoryRouter2.default;
    }, /* 245 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _Route = __webpack_require__(246), _Route2 = _interopRequireDefault(_Route), _Link = __webpack_require__(243), _Link2 = _interopRequireDefault(_Link), NavLink = function(_ref) {
            var to = _ref.to, exact = _ref.exact, strict = _ref.strict, location = _ref.location, activeClassName = _ref.activeClassName, className = _ref.className, activeStyle = _ref.activeStyle, style = _ref.style, getIsActive = _ref.isActive, ariaCurrent = _ref["aria-current"], rest = _objectWithoutProperties(_ref, [ "to", "exact", "strict", "location", "activeClassName", "className", "activeStyle", "style", "isActive", "aria-current" ]), path = "object" === ("undefined" == typeof to ? "undefined" : _typeof(to)) ? to.pathname : to, escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
            return _react2.default.createElement(_Route2.default, {
                path: escapedPath,
                exact: exact,
                strict: strict,
                location: location,
                children: function(_ref2) {
                    var location = _ref2.location, match = _ref2.match, isActive = !!(getIsActive ? getIsActive(match, location) : match);
                    return _react2.default.createElement(_Link2.default, _extends({
                        to: to,
                        className: isActive ? [ className, activeClassName ].filter(function(i) {
                            return i;
                        }).join(" ") : className,
                        style: isActive ? _extends({}, style, activeStyle) : style,
                        "aria-current": isActive && ariaCurrent || null
                    }, rest));
                }
            });
        };
        NavLink.propTypes = {
            to: _Link2.default.propTypes.to,
            exact: _propTypes2.default.bool,
            strict: _propTypes2.default.bool,
            location: _propTypes2.default.object,
            activeClassName: _propTypes2.default.string,
            className: _propTypes2.default.string,
            activeStyle: _propTypes2.default.object,
            style: _propTypes2.default.object,
            isActive: _propTypes2.default.func,
            "aria-current": _propTypes2.default.oneOf([ "page", "step", "location", "date", "time", "true" ])
        }, NavLink.defaultProps = {
            activeClassName: "active",
            "aria-current": "page"
        }, exports.default = NavLink;
    }, /* 246 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Route = __webpack_require__(233), _Route2 = _interopRequireDefault(_Route);
        exports.default = _Route2.default;
    }, /* 247 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Prompt = __webpack_require__(228), _Prompt2 = _interopRequireDefault(_Prompt);
        exports.default = _Prompt2.default;
    }, /* 248 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Redirect = __webpack_require__(229), _Redirect2 = _interopRequireDefault(_Redirect);
        exports.default = _Redirect2.default;
    }, /* 249 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _StaticRouter = __webpack_require__(235), _StaticRouter2 = _interopRequireDefault(_StaticRouter);
        exports.default = _StaticRouter2.default;
    }, /* 250 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _Switch = __webpack_require__(236), _Switch2 = _interopRequireDefault(_Switch);
        exports.default = _Switch2.default;
    }, /* 251 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _generatePath = __webpack_require__(230), _generatePath2 = _interopRequireDefault(_generatePath);
        exports.default = _generatePath2.default;
    }, /* 252 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _matchPath = __webpack_require__(234), _matchPath2 = _interopRequireDefault(_matchPath);
        exports.default = _matchPath2.default;
    }, /* 253 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _withRouter = __webpack_require__(237), _withRouter2 = _interopRequireDefault(_withRouter);
        exports.default = _withRouter2.default;
    }, /* 254 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function DefaultTheme() {
            return _react2.default.createElement(_react.Fragment, null, _react2.default.createElement(GlobalStyles, null), _react2.default.createElement("link", {
                href: "https://fonts.googleapis.com/css?family=Droid+Sans|Yanone+Kaffeesatz",
                rel: "stylesheet",
                type: "text/css"
            }));
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  html, body {\n    height: 100%;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }\n  * {\n    box-sizing: inherit;\n  }\n\n  body {\n    font-family: 'Droid Sans', sans-serif;\n    font-size: 20px;\n  }\n  h1, h2, h3, h4 {\n    font-family: 'Yanone Kaffeesatz', sans-serif;\n    font-weight: 400;\n    margin: 0 0 1rem;\n  }\n  h1 {\n    font-size: 2.5rem;\n  }\n  h2 {\n    font-size: 1.75rem;\n  }\n  h3 {\n    font-size: 1.5rem;\n  }\n  h4 {\n    font-size: 1rem;\n  }\n\n  li {\n    margin: 0 0 0.5rem;\n  }\n\n  html, body, #root {\n    height: 100%;\n  }\n\n  a {\n    color: #F92672;\n    text-decoration: none;\n  }\n\n  p {\n    margin: 0 0 1rem;\n  }\n\n  code {\n    background: #e7e8e2;\n    border-radius: 5px;\n    font-family: monospace;\n  }\n\n  button {\n    font-family: 'Yanone Kaffeesatz';\n    padding: 0.5rem 1rem;\n    border-radius: 0.5rem;\n    border: none;\n    background-color: #F92672;\n    color: #fff;\n    font-weight: 400;\n    font-size: 20px;\n    cursor: pointer;\n  }\n\n  button:disabled {\n    opacity: 0.5;\n    cursor: default;\n  }\n" ], [ "\n  html, body {\n    height: 100%;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }\n  * {\n    box-sizing: inherit;\n  }\n\n  body {\n    font-family: 'Droid Sans', sans-serif;\n    font-size: 20px;\n  }\n  h1, h2, h3, h4 {\n    font-family: 'Yanone Kaffeesatz', sans-serif;\n    font-weight: 400;\n    margin: 0 0 1rem;\n  }\n  h1 {\n    font-size: 2.5rem;\n  }\n  h2 {\n    font-size: 1.75rem;\n  }\n  h3 {\n    font-size: 1.5rem;\n  }\n  h4 {\n    font-size: 1rem;\n  }\n\n  li {\n    margin: 0 0 0.5rem;\n  }\n\n  html, body, #root {\n    height: 100%;\n  }\n\n  a {\n    color: #F92672;\n    text-decoration: none;\n  }\n\n  p {\n    margin: 0 0 1rem;\n  }\n\n  code {\n    background: #e7e8e2;\n    border-radius: 5px;\n    font-family: monospace;\n  }\n\n  button {\n    font-family: 'Yanone Kaffeesatz';\n    padding: 0.5rem 1rem;\n    border-radius: 0.5rem;\n    border: none;\n    background-color: #F92672;\n    color: #fff;\n    font-weight: 400;\n    font-size: 20px;\n    cursor: pointer;\n  }\n\n  button:disabled {\n    opacity: 0.5;\n    cursor: default;\n  }\n" ]);
        exports.default = DefaultTheme;
        var _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(132), GlobalStyles = (0, 
        _styledComponents.createGlobalStyle)(_templateObject);
    }, /* 255 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 0.5rem;\n  }\n" ], [ "\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 0.5rem;\n  }\n" ]), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(132), _styledComponents2 = _interopRequireDefault(_styledComponents), _IconButton = __webpack_require__(203), _IconButton2 = _interopRequireDefault(_IconButton), _Icons = __webpack_require__(204), _PropTypes = __webpack_require__(206), ButtonGroup = _styledComponents2.default.div(_templateObject), TouchNav = function(_Component) {
            function TouchNav() {
                return (0, _classCallCheck3.default)(this, TouchNav), (0, _possibleConstructorReturn3.default)(this, (TouchNav.__proto__ || (0, 
                _getPrototypeOf2.default)(TouchNav)).apply(this, arguments));
            }
            return (0, _inherits3.default)(TouchNav, _Component), (0, _createClass3.default)(TouchNav, [ {
                key: "render",
                value: function() {
                    var presentation = this.context.presentation;
                    return _react2.default.createElement(ButtonGroup, null, _react2.default.createElement(_IconButton2.default, {
                        disabled: presentation.isAtBeginning(),
                        onClick: presentation.goBack
                    }, _react2.default.createElement(_Icons.IconLeft, null)), _react2.default.createElement(_IconButton2.default, {
                        disabled: presentation.isAtEnd(),
                        onClick: presentation.goForward
                    }, _react2.default.createElement(_Icons.IconRight, null)));
                }
            } ]), TouchNav;
        }(_react.Component);
        TouchNav.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = TouchNav;
    }, /* 256 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _assign = __webpack_require__(69), _assign2 = _interopRequireDefault(_assign), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _cuid = __webpack_require__(257), _cuid2 = _interopRequireDefault(_cuid), _qs = __webpack_require__(258), _qs2 = _interopRequireDefault(_qs), _react = __webpack_require__(108), _PropTypes = __webpack_require__(206), parentWindowID = (0, 
        _cuid2.default)(), PresenterModePlugin = function(_Component) {
            function PresenterModePlugin(props, context) {
                (0, _classCallCheck3.default)(this, PresenterModePlugin);
                var _this = (0, _possibleConstructorReturn3.default)(this, (PresenterModePlugin.__proto__ || (0, 
                _getPrototypeOf2.default)(PresenterModePlugin)).call(this, props, context));
                return _this._parentWindowID = null, _this._presenterWindow = null, _this._onKeyDown = _this._onKeyDown.bind(_this), 
                _this._signalParent = _this._signalParent.bind(_this), _this._togglePresenterMode = _this._togglePresenterMode.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(PresenterModePlugin, _Component), (0, _createClass3.default)(PresenterModePlugin, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillMount",
                value: function() {
                    var presentation = this.context.presentation;
                    this._parentWindowID = _qs2.default.parse(window.location.search.slice(1)).parentWindowID, 
                    presentation.setPluginProps({
                        isPresenterMode: !!this._parentWindowID
                    });
                    var callback = function(_ref) {
                        var slideIndex = _ref.slideIndex, stepIndex = _ref.stepIndex;
                        presentation.goToSlide({
                            slideIndex: slideIndex,
                            stepIndex: stepIndex
                        });
                    };
                    this._parentWindowID || window[parentWindowID] ? this._parentWindowID && !window[this._parentWindowID] && (window[this._parentWindowID] = callback) : window[parentWindowID] = callback;
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState, nextContext) {
                    var presentation = this.context.presentation, slideIndex = presentation.getSlideIndex(), stepIndex = presentation.getStepIndex();
                    slideIndex === this._slideIndex && stepIndex === this._stepIndex || (this._slideIndex = slideIndex, 
                    this._stepIndex = stepIndex, this._parentWindowID ? this._signalParent({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }) : this._presenterWindow && this._syncPath({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }));
                }
            }, {
                key: "render",
                value: function() {
                    return null;
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    if ("INPUT" !== event.target.tagName) switch (event.key) {
                      case "p":
                      case "P":
                        this._parentWindowID || this._togglePresenterMode();
                    }
                }
            }, {
                key: "_signalParent",
                value: function(path) {
                    window.opener && ("function" != typeof window.opener[this._parentWindowID] ? window.close() : window.opener && window.opener[this._parentWindowID](path));
                }
            }, {
                key: "_togglePresenterMode",
                value: function(path) {
                    if (this._presenterWindow) this._presenterWindow.close(), this._presenterWindow = null; else {
                        var url = new window.URL(window.location.href);
                        url.search = "?" + _qs2.default.stringify((0, _assign2.default)(_qs2.default.parse(window.location.search.slice(1)), {
                            parentWindowID: parentWindowID
                        })), this._presenterWindow = window.open(url.toString(), "react-presents-notes");
                    }
                }
            }, {
                key: "_syncPath",
                value: function(path) {
                    this._presenterWindow && !this._presenterWindow.closed && this._presenterWindow[parentWindowID](path);
                }
            } ]), PresenterModePlugin;
        }(_react.Component);
        PresenterModePlugin.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = PresenterModePlugin;
    }, /* 257 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * cuid.js
	 * Collision-resistant UID generator for browsers and node.
	 * Sequential for fast db lookups and recency sorting.
	 * Safe for element IDs and server-side lookups.
	 *
	 * Extracted from CLCTR
	 *
	 * Copyright (c) Eric Elliott 2012
	 * MIT License
	 */
        /*global window, navigator, document, require, process, module */
        !function(app) {
            "use strict";
            var namespace = "cuid", c = 0, blockSize = 4, base = 36, discreteValues = Math.pow(base, blockSize), pad = function(num, size) {
                var s = "000000000" + num;
                return s.substr(s.length - size);
            }, randomBlock = function() {
                return pad((Math.random() * discreteValues << 0).toString(base), blockSize);
            }, safeCounter = function() {
                // this is not subliminal
                return c = c < discreteValues ? c : 0, c++, c - 1;
            }, api = function() {
                // Starting with a lowercase letter makes
                // it HTML element ID friendly.
                var // Prevent same-machine collisions.
                counter, letter = "c", // hard-coded allows for sequential access
                // timestamp
                // warning: this exposes the exact date and time
                // that the uid was created.
                timestamp = new Date().getTime().toString(base), // A few chars to generate distinct ids for different
                // clients (so different computers are far less
                // likely to generate the same id)
                fingerprint = api.fingerprint(), // Grab some more chars from Math.random()
                random = randomBlock() + randomBlock();
                return counter = pad(safeCounter().toString(base), blockSize), letter + timestamp + counter + fingerprint + random;
            };
            api.slug = function() {
                var counter, date = new Date().getTime().toString(36), print = api.fingerprint().slice(0, 1) + api.fingerprint().slice(-1), random = randomBlock().slice(-2);
                return counter = safeCounter().toString(36).slice(-4), date.slice(-2) + counter + print + random;
            }, api.globalCount = function() {
                // We want to cache the results of this
                var cache = function() {
                    var i, count = 0;
                    for (i in window) count++;
                    return count;
                }();
                return api.globalCount = function() {
                    return cache;
                }, cache;
            }, api.fingerprint = function() {
                return pad((navigator.mimeTypes.length + navigator.userAgent.length).toString(36) + api.globalCount().toString(36), 4);
            }, // don't change anything from here down.
            app.register ? app.register(namespace, api) : module.exports = api;
        }(this.applitude || this);
    }, /* 258 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var stringify = __webpack_require__(259), parse = __webpack_require__(262), formats = __webpack_require__(261);
        module.exports = {
            formats: formats,
            parse: parse,
            stringify: stringify
        };
    }, /* 259 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(260), formats = __webpack_require__(261), has = Object.prototype.hasOwnProperty, arrayPrefixGenerators = {
            brackets: function(prefix) {
                return prefix + "[]";
            },
            comma: "comma",
            indices: function(prefix, key) {
                return prefix + "[" + key + "]";
            },
            repeat: function(prefix) {
                return prefix;
            }
        }, isArray = Array.isArray, push = Array.prototype.push, pushToArray = function(arr, valueOrArray) {
            push.apply(arr, isArray(valueOrArray) ? valueOrArray : [ valueOrArray ]);
        }, toISO = Date.prototype.toISOString, defaultFormat = formats.default, defaults = {
            addQueryPrefix: !1,
            allowDots: !1,
            charset: "utf-8",
            charsetSentinel: !1,
            delimiter: "&",
            encode: !0,
            encoder: utils.encode,
            encodeValuesOnly: !1,
            format: defaultFormat,
            formatter: formats.formatters[defaultFormat],
            // deprecated
            indices: !1,
            serializeDate: function(date) {
                return toISO.call(date);
            },
            skipNulls: !1,
            strictNullHandling: !1
        }, isNonNullishPrimitive = function(v) {
            return "string" == typeof v || "number" == typeof v || "boolean" == typeof v || "symbol" == typeof v || "bigint" == typeof v;
        }, stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset) {
            var obj = object;
            if ("function" == typeof filter ? obj = filter(prefix, obj) : obj instanceof Date ? obj = serializeDate(obj) : "comma" === generateArrayPrefix && isArray(obj) && (obj = utils.maybeMap(obj, function(value) {
                return value instanceof Date ? serializeDate(value) : value;
            }).join(",")), null === obj) {
                if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key") : prefix;
                obj = "";
            }
            if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
                if (encoder) {
                    var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key");
                    return [ formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value")) ];
                }
                return [ formatter(prefix) + "=" + formatter(String(obj)) ];
            }
            var values = [];
            if ("undefined" == typeof obj) return values;
            var objKeys;
            if (isArray(filter)) objKeys = filter; else {
                var keys = Object.keys(obj);
                objKeys = sort ? keys.sort(sort) : keys;
            }
            for (var i = 0; i < objKeys.length; ++i) {
                var key = objKeys[i], value = obj[key];
                if (!skipNulls || null !== value) {
                    var keyPrefix = isArray(obj) ? "function" == typeof generateArrayPrefix ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
                    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
                }
            }
            return values;
        }, normalizeStringifyOptions = function(opts) {
            if (!opts) return defaults;
            if (null !== opts.encoder && void 0 !== opts.encoder && "function" != typeof opts.encoder) throw new TypeError("Encoder has to be a function.");
            var charset = opts.charset || defaults.charset;
            if ("undefined" != typeof opts.charset && "utf-8" !== opts.charset && "iso-8859-1" !== opts.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var format = formats.default;
            if ("undefined" != typeof opts.format) {
                if (!has.call(formats.formatters, opts.format)) throw new TypeError("Unknown format option provided.");
                format = opts.format;
            }
            var formatter = formats.formatters[format], filter = defaults.filter;
            return ("function" == typeof opts.filter || isArray(opts.filter)) && (filter = opts.filter), 
            {
                addQueryPrefix: "boolean" == typeof opts.addQueryPrefix ? opts.addQueryPrefix : defaults.addQueryPrefix,
                allowDots: "undefined" == typeof opts.allowDots ? defaults.allowDots : !!opts.allowDots,
                charset: charset,
                charsetSentinel: "boolean" == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                delimiter: "undefined" == typeof opts.delimiter ? defaults.delimiter : opts.delimiter,
                encode: "boolean" == typeof opts.encode ? opts.encode : defaults.encode,
                encoder: "function" == typeof opts.encoder ? opts.encoder : defaults.encoder,
                encodeValuesOnly: "boolean" == typeof opts.encodeValuesOnly ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
                filter: filter,
                formatter: formatter,
                serializeDate: "function" == typeof opts.serializeDate ? opts.serializeDate : defaults.serializeDate,
                skipNulls: "boolean" == typeof opts.skipNulls ? opts.skipNulls : defaults.skipNulls,
                sort: "function" == typeof opts.sort ? opts.sort : null,
                strictNullHandling: "boolean" == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling
            };
        };
        module.exports = function(object, opts) {
            var objKeys, filter, obj = object, options = normalizeStringifyOptions(opts);
            "function" == typeof options.filter ? (filter = options.filter, obj = filter("", obj)) : isArray(options.filter) && (filter = options.filter, 
            objKeys = filter);
            var keys = [];
            if ("object" != typeof obj || null === obj) return "";
            var arrayFormat;
            arrayFormat = opts && opts.arrayFormat in arrayPrefixGenerators ? opts.arrayFormat : opts && "indices" in opts ? opts.indices ? "indices" : "repeat" : "indices";
            var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
            objKeys || (objKeys = Object.keys(obj)), options.sort && objKeys.sort(options.sort);
            for (var i = 0; i < objKeys.length; ++i) {
                var key = objKeys[i];
                options.skipNulls && null === obj[key] || pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.formatter, options.encodeValuesOnly, options.charset));
            }
            var joined = keys.join(options.delimiter), prefix = options.addQueryPrefix === !0 ? "?" : "";
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            return options.charsetSentinel && (prefix += "iso-8859-1" === options.charset ? "utf8=%26%2310003%3B&" : "utf8=%E2%9C%93&"), 
            joined.length > 0 ? prefix + joined : "";
        };
    }, /* 260 */
    /***/
    function(module, exports) {
        "use strict";
        var has = Object.prototype.hasOwnProperty, isArray = Array.isArray, hexTable = function() {
            for (var array = [], i = 0; i < 256; ++i) array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
            return array;
        }(), compactQueue = function(queue) {
            for (;queue.length > 1; ) {
                var item = queue.pop(), obj = item.obj[item.prop];
                if (isArray(obj)) {
                    for (var compacted = [], j = 0; j < obj.length; ++j) "undefined" != typeof obj[j] && compacted.push(obj[j]);
                    item.obj[item.prop] = compacted;
                }
            }
        }, arrayToObject = function(source, options) {
            for (var obj = options && options.plainObjects ? Object.create(null) : {}, i = 0; i < source.length; ++i) "undefined" != typeof source[i] && (obj[i] = source[i]);
            return obj;
        }, merge = function merge(target, source, options) {
            /* eslint no-param-reassign: 0 */
            if (!source) return target;
            if ("object" != typeof source) {
                if (isArray(target)) target.push(source); else {
                    if (!target || "object" != typeof target) return [ target, source ];
                    (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) && (target[source] = !0);
                }
                return target;
            }
            if (!target || "object" != typeof target) return [ target ].concat(source);
            var mergeTarget = target;
            return isArray(target) && !isArray(source) && (mergeTarget = arrayToObject(target, options)), 
            isArray(target) && isArray(source) ? (source.forEach(function(item, i) {
                if (has.call(target, i)) {
                    var targetItem = target[i];
                    targetItem && "object" == typeof targetItem && item && "object" == typeof item ? target[i] = merge(targetItem, item, options) : target.push(item);
                } else target[i] = item;
            }), target) : Object.keys(source).reduce(function(acc, key) {
                var value = source[key];
                return has.call(acc, key) ? acc[key] = merge(acc[key], value, options) : acc[key] = value, 
                acc;
            }, mergeTarget);
        }, assign = function(target, source) {
            return Object.keys(source).reduce(function(acc, key) {
                return acc[key] = source[key], acc;
            }, target);
        }, decode = function(str, decoder, charset) {
            var strWithoutPlus = str.replace(/\+/g, " ");
            if ("iso-8859-1" === charset) // unescape never throws, no try...catch needed:
            return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
            // utf-8
            try {
                return decodeURIComponent(strWithoutPlus);
            } catch (e) {
                return strWithoutPlus;
            }
        }, encode = function(str, defaultEncoder, charset) {
            // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
            // It has been adapted here for stricter adherence to RFC 3986
            if (0 === str.length) return str;
            var string = str;
            if ("symbol" == typeof str ? string = Symbol.prototype.toString.call(str) : "string" != typeof str && (string = String(str)), 
            "iso-8859-1" === charset) return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
                return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
            });
            for (var out = "", i = 0; i < string.length; ++i) {
                var c = string.charCodeAt(i);
                45 === c || 46 === c || 95 === c || 126 === c || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 ? out += string.charAt(i) : c < 128 ? out += hexTable[c] : c < 2048 ? out += hexTable[192 | c >> 6] + hexTable[128 | 63 & c] : c < 55296 || c >= 57344 ? out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c] : (i += 1, 
                c = 65536 + ((1023 & c) << 10 | 1023 & string.charCodeAt(i)), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]);
            }
            return out;
        }, compact = function(value) {
            for (var queue = [ {
                obj: {
                    o: value
                },
                prop: "o"
            } ], refs = [], i = 0; i < queue.length; ++i) for (var item = queue[i], obj = item.obj[item.prop], keys = Object.keys(obj), j = 0; j < keys.length; ++j) {
                var key = keys[j], val = obj[key];
                "object" == typeof val && null !== val && refs.indexOf(val) === -1 && (queue.push({
                    obj: obj,
                    prop: key
                }), refs.push(val));
            }
            return compactQueue(queue), value;
        }, isRegExp = function(obj) {
            return "[object RegExp]" === Object.prototype.toString.call(obj);
        }, isBuffer = function(obj) {
            return !(!obj || "object" != typeof obj) && !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        }, combine = function(a, b) {
            return [].concat(a, b);
        }, maybeMap = function(val, fn) {
            if (isArray(val)) {
                for (var mapped = [], i = 0; i < val.length; i += 1) mapped.push(fn(val[i]));
                return mapped;
            }
            return fn(val);
        };
        module.exports = {
            arrayToObject: arrayToObject,
            assign: assign,
            combine: combine,
            compact: compact,
            decode: decode,
            encode: encode,
            isBuffer: isBuffer,
            isRegExp: isRegExp,
            maybeMap: maybeMap,
            merge: merge
        };
    }, /* 261 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var replace = String.prototype.replace, percentTwenties = /%20/g, util = __webpack_require__(260), Format = {
            RFC1738: "RFC1738",
            RFC3986: "RFC3986"
        };
        module.exports = util.assign({
            default: Format.RFC3986,
            formatters: {
                RFC1738: function(value) {
                    return replace.call(value, percentTwenties, "+");
                },
                RFC3986: function(value) {
                    return String(value);
                }
            }
        }, Format);
    }, /* 262 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(260), has = Object.prototype.hasOwnProperty, isArray = Array.isArray, defaults = {
            allowDots: !1,
            allowPrototypes: !1,
            arrayLimit: 20,
            charset: "utf-8",
            charsetSentinel: !1,
            comma: !1,
            decoder: utils.decode,
            delimiter: "&",
            depth: 5,
            ignoreQueryPrefix: !1,
            interpretNumericEntities: !1,
            parameterLimit: 1e3,
            parseArrays: !0,
            plainObjects: !1,
            strictNullHandling: !1
        }, interpretNumericEntities = function(str) {
            return str.replace(/&#(\d+);/g, function($0, numberStr) {
                return String.fromCharCode(parseInt(numberStr, 10));
            });
        }, parseArrayValue = function(val, options) {
            return val && "string" == typeof val && options.comma && val.indexOf(",") > -1 ? val.split(",") : val;
        }, isoSentinel = "utf8=%26%2310003%3B", charsetSentinel = "utf8=%E2%9C%93", parseValues = function(str, options) {
            var i, obj = {}, cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str, limit = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit, parts = cleanStr.split(options.delimiter, limit), skipIndex = -1, charset = options.charset;
            if (options.charsetSentinel) for (i = 0; i < parts.length; ++i) 0 === parts[i].indexOf("utf8=") && (parts[i] === charsetSentinel ? charset = "utf-8" : parts[i] === isoSentinel && (charset = "iso-8859-1"), 
            skipIndex = i, i = parts.length);
            for (i = 0; i < parts.length; ++i) if (i !== skipIndex) {
                var key, val, part = parts[i], bracketEqualsPos = part.indexOf("]="), pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
                pos === -1 ? (key = options.decoder(part, defaults.decoder, charset, "key"), val = options.strictNullHandling ? null : "") : (key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key"), 
                val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, "value");
                })), val && options.interpretNumericEntities && "iso-8859-1" === charset && (val = interpretNumericEntities(val)), 
                part.indexOf("[]=") > -1 && (val = isArray(val) ? [ val ] : val), has.call(obj, key) ? obj[key] = utils.combine(obj[key], val) : obj[key] = val;
            }
            return obj;
        }, parseObject = function(chain, val, options, valuesParsed) {
            for (var leaf = valuesParsed ? val : parseArrayValue(val, options), i = chain.length - 1; i >= 0; --i) {
                var obj, root = chain[i];
                if ("[]" === root && options.parseArrays) obj = [].concat(leaf); else {
                    obj = options.plainObjects ? Object.create(null) : {};
                    var cleanRoot = "[" === root.charAt(0) && "]" === root.charAt(root.length - 1) ? root.slice(1, -1) : root, index = parseInt(cleanRoot, 10);
                    options.parseArrays || "" !== cleanRoot ? !isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit ? (obj = [], 
                    obj[index] = leaf) : obj[cleanRoot] = leaf : obj = {
                        0: leaf
                    };
                }
                leaf = obj;
            }
            return leaf;
        }, parseKeys = function(givenKey, val, options, valuesParsed) {
            if (givenKey) {
                // Transform dot notation to bracket notation
                var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey, brackets = /(\[[^[\]]*])/, child = /(\[[^[\]]*])/g, segment = options.depth > 0 && brackets.exec(key), parent = segment ? key.slice(0, segment.index) : key, keys = [];
                if (parent) {
                    // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
                    if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) return;
                    keys.push(parent);
                }
                for (// Loop through children appending to the array until we hit depth
                var i = 0; options.depth > 0 && null !== (segment = child.exec(key)) && i < options.depth; ) {
                    if (i += 1, !options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1)) && !options.allowPrototypes) return;
                    keys.push(segment[1]);
                }
                // If there's a remainder, just add whatever is left
                return segment && keys.push("[" + key.slice(segment.index) + "]"), parseObject(keys, val, options, valuesParsed);
            }
        }, normalizeParseOptions = function(opts) {
            if (!opts) return defaults;
            if (null !== opts.decoder && void 0 !== opts.decoder && "function" != typeof opts.decoder) throw new TypeError("Decoder has to be a function.");
            if ("undefined" != typeof opts.charset && "utf-8" !== opts.charset && "iso-8859-1" !== opts.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var charset = "undefined" == typeof opts.charset ? defaults.charset : opts.charset;
            return {
                allowDots: "undefined" == typeof opts.allowDots ? defaults.allowDots : !!opts.allowDots,
                allowPrototypes: "boolean" == typeof opts.allowPrototypes ? opts.allowPrototypes : defaults.allowPrototypes,
                arrayLimit: "number" == typeof opts.arrayLimit ? opts.arrayLimit : defaults.arrayLimit,
                charset: charset,
                charsetSentinel: "boolean" == typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel,
                comma: "boolean" == typeof opts.comma ? opts.comma : defaults.comma,
                decoder: "function" == typeof opts.decoder ? opts.decoder : defaults.decoder,
                delimiter: "string" == typeof opts.delimiter || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
                // eslint-disable-next-line no-implicit-coercion, no-extra-parens
                depth: "number" == typeof opts.depth || opts.depth === !1 ? +opts.depth : defaults.depth,
                ignoreQueryPrefix: opts.ignoreQueryPrefix === !0,
                interpretNumericEntities: "boolean" == typeof opts.interpretNumericEntities ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
                parameterLimit: "number" == typeof opts.parameterLimit ? opts.parameterLimit : defaults.parameterLimit,
                parseArrays: opts.parseArrays !== !1,
                plainObjects: "boolean" == typeof opts.plainObjects ? opts.plainObjects : defaults.plainObjects,
                strictNullHandling: "boolean" == typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling
            };
        };
        module.exports = function(str, opts) {
            var options = normalizeParseOptions(opts);
            if ("" === str || null === str || "undefined" == typeof str) return options.plainObjects ? Object.create(null) : {};
            for (var tempObj = "string" == typeof str ? parseValues(str, options) : str, obj = options.plainObjects ? Object.create(null) : {}, keys = Object.keys(tempObj), i = 0; i < keys.length; ++i) {
                var key = keys[i], newObj = parseKeys(key, tempObj[key], options, "string" == typeof str);
                obj = utils.merge(obj, newObj, options);
            }
            return utils.compact(obj);
        };
    }, /* 263 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _reactRouterDom = __webpack_require__(239), _styledComponents = __webpack_require__(132), _PropTypes = __webpack_require__(206), Slide = function(_Component) {
            function Slide(props, context) {
                (0, _classCallCheck3.default)(this, Slide);
                var _this = (0, _possibleConstructorReturn3.default)(this, (Slide.__proto__ || (0, 
                _getPrototypeOf2.default)(Slide)).call(this, props, context));
                return _this._stepIndex = 0, _this._renderComponent = _this._renderComponent.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(Slide, _Component), (0, _createClass3.default)(Slide, [ {
                key: "componentWillMount",
                value: function() {
                    var presentation = this.context.presentation, _presentation$getSlid = presentation.getSlideMetadata(this), path = _presentation$getSlid.path, slideIndex = _presentation$getSlid.slideIndex;
                    this._path = path, this._slideIndex = slideIndex;
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this._stepIndex = 0;
                }
            }, {
                key: "getChildContext",
                value: function() {
                    return {
                        slide: this
                    };
                }
            }, {
                key: "getNumSteps",
                value: function() {
                    return this._numSteps || this._stepIndex + 1;
                }
            }, {
                key: "registerStep",
                value: function(index) {
                    this._stepIndex = Math.max(this._stepIndex, index);
                }
            }, {
                key: "render",
                value: function() {
                    return _react2.default.createElement(_reactRouterDom.Route, {
                        exact: !0,
                        path: this._path,
                        render: this._renderComponent
                    });
                }
            }, {
                key: "setNumSteps",
                value: function(numSteps) {
                    this._numSteps = numSteps;
                }
            }, {
                key: "_renderComponent",
                value: function() {
                    var _context = this.context, pluginProps = _context.pluginProps, presentation = _context.presentation, _props = this.props, Component = _props.component, render = _props.render, isPresenterMode = pluginProps.isPresenterMode, slideIndex = this._slideIndex, stepIndex = presentation.getStepIndex(), rendered = void 0;
                    return rendered = "function" == typeof render ? render({
                        isPresenterMode: isPresenterMode,
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }) : _react2.default.createElement(Component, {
                        isPresenterMode: isPresenterMode,
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }), _react2.default.createElement(_styledComponents.ThemeProvider, {
                        theme: {
                            isPresenterMode: isPresenterMode
                        }
                    }, rendered);
                }
            } ]), Slide;
        }(_react.Component);
        Slide.childContextTypes = {
            slide: _PropTypes.slideContext.isRequired
        }, Slide.contextTypes = {
            pluginProps: _propTypes2.default.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = Slide;
    }, /* 264 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(100), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(108), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(109), _propTypes2 = _interopRequireDefault(_propTypes), _PropTypes = __webpack_require__(206), Step = function(_Component) {
            function Step() {
                return (0, _classCallCheck3.default)(this, Step), (0, _possibleConstructorReturn3.default)(this, (Step.__proto__ || (0, 
                _getPrototypeOf2.default)(Step)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Step, _Component), (0, _createClass3.default)(Step, [ {
                key: "componentWillMount",
                value: function() {
                    var slide = this.context.slide, _props = this.props, index = _props.index, maxIndex = _props.maxIndex;
                    maxIndex < 1 / 0 ? slide.registerStep(maxIndex) : slide.registerStep(index);
                }
            }, {
                key: "render",
                value: function() {
                    var _context = this.context, pluginProps = _context.pluginProps, presentation = _context.presentation, _props2 = this.props, children = _props2.children, exact = _props2.exact, index = _props2.index, maxIndex = _props2.maxIndex, isPresenterMode = pluginProps.isPresenterMode, stepIndex = presentation.getStepIndex(), match = void 0;
                    return match = exact ? stepIndex === index : stepIndex >= index && stepIndex <= maxIndex, 
                    match ? children : isPresenterMode ? _react2.default.createElement("div", {
                        style: {
                            opacity: .35
                        }
                    }, children) : null;
                }
            } ]), Step;
        }(_react.Component);
        Step.contextTypes = {
            pluginProps: _propTypes2.default.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired,
            slide: _PropTypes.slideContext.isRequired
        }, Step.defaultProps = {
            maxIndex: 1 / 0
        }, exports.default = Step;
    }, /* 265 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  height: 100%;\n  background-color: #222;\n  color: #fff;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n" ], [ "\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  height: 100%;\n  background-color: #222;\n  color: #fff;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n" ]), _styledComponents = __webpack_require__(132), _styledComponents2 = _interopRequireDefault(_styledComponents), _presenterSlideStyle = __webpack_require__(145), _presenterSlideStyle2 = _interopRequireDefault(_presenterSlideStyle);
        exports.default = _styledComponents2.default.div(_templateObject, _presenterSlideStyle2.default);
    } ]);
});
//# sourceMappingURL=react-presents.js.map